.packageName <- "cli"
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/aaa-utils.R"

`%||%` <- function(l, r) if (is.null(l)) r else l

new_class <- function(class_name, ...) {
  structure(as.environment(list(...)), class = class_name)
}

make_space <- function(len) {
  strrep(" ", len)
}

strrep <- function(x, times) {
  x <- as.character(x)
  if (length(x) == 0L) return(x)
  r <- .mapply(
    function(x, times) {
      if (is.na(x) || is.na(times)) return(NA_character_)
      if (times <= 0L) return("")
      paste0(replicate(times, x), collapse = "")
    },
    list(x = x, times = times),
    MoreArgs = list()
  )

  res <- unlist(r, use.names = FALSE)
  Encoding(res) <- Encoding(x)
  res
}

is_latex_output <- function() {
  if (!("knitr" %in% loadedNamespaces())) return(FALSE)
  get("is_latex_output", asNamespace("knitr"))()
}

is_windows <-  function() {
  .Platform$OS.type == "windows"
}

apply_style <- function(text, style, bg = FALSE) {
  if (identical(text, ""))
    return(text)

  if (is.function(style)) {
    style(text)
  } else if (is.character(style)) {
    make_ansi_style(style, bg = bg)(text)
  } else if (is.null(style)) {
    text
  } else {
    throw(cli_error(
      "{.arg style} must be a color name or an ANSI style function",
      "i" = "{.arg style} is {.typeof {style}}"
    ))
  }
}

vcapply <- function(X, FUN, ..., USE.NAMES = TRUE) {
  vapply(X, FUN, FUN.VALUE = character(1), ..., USE.NAMES = USE.NAMES)
}

viapply <- function(X, FUN, ..., USE.NAMES = TRUE) {
  vapply(X, FUN, FUN.VALUE = integer(1), ..., USE.NAMES = USE.NAMES)
}

vlapply <- function(X, FUN, ..., USE.NAMES = TRUE) {
  vapply(X, FUN, FUN.VALUE = logical(1), ..., USE.NAMES = USE.NAMES)
}

rpad <- function(x, width = NULL) {
  if (!length(x)) return(x)
  w <- nchar(x, type = "width")
  if (is.null(width)) width <- max(w)
  paste0(x, strrep(" ", pmax(width - w, 0)))
}

lpad <- function(x, width = NULL) {
  if (!length(x)) return(x)
  w <- nchar(x, type = "width")
  if (is.null(width)) width <- max(w)
  paste0(strrep(" ", pmax(width - w, 0)), x)
}

tail_na <- function(x, n = 1) {
  utils::tail(c(rep(NA, n), x), n)
}

dedent <- function(x, n = 2) {
  first_n_char <- strsplit(ansi_substr(x, 1, n), "", fixed = TRUE)[[1]]
  n_space <- cumsum(first_n_char == " ")
  d_n_space <- diff(c(0, n_space))
  first_not_space <- utils::head(c(which(d_n_space == 0), n + 1), 1)
  ansi_substr(x, first_not_space, nchar(x))
}

new_uuid <- (function() {
  cnt <- 0
  function() {
    cnt <<- cnt + 1
    paste0("cli-", clienv$pid, "-", cnt)
  }
})()

na.omit <- function(x) {
  if (is.atomic(x)) x[!is.na(x)] else x
}

last <- function(x) {
  utils::tail(x, 1)[[1]]
}

str_tail <- function(x) {
  substr(x, 2, nchar(x))
}

push <- function(l, el, name = NULL) {
  c(l, structure(list(el), names = name))
}

try_silently <- function(expr) {
  suppressWarnings(tryCatch(expr, error = function(x) x))
}

random_id <- local({
  i <- 0
  function() {
    i <<- i + 1
    paste0("FCkNXbE-", i)
  }
})

random_marker <- "ImzV8dciA4cn4POI"

str_trim <- function(x) {
  sub("^\\s+", "", sub("\\s+$", "", x))
}

last_character <- function(x) {
  substr(x, nchar(x), nchar(x))
}

first_character <- function(x) {
  substr(x, 1, 1)
}

second_character <- function(x) {
  substr(x, 2, 2)
}

is_alnum <- function(x, ok = "") {
  grepl(paste0("^[[:alnum:]/_.", ok, "]*$"), x)
}

os_type <- function() {
  .Platform$OS.type
}

leading_space <- function(x) {
  sub("^([\\s\u00a0]*).*$", "\\1", x, perl = TRUE)
}

trailing_space <- function(x) {
  sub("^.*[^\\s\u00a0]([\\s\u00a0]*)$", "\\1", x, perl = TRUE)
}

get_rstudio_theme <- function() {
  suppressWarnings(rstudioapi::getThemeInfo())
}

# ansi_strtrim might not support NAs

abbrev <- function(x, len = 10) {
  # this is better than strtrim() because it adds ...
  ansi_strtrim(x, len)
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/aab-rstudio-detect.R"

rstudio <- local({

  standalone_env <- environment()
  parent.env(standalone_env) <- baseenv()

  # -- Collect data ------------------------------------------------------

  data <- NULL

  get_data <- function() {
    envs <- c(
      "R_BROWSER",
      "R_PDFVIEWER",
      "RSTUDIO",
      "RSTUDIO_TERM",
      "RSTUDIO_CLI_HYPERLINKS",
      "RSTUDIO_CONSOLE_COLOR",
      "RSTUDIOAPI_IPC_REQUESTS_FILE",
      "XPC_SERVICE_NAME",
      "ASCIICAST")

    d <- list(
      pid = Sys.getpid(),
      envs = Sys.getenv(envs),
      api = tryCatch(
        asNamespace("rstudioapi")$isAvailable(),
        error = function(err) FALSE
      ),
      tty = isatty(stdin()),
      gui = .Platform$GUI,
      args = commandArgs(),
      search = search()
    )

    if (d$api) {
      ns <- asNamespace("rstudioapi")
      d$ver <- if (d$api) ns$getVersion()
      new_api <- package_version(getNamespaceVersion(ns)) >= "0.17.0"
      d$desktop <- if (new_api) ns$getMode() else ns$versionInfo()$mode
    }

    d
  }

  # -- Auto-detect environment -------------------------------------------

  is_rstudio <- function() {
    Sys.getenv("RSTUDIO") == "1"
  }

  detect <- function(clear_cache = FALSE) {
    # Check this up front, in case we are in a testthat 3e test block.
    # We cannot cache this, because we might be in RStudio in reality.
    if (!is_rstudio()) {
      return(get_caps(type = "not_rstudio"))
    }

    # Cached?
    if (clear_cache) data <<- NULL
    if (!is.null(data)) return(get_caps(data))

    if ((rspid <- Sys.getenv("RSTUDIO_SESSION_PID")) != "" &&
        any(c("ps", "cli") %in% loadedNamespaces())) {
      detect_new(rspid, clear_cache)
    } else {
      detect_old(clear_cache)
    }
  }

  get_parentpid <- function() {
    if ("cli" %in% loadedNamespaces()) {
      asNamespace("cli")$get_ppid()
    } else {
      ps::ps_ppid()
    }
  }

  detect_new <- function(rspid, clear_cache) {
    mypid <- Sys.getpid()

    new <- get_data()

    if (mypid == rspid) {
      return(get_caps(new, type = "rstudio_console"))
    }

    # need explicit namespace reference because we mess up the environment
    parentpid <- get_parentpid()
    pane <- Sys.getenv("RSTUDIO_CHILD_PROCESS_PANE")

    # this should not happen, but be defensive and fall back
    if (pane == "") return(detect_old(clear_cache))

    # direct subprocess
    new$type <- if (rspid == parentpid) {

      if (pane == "job") {
        "rstudio_job"

      } else if (pane == "build") {
        "rstudio_build_pane"

      } else if (pane == "render") {
        "rstudio_render_pane"

      } else if (pane == "terminal" && new$tty &&
                 new$envs["ASCIICAST"] != "true") {
        # not possible, because there is a shell in between, just in case
        "rstudio_terminal"

      } else {
        # don't know what kind of direct subprocess
        "rstudio_subprocess"
      }

    } else if (pane == "terminal" && new$tty &&
               new$envs[["ASCIICAST"]] != "true") {
      # not a direct subproces, so check other criteria as well
      "rstudio_terminal"

    } else {
      # don't know what kind of subprocess
      "rstudio_subprocess"
    }

    get_caps(new)
  }

  detect_old <- function(clear_cache = FALSE) {

    # Cache unless told otherwise
    cache <- TRUE
    new <- get_data()

    new$type <- if (new$envs[["RSTUDIO"]] != "1") {
      # 1. Not RStudio at all
      "not_rstudio"

    } else if (new$gui == "RStudio" && new$api) {
      # 2. RStudio console, properly initialized
      "rstudio_console"

    } else if (! new$api && basename(new$args[1]) == "RStudio") {
      # 3. RStudio console, initializing
      cache <- FALSE
      "rstudio_console_starting"

    } else if (new$gui == "Rgui") {
      # Still not RStudio, but Rgui that was started from RStudio
      "not_rstudio"

    } else if (new$tty && new$envs[["ASCIICAST"]] != "true") {
      # 4. R in the RStudio terminal
      # This could also be a subprocess of the console or build pane
      # with a pseudo-terminal. There isn't really a way to rule that
      # out, without inspecting some process data with ps::ps_*().
      # At least we rule out asciicast
      "rstudio_terminal"

    } else if (! new$tty &&
               new$envs[["RSTUDIO_TERM"]] == "" &&
               new$envs[["R_BROWSER"]] == "false" &&
               new$envs[["R_PDFVIEWER"]] == "false" &&
               is_build_pane_command(new$args)) {
      # 5. R in the RStudio build pane
      # https://github.com/rstudio/rstudio/blob/main/src/cpp/session/
      # modules/build/SessionBuild.cpp#L231-L240
      "rstudio_build_pane"

    } else if (new$envs[["RSTUDIOAPI_IPC_REQUESTS_FILE"]] != "" &&
               grepl("rstudio", new$envs[["XPC_SERVICE_NAME"]], fixed = TRUE)) {
      # RStudio job, XPC_SERVICE_NAME=0 in the subprocess of a job
      # process. Hopefully this is reliable.
      "rstudio_job"

    } else if (new$envs[["RSTUDIOAPI_IPC_REQUESTS_FILE"]] != "" &&
               any(grepl("SourceWithProgress.R", new$args))) {
      # Or we can check SourceWithProgress.R in the command line, see
      # https://github.com/r-lib/cli/issues/367
      "rstudio_job"

    } else {
      # Otherwise it is a subprocess of the console, terminal or
      # build pane, and it is hard to say which, so we do not try.
      "rstudio_subprocess"
    }

    installing <- Sys.getenv("R_PACKAGE_DIR", "")
    if (cache && installing == "") data <<- new

    get_caps(new)
  }

  is_build_pane_command <- function(args) {
    cmd <- gsub("[\"']", "", args[[length(args)]], useBytes = TRUE)
    calls <- c(
      "devtools::build",
      "devtools::test",
      "devtools::check",
      "testthat::test_file"
    )
    any(vapply(calls, grepl, logical(1), cmd, useBytes = TRUE))
  }

  # -- Capabilities ------------------------------------------------------

  caps <- list()

  caps$not_rstudio <- function(data) {
    list(
      type = "not_rstudio",
      dynamic_tty = FALSE,
      ansi_tty = FALSE,
      ansi_color = FALSE,
      num_colors = 1L,
      hyperlink = FALSE,
      has_canonical_mode = FALSE
    )
  }

  caps$rstudio_console <- function(data) {
    list(
      type = "rstudio_console",
      dynamic_tty = TRUE,
      ansi_tty = FALSE,
      ansi_color = data$envs[["RSTUDIO_CONSOLE_COLOR"]] != "",
      num_colors = as.integer(data$envs[["RSTUDIO_CONSOLE_COLOR"]]),
      hyperlink = data$envs[["RSTUDIO_CLI_HYPERLINKS"]] != "",
      has_canonical_mode = FALSE
    )
  }

  caps$rstudio_console_starting <- function(data) {
    res <- caps$rstudio_console(data)
    res$type <- "rstudio_console_starting"
    res
  }

  caps$rstudio_terminal <- function(data) {
    list(
      type = "rstudio_terminal",
      dynamic_tty = TRUE,
      ansi_tty = FALSE,
      ansi_color = FALSE,
      num_colors = 1L,
      hyperlink = FALSE,
      has_canonical_mode = FALSE
    )
  }

  caps$rstudio_build_pane <- function(data) {
    list(
      type = "rstudio_build_pane",
      dynamic_tty = TRUE,
      ansi_tty = FALSE,
      ansi_color = data$envs[["RSTUDIO_CONSOLE_COLOR"]] != "",
      num_colors = as.integer(data$envs[["RSTUDIO_CONSOLE_COLOR"]]),
      hyperlink = data$envs[["RSTUDIO_CLI_HYPERLINKS"]] != "",
      has_canonical_mode = FALSE
    )
  }

  caps$rstudio_job <- function(data) {
    list(
      type = "rstudio_job",
      dynamic_tty = FALSE,
      ansi_tty = FALSE,
      ansi_color = data$envs[["RSTUDIO_CONSOLE_COLOR"]] != "",
      num_colors = as.integer(data$envs[["RSTUDIO_CONSOLE_COLOR"]]),
      hyperlink = data$envs[["RSTUDIO_CLI_HYPERLINKS"]] != "",
      has_canonical_mode = FALSE
    )
  }

  caps$rstudio_render_pane <- function(data) {
    list(
      type = "rstudio_render_pane",
      dynamic_tty = TRUE,
      ansi_tty = FALSE,
      ansi_color = FALSE,
      num_colors = 1L,
      hyperlink = FALSE,
      has_canonical_mode = FALSE
    )
  }

  caps$rstudio_subprocess <- function(data) {
    list(
      type = "rstudio_subprocess",
      dynamic_tty = FALSE,
      ansi_tty = FALSE,
      ansi_color = FALSE,
      num_colors = 1L,
      hyperlink = FALSE,
      has_canonical_mode = FALSE
    )
  }

  get_caps <- function(data, type = data$type) caps[[type]](data)

  structure(
    list(
      .internal = standalone_env,
      is_rstudio = is_rstudio,
      detect = detect
    ),
    class = c("standalone_rstudio_detect", "standalone")
  )
})
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/ansi-hyperlink.R"

#' Auto-linking existing styles
#'
#' They keep formatting. It is not possible to use a different link text
#' with them. We could add link text support, but theming is applied to the
#' result of these tags, and it would look weird for link text. (I.e. if
#' there is link text you don't want to append `()` to the function name,
#' etc.)
#'
#' N | Goal                                        | Input                           |Links to (link text is always the verbatim content, styled)
#' --|---------------------------------------------|---------------------------------|---------------------------------------------------------------------
#' 1 | auto-link emails                            | `{.email foo@bar.com}`          | `mailto:foo@bar.com`
#' 2 | auto-link file                              | `{.file path/file}`             | `file:///abs/path/dile`
#' 3 | auto-link file with line and column numbers | `{.file /abs/path:line:col}`    | `file:///abs/path:line:col`, `params = list(line = line, col = col)`
#' 4 | auto-link function                          | `{.fun pkg::fun}`               | `x-r-help:pkg::fun`
#' 5 | mention function w/o package                | `{.fun fun}`                    | no link is created for this form
#' 6 | auto-link url                               | `{.url url}`                    | `url`
#'
#' ## New styles to create links
#'
#' These all have link text support, via the `[text](link)` markdown syntax.
#'
#' N | Goal                                        | Input                           | Link text         | Links to                 | Non-link form
#' --|---------------------------------------------|---------------------------------|-------------------|--------------------------|------------------------------------
#' 7 | link qualified function name to help        | `{.help pkg::fun}`              | `{.fun pkg::fun}` | `x-r-help:pkg::fun`      | `{.fun ?pkg::fun}`
#' 8 | link to function with link text             | `{.help [text](pkg::fun)}`      | `text`            | `x-r-help:pkg::fun`      | `text ({.fun pkg::fun})`
#' 9 | link to topic                               | `{.topic pkg::topic}`           | `pkg::topic`      | `x-r-help:pkg::topic`    | `{.code pkg::topic}`
#' 10| link to topic with link text                | `{.topic [text](pkg::topic)}`   | `text`            | `x-r-help:pkg::topic`    | `text ({.code pkg::topic})`
#' 11| link url                                    | `{.href url}`                   | `{.url url}`      | `url`                    | `{.url url}`
#' 12| link url with link text                     | `{.href [text](url)}`           | `text`            | `url`                    | `text ({.url url})`
#' 13| link running expr                           | `{.run expr}`                   | `{.code expr}`    | `x-r-run:expr`           | `{.code expr}`
#' 14| link running expr, show code                | `{.run [code](expr)}`           | `{.code code}`    | `x-r-run:expr`           | `{.code expr}`
#' 15| link to vignette                            | `{.vignette pkg::name}`         | `pkg::name`       | `x-r-vignette:pkg::name` | `{.code vignette(pkg::name)}`
#' 16| link to vignette with link text             | `{.vignette [text](pkg::name)}` | `text`            | `x-r-vignette:pkg::name` | `text ({.code vignette(pkg::name)})`
#'
#' @name cli-links
#' @noRd
NULL

make_link <- function(txt, type = c("email", "file", "fun", "help", "href",
                                    "run", "topic", "url", "vignette")) {
  type <- match.arg(type)

  switch(
    type,
    email    = make_link_email(txt),
    file     = make_link_file(txt),
    fun      = make_link_fun(txt),
    help     = make_link_help(txt),
    href     = make_link_href(txt),
    run      = make_link_run(txt),
    topic    = make_link_topic(txt),
    url      = make_link_url(txt),
    vignette = make_link_vignette(txt),
    throw(cli_error("Unknown hyperlink type: {.code {type}}, internal cli error")) # nocov
  )
}

# -- {.email} -------------------------------------------------------------

make_link_email <- function(txt) {
  style_hyperlink(txt, paste0("mailto:", txt))
}

# -- {.file} and {.path} --------------------------------------------------

# if txt already contains a hyperlink, then we do not add another link
# this is needed because some packages, e.g. roxygen2 currently create
# links to files manually:
# https://github.com/r-lib/roxygen2/blob/3ddfd7f2e35c3a71d5705ab4f49e851cd8da306d/R/utils.R#L91

make_link_file <- function(txt) {
  ret <- txt
  linked <- grepl("\007|\033\\\\", txt)
  ret[!linked] <- vcapply(which(!linked), function(i) {
    params <- parse_file_link_params(txt[i])
    link <- construct_file_link(params)
    style_hyperlink(
      txt[i],
      link$url,
      params = link$params
    )
  })
  ret
}

parse_file_link_params <- function(txt) {
  pattern <- "^(?<path>.*?)(?::(?<line>\\d*))?(?::(?<column>\\d*))?$"
  matches <- re_match(txt, pattern)
  ret <- as.list(matches)
  ret[!nzchar(ret)] <- list(NULL)
  if (is.null(ret[["path"]])) ret[["path"]] <- ""
  ret
}

construct_file_link <- function(params) {
  fmt <- get_config_chr("hyperlink_file_url_format")

  if (is.null(fmt)) {
    return(construct_file_link_OG(params))
  }

  params$path <- sub("^file://", "", params$path)
  params$path <- path.expand(params$path)

  looks_absolute <- function(path) {
    grepl("^/", params$path) || (is_windows() && grepl("^[a-zA-Z]:", params$path))
  }
  if (!looks_absolute(params$path)) {
    params$path <- file.path(getwd(), params$path)
  }
  if (!grepl("^/", params$path)) {
    params$path <- paste0("/", params$path)
  }

  res <- interpolate_parts(fmt, params)
  list(url = res)
}

# the order of operations is very intentional and important:
# column, then line, then path
# relates to how interpolate_part() works
interpolate_parts <- function(fmt, params) {
  res <- interpolate_part(fmt, "column", params$column)
  res <- interpolate_part(res, "line", params$line)
  interpolate_part(res, "path", params$path)
}

# interpolate a part, if possible
# if no placeholder for part, this is a no-op
# if placeholder exists, but no value to fill, remove placeholder (and everything after it!)
interpolate_part <- function(fmt, part = c("column", "line", "path"), value = NULL) {
  part <- match.arg(part)
  re <- glue(
    "^(?<before>.*)(?<part>\\{<<<part>>>\\})(?<after>.*?)$",
    .open = "<<<", .close = ">>>"
  )
  m <- re_match(fmt, re)

  if (is.na(m$part) || !nzchar(m$part)) {
    return(fmt)
  }

  if (is.null(value) || !nzchar(value)) {
    return(sub("}[^}]*$", "}", m$before))
  }

  paste0(m$before, value, m$after)
}

# handle the iterm and RStudio cases, which predated the notion of configuring
# the file hyperlink format
construct_file_link_OG <- function(params) {
  params$path <- abs_path(params$path)

  if (Sys.getenv("R_CLI_HYPERLINK_STYLE") == "iterm") {
    fmt <- "{path}#{line}:{column}"
    res <- interpolate_parts(fmt, params)
    return(list(url = res))
  }

  # RStudio takes line and col via params
  loc <- if (is.null(params$line)) {
    NULL
  } else {
    list(line = params$line, col = params$column %||% 1)
  }

  list(url = params$path, params = loc)
}

abs_path <- function(x) {
  x <- path.expand(x)
  vcapply(x, abs_path1, USE.NAMES = FALSE)
}

abs_path1 <- function(x) {
  if (grepl("^file://", x)) return(x)
  if (grepl("^/", x)) return(paste0("file://", x))
  if (is_windows() && grepl("^[a-zA-Z]:", x)) return(paste0("file://", x))
  paste0("file://", file.path(getwd(), x))
}

# -- {.fun} ---------------------------------------------------------------

make_link_fun <- function(txt) {
  tolink <- grepl("::", txt, fixed = TRUE)
  linked <- grepl("\007|\033\\\\", txt)
  todo <- tolink & !linked
  if (!any(todo)) return(txt)

  sprt <- ansi_hyperlink_types()$help
  if (!sprt) {
    return(txt)
  }

  fmt <- get_hyperlink_format("help")
  # the format has a placeholder for 'topic'
  topic <- txt[todo]
  done <- style_hyperlink(text = topic, url = glue(fmt))

  txt[todo] <- done

  txt
}

# -- {.help} --------------------------------------------------------------

make_link_help <- function(txt) {
  mch <- re_match(txt, "^\\[(?<text>.*)\\]\\((?<url>.*)\\)$")
  text <- ifelse(is.na(mch$text), txt, mch$text)
  topic <- ifelse(is.na(mch$url), txt, mch$url)

  sprt <- ansi_hyperlink_types()$help
  if (!sprt) {
    topic2 <- vcapply(topic, function(x) format_inline("{.fun ?{x}}"))
    return(ifelse(text == topic, topic2, paste0(text, " (", topic2, ")")))
  }

  fmt <- get_hyperlink_format("help")
  style_hyperlink(text = text, url = glue(fmt))
}

# -- {.href} --------------------------------------------------------------

make_link_href <- function(txt) {
  mch <- re_match(txt, "^\\[(?<text>.*)\\]\\((?<url>.*)\\)$")
  text <- ifelse(is.na(mch$text), txt, mch$text)
  url <- ifelse(is.na(mch$url), txt, mch$url)
  if (ansi_has_hyperlink_support()) {
    link <- style_hyperlink(text = text, url = url)
    style <- is.na(mch$text)
    link[style] <- vcapply(
      url[style],
      function(url1) format_inline("{.url {url1}}")
    )
    link
  } else {
    url2 <- vcapply(url, function(url1) format_inline("{.url {url1}}"))
    ifelse(text == url, url2, paste0(text, " (", url2, ")"))
  }
}

# -- {.run} ---------------------------------------------------------------

make_link_run <- function(txt) {
  mch <- re_match(txt, "^\\[(?<text>.*)\\]\\((?<url>.*)\\)$")
  text <- ifelse(is.na(mch$text), txt, mch$text)
  code <- ifelse(is.na(mch$url), txt, mch$url)

  sprt <- ansi_hyperlink_types()$run
  if (!sprt) {
    return(vcapply(text, function(code1) format_inline("{.code {code1}}")))
  }

  fmt <- get_hyperlink_format("run")
  style_hyperlink(text = text, url = glue(fmt))
}

# -- {.topic} -------------------------------------------------------------

make_link_topic <- function(txt) {
  mch <- re_match(txt, "^\\[(?<text>.*)\\]\\((?<url>.*)\\)$")
  text <- ifelse(is.na(mch$text), txt, mch$text)
  topic <- ifelse(is.na(mch$url), txt, mch$url)

  sprt <- ansi_hyperlink_types()$help
  if (!sprt) {
    topic2 <- vcapply(topic, function(x) format_inline("{.code ?{x}}"))
    return(ifelse(text == topic, topic2, paste0(text, " (", topic2, ")")))
  }

  fmt <- get_hyperlink_format("help")
  style_hyperlink(text = text, url = glue(fmt))
}

# -- {.url} ---------------------------------------------------------------

make_link_url <- function(txt) {
  linked <- grepl("\007|\033\\\\", txt)
  if (all(linked)) return(txt)
  txt[!linked] <- style_hyperlink(txt[!linked], txt[!linked])
  txt
}

# -- {.vignette} ----------------------------------------------------------

make_link_vignette <- function(txt) {
  mch <- re_match(txt, "^\\[(?<text>.*)\\]\\((?<url>.*)\\)$")
  text <- ifelse(is.na(mch$text), txt, mch$text)
  vignette <- ifelse(is.na(mch$url), txt, mch$url)

  sprt <- ansi_hyperlink_types()$vignette
  if (!sprt) {
    vignette2 <- vcapply(vignette, function(x) format_inline("{.code vignette({x})}"))
    return(ifelse(text == vignette, vignette2, paste0(text, " (", vignette2, ")")))
  }

  fmt <- get_hyperlink_format("vignette")
  style_hyperlink(text = text, url = glue(fmt))
}

#' Terminal Hyperlinks
#'
#' `ansi_hyperlink()` creates an ANSI hyperlink.
#'
#' @details
#' This function is currently experimental. In particular, many of the
#' `ansi_*()` functions do not support it properly.
#'
#' `ansi_has_hyperlink_support()` checks if the current `stdout()`
#' supports hyperlinks.
#'
#' See also
#' <https://gist.github.com/egmontkob/eb114294efbcd5adb1944c9f3cb5feda>.
#'
#' @param text Text to show. `text` and `url` are recycled to match their
#'   length, via a `paste0()` call.
#' @param url URL to link to.
#' @param params A named character vector of additional parameters, or `NULL`.
#' @return Styled `cli_ansi_string` for `style_hyperlink()`.
#'   Logical scalar for `ansi_has_hyperlink_support()`.
#'
#' @export
#' @examples
#' cat("This is an", style_hyperlink("R", "https://r-project.org"), "link.\n")

style_hyperlink <- function(text, url, params = NULL) {
  params <- if (length(params)) {
    paste(
      names(params), "=", params,
      collapse = ":"
    )
  }

  if (Sys.getenv("R_CLI_HYPERLINK_MODE") == "posix") {
    ST <- "\033\\"
  } else {
    ST <- "\u0007"
  }

  out <- if (ansi_has_hyperlink_support()) {
    paste0("\u001B]8;", params, ";", url, ST, text, "\u001B]8;;", ST)
  } else {
    text
  }

  class(out) <- c("cli_ansi_string", "ansi_string", "character")
  out
}

#' @export
#' @rdname style_hyperlink
#' @examples
#' ansi_has_hyperlink_support()

ansi_has_hyperlink_support <- function() {

  ## Hyperlinks forced?
  enabled <- getOption("cli.hyperlink", getOption("crayon.hyperlink"))
  if (!is.null(enabled)) { return(isTRUE(enabled)) }

  ## forced by environment variable
  enabled <- Sys.getenv("R_CLI_HYPERLINKS", "")
  if (isTRUE(as.logical(enabled))){ return(TRUE) }

  ## If ANSI support is off, then this is off as well
  if (num_ansi_colors() == 1) return(FALSE)

  ## Are we in RStudio?
  rstudio <- rstudio_detect()
  if (rstudio$type != "not_rstudio") { return(rstudio$hyperlink) }

  ## Are we in a terminal? No?
  if (!isatty(stdout())) { return(FALSE) }

  ## Are we in a windows terminal?
  if (is_windows() && Sys.getenv("WT_SESSION") != "")  { return(TRUE) }

  ## Better to avoid it in CIs
  if (nzchar(Sys.getenv("CI")) ||
      nzchar(Sys.getenv("TEAMCITY_VERSION"))) { return(FALSE) }

  ## iTerm
  if (nzchar(TERM_PROGRAM <- Sys.getenv("TERM_PROGRAM"))) {
    version <- package_version(
      Sys.getenv("TERM_PROGRAM_VERSION"),
      strict = FALSE)

    if (TERM_PROGRAM == "iTerm.app") {
      if (!is.na(version) && version >= "3.1") return(TRUE)
    }
  }

  if (nzchar(VTE_VERSION <- Sys.getenv("VTE_VERSION"))) {
    # See #441 -- some apparent heterogeneity in how the version gets
    #   encoded to this env variable. Accept either form.
    if (grepl("^\\d{4}$", VTE_VERSION)) {
      VTE_VERSION <- sprintf("%2.02f", as.numeric(VTE_VERSION) / 100)
      VTE_VERSION <- package_version(list(major = "0", minor = VTE_VERSION))
    } else {
      VTE_VERSION <- package_version(VTE_VERSION, strict = FALSE)
      if (is.na(VTE_VERSION)) {
        VTE_VERSION <- package_version("0.1.0")
      }
    }
    if (VTE_VERSION >= "0.50.1") return(TRUE)
  }

  FALSE
}


#' @details
#' `ansi_hyperlink_types()` checks if current `stdout()` supports various
#' types of hyperlinks. It returns a list with entries `href`, `run`,
#' `help` and `vignettes`.
#'
#' @rdname style_hyperlink
#' @export

ansi_hyperlink_types <- function() {

  get_config <- function(x, default = NULL) {
    opt <- getOption(paste0("cli.", tolower(x)))
    if (!is.null(opt)) return(isTRUE(opt))

    env <- Sys.getenv(paste0("R_CLI_", toupper(x)), NA_character_)
    if (!is.na(env)) return(isTRUE(as.logical(env)))

    default
  }

  rs <- rstudio_detect()
  has <- ansi_has_hyperlink_support()

  # they are on by default in RStudio, but not otherwise
  run <- get_config("hyperlink_run", default = rs$hyperlink)
  hlp <- get_config("hyperlink_help", default = rs$hyperlink)
  vgn <- get_config("hyperlink_vignette", default = rs$hyperlink)

  if (!has) {
    list(
      href = FALSE,
      run = FALSE,
      help = FALSE,
      vignette = FALSE
    )

  } else if (isTRUE(rs$hyperlink)) {
    list(
      href = TRUE,
      run = structure(run, type = "rstudio"),
      help = structure(hlp, type = "rstudio"),
      vignette = structure(vgn, type = "rstudio")
    )

  } else {
    list(
      href = TRUE,
      run = structure(run, type = "standard"),
      help = structure(hlp, type = "standard"),
      vignette = structure(vgn, type = "standard")
    )
  }
}

get_hyperlink_format <- function(type = c("run", "help", "vignette")) {
  type <- match.arg(type)

  key <- glue("hyperlink_{type}_url_format")
  sprt <- ansi_hyperlink_types()[[type]]

  custom_fmt <- get_config_chr(key)
  if (is.null(custom_fmt)) {
    if (identical(attr(sprt, "type"), "rstudio")) {
      fmt_type <- "rstudio"
    } else {
      fmt_type <- "standard"
    }
  } else {
    fmt_type <- "custom"
  }

  variable <- c(run = "code", help = "topic", vignette = "vignette")
  fmt <- switch(
    fmt_type,
    custom = custom_fmt,
    rstudio = glue("ide:{type}:{{{variable[type]}}}"),
    standard = glue("x-r-{type}:{{{variable[type]}}}")
  )
  fmt
}

get_config_chr <- function(x, default = NULL) {
  opt <- getOption(paste0("cli.", tolower(x)))
  if (!is.null(opt)) {
    stopifnot(is_string(opt))
    return(opt)
  }

  env <- Sys.getenv(paste0("R_CLI_", toupper(x)), NA_character_)
  if (!is.na(env)) return(env)

  default
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/ansi-palette.R"

get_palette_color <- function(style, colors = num_ansi_colors()) {
  opt <- getOption("cli.palette")
  if (is.null(opt) || colors < 256) return(style)
  cache_palette_color(opt, style$palette, colors)
}

palette_cache <- new.env(parent = emptyenv())

cache_palette_color <- function(pal, idx, colors = num_ansi_colors()) {
  if (is_string(pal)) {
    if (! pal %in% rownames(ansi_palettes)) {
      opt <- options(cli.palette = NULL)
      defer(options(opt))
      throw(cli_error(
        "Cannot find cli ANSI palette {.val {pal}}",
        "i" = "Know palettes are {.val {rownames(cli::ansi_palettes)}}.",
        "i" = "Maybe the {.code cli.palette} option is incorrect?"
      ))
    }
    pal <- ansi_palettes[pal, ]
  }

  bg <- idx < 0
  idx <- abs(idx)
  col <- pal[[idx]]

  colkey <- as.character(colors)
  key <- paste0(col, bg)
  if (key %in% names(palette_cache[[colkey]])) {
    return(palette_cache[[colkey]][[key]])
  }

  val <- ansi_style_from_r_color(
    col,
    bg = bg,
    colors,
    grey = FALSE
  )

  if (is.null(palette_cache[[colkey]])) {
    palette_cache[[colkey]] <- new.env(parent = emptyenv())
  }
  palette_cache[[colkey]][[key]] <- val

  return(val)
}

#' @details
#' `truecolor` is an integer constant for the number of 24 bit ANSI colors.
#'
#' @format `truecolor` is an integer scalar.
#'
#' @export
#' @rdname ansi_palettes

truecolor <- as.integer(256 ^ 3)

#' ANSI colors palettes
#'
#' If your platform supports at least 256 colors, then you can configure
#' the colors that cli uses for the eight base and the eight bright colors.
#' (I.e. the colors of [col_black()], [col_red()], and [col_br_black()],
#' [col_br_red()], etc.
#'
#' To customize the default palette, set the `cli.palette` option to the
#' name of a built-in palette (see `ansi_palettes()`), or the list of
#' 16 colors. Colors can be specified with RGB colors strings:
#' `#rrggbb` or R color names (see the output of [grDevices::colors()]).
#'
#' For example, you can put this in your R profile:
#' ```r
#' options(cli.palette = "vscode")
#' ```
#'
#' It is currently not possible to configure the background colors
#' separately, these will be always the same as the foreground colors.
#'
#' If your platform only has 256 colors, then the colors specified in the
#' palette have to be interpolated. On true color platforms they RGB
#' values are used as-is.
#'
#' `ansi_palettes` is a data frame of the built-in palettes, each row
#' is one palette.
#'
#' `ansi_palette_show()` shows the colors of an ANSI palette on the screen.
#'
#' @format `ansi_palettes` is a data frame with one row for each palette,
#'   and one column for each base ANSI color. `attr(ansi_palettes, "info")`
#'   contains a list with information about each palette.
#'
#' @export
#' @examples
#' ansi_palettes
#' ansi_palette_show("dichro", colors = truecolor)

ansi_palettes <- rbind(
  utils::read.table(
    "tools/ansi-palettes.txt",
    comment.char = ";",
    stringsAsFactors = FALSE
  ),
  utils::read.table(
    "tools/ansi-iterm-palettes.txt",
    comment.char = ";",
    stringsAsFactors = FALSE
  )
)

attr(ansi_palettes, "info") <-
  list(
    dichro = paste(
      "Colorblind friendly palette, from",
      "https://github.com/romainl/vim-dichromatic#dichromatic."
    ),
    vga = paste(
      "Typical colors that are used when booting PCs and leaving them in",
      "text mode, which used a 16-entry color table. The colors are",
      "different in the EGA/VGA graphic modes.",
      "From https://en.wikipedia.org/wiki/ANSI_escape_code#SGR."
    ),
    winxp = paste(
      "Windows XP Console. Seen in Windows XP through Windows 8.1.",
      "From https://en.wikipedia.org/wiki/ANSI_escape_code#SGR."
    ),
    vscode = paste(
      "Visual Studio Debug console, 'Dark+' theme.",
      "From https://en.wikipedia.org/wiki/ANSI_escape_code#SGR."
    ),
    win10 = paste0(
      "Campbell theme, used as of Windows 10 version 1709. Also used",
      "by PowerShell 6.",
      "From https://en.wikipedia.org/wiki/ANSI_escape_code#SGR."
    ),
    macos = paste0(
      "Terminal.app in macOS",
      "From https://en.wikipedia.org/wiki/ANSI_escape_code#SGR."
    ),
    putty = paste0(
      "From https://en.wikipedia.org/wiki/ANSI_escape_code#SGR."
    ),
    mirc = paste0(
      "From https://en.wikipedia.org/wiki/ANSI_escape_code#SGR."
    ),
    xterm = paste0(
      "From https://en.wikipedia.org/wiki/ANSI_escape_code#SGR."
    ),
    ubuntu = paste0(
      "For virtual terminals, from /etc/vtrgb.",
      "From https://en.wikipedia.org/wiki/ANSI_escape_code#SGR."
    ),
    eclipse = paste0(
      "From https://en.wikipedia.org/wiki/ANSI_escape_code#SGR."
    ),
    iterm = "Built-in iTerm2 theme.",
    "iterm-pastel" = "Built-In iTerm2 theme.",
    "iterm-smoooooth" = "Built-In iTerm2 theme.",
    "iterm-snazzy" = "From https://github.com/sindresorhus/iterm2-snazzy.",
    "iterm-solarized" = "Built-In iTerm2 theme.",
    "iterm-tango" = "Built-In iTerm2 theme."
  )

#' @param palette The palette to show, in the same format as for the
#'   `cli.palette` option, so it can be the name of a built-in palette,
#'   of a list of 16 colors.
#' @param colors Number of ANSI colors to use the show the palette. If the
#'   platform does not have sufficient support, the output might have
#'   a lower color resolution. Without color support it will have no color
#'   at all.
#' @param rows The number of colored rows to print.
#' @return `ansi_palette_show` returns a character vector, the rows that
#'   are printed to the screen, invisibly.
#'
#' @export
#' @rdname ansi_palettes

ansi_palette_show <- function(palette = NULL, colors = num_ansi_colors(),
                              rows = 4) {
  opts <- options(
    cli.palette = palette %||% getOption("cli.palette"),
    cli.num_colors = colors
  )
  on.exit(options(opts), add = TRUE)

  blk <- strrep(symbol$lower_block_8, 4)
  blks <- c(
    "blck" = col_black(blk),
    "red " = col_red(blk),
    "grn " = col_green(blk),
    "yllw" = col_yellow(blk),
    "blue" = col_blue(blk),
    "mgnt" = col_magenta(blk),
    "cyan" = col_cyan(blk),
    "whte" = col_white(blk),
    "blck" = col_br_black(blk),
    "red " = col_br_red(blk),
    "grn " = col_br_green(blk),
    "yllw" = col_br_yellow(blk),
    "blue" = col_br_blue(blk),
    "mgnt" = col_br_magenta(blk),
    "cyan" = col_br_cyan(blk),
    "whte" = col_br_white(blk)
  )

  join <- function(x) {
    paste0(
      paste(x[1:8], collapse = " "),
      "  ",
      paste(x[9:16], collapse = " ")
    )
  }

  nms <- join(names(blks))
  str <- join(blks)

  out <- c(
    paste(strrep(" ", 52), "bright variants"),
    nms,
    "",
    rep(str, rows)
  )

  cat_line(out)
  invisible(out)
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/ansi-utils.R"

re_table <- function(...) {
  lapply(gregexpr(...), function(x) {
    res <- cbind(
      start = x,
      end = x + attr(x, "match.length") - 1,
      length = attr(x, "match.length")
    )
    res <- res[res[, "start"] != -1, , drop=FALSE]
  })
}

## Create the non-matching table from the matching table

non_matching <- function(table, str, empty = FALSE) {
  mapply(table, str, SIMPLIFY = FALSE, FUN = function(t, s) {
    if (! nrow(t)) {
      cbind(start = 1, end = base::nchar(s), length = base::nchar(s))
    } else {
      start <- c(1, t[, "end"] + 1)
      end <- c(t[, "start"] - 1, base::nchar(s))
      res <- cbind(start = start, end = end, length = end - start + 1)
      if (!empty) res[ res[, "length"] != 0, , drop = FALSE ] else res
    }
  })
}

myseq <- function(from, to, by = 1) {
  stopifnot(by != 0)
  if (by > 0) {
    if (to < from) {
      integer()
    } else {
      seq(from, to, by = by)
    }
  } else {
    if (to > from) {
      integer()
    } else {
      seq(from, to, by = by)
    }
  }
}

`%:%` <- myseq
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/ansi.R"

# this is install time
# nocov start

palette_idx <- function(id) {
  ifelse(
    id < 38,
    id - (30 - 1),
  ifelse(
    id < 48,
    -(id - (40 - 1)),
  ifelse(
    id < 98,
    id - (90 - 9),
    -(id - (100 - 9))
  )))
}

palette_color <- function(x) {
  c(x, palette = palette_idx(x[[1]]))
}

ansi_builtin_styles <- list(
  reset = list(0, c(0, 22, 23, 24, 27, 28, 29, 39, 49)),
  bold = list(1, 22), # 21 isn't widely supported and 22 does the same thing
  blurred = list(2, 22),
  italic = list(3, 23),
  underline = list(4, 24),
  inverse = list(7, 27),
  hidden = list(8, 28),
  strikethrough = list(9, 29),

  black = palette_color(list(30, 39)),
  red = palette_color(list(31, 39)),
  green = palette_color(list(32, 39)),
  yellow = palette_color(list(33, 39)),
  blue = palette_color(list(34, 39)),
  magenta = palette_color(list(35, 39)),
  cyan = palette_color(list(36, 39)),
  white = palette_color(list(37, 39)),
  silver = list(90, 39),

  br_black = palette_color(list(90, 39)),
  br_red = palette_color(list(91, 39)),
  br_green = palette_color(list(92, 39)),
  br_yellow = palette_color(list(93, 39)),
  br_blue = palette_color(list(94, 39)),
  br_magenta = palette_color(list(95, 39)),
  br_cyan = palette_color(list(96, 39)),
  br_white = palette_color(list(97, 39)),

  bg_black = palette_color(list(40, 49)),
  bg_red = palette_color(list(41, 49)),
  bg_green = palette_color(list(42, 49)),
  bg_yellow = palette_color(list(43, 49)),
  bg_blue = palette_color(list(44, 49)),
  bg_magenta = palette_color(list(45, 49)),
  bg_cyan = palette_color(list(46, 49)),
  bg_white = palette_color(list(47, 49)),

  bg_br_black = palette_color(list(100, 49)),
  bg_br_red = palette_color(list(101, 49)),
  bg_br_green = palette_color(list(102, 49)),
  bg_br_yellow = palette_color(list(103, 49)),
  bg_br_blue = palette_color(list(104, 49)),
  bg_br_magenta = palette_color(list(105, 49)),
  bg_br_cyan = palette_color(list(106, 49)),
  bg_br_white = palette_color(list(107, 49)),

  # similar to reset, but only for a single property
  no_bold          = list(c(0,     23, 24, 27, 28, 29, 39, 49), 22),
  no_blurred       = list(c(0,     23, 24, 27, 28, 29, 39, 49), 22),
  no_italic        = list(c(0, 22,     24, 27, 28, 29, 39, 49), 23),
  no_underline     = list(c(0, 22, 23,     27, 28, 29, 39, 49), 24),
  no_inverse       = list(c(0, 22, 23, 24,     28, 29, 39, 49), 27),
  no_hidden        = list(c(0, 22, 23, 24, 27,     29, 39, 49), 28),
  no_strikethrough = list(c(0, 22, 23, 24, 27, 28,     39, 49), 29),
  none             = list(c(0, 22, 23, 24, 27, 28, 29,     49), 39),
  no_color         = list(c(0, 22, 23, 24, 27, 28, 29,     49), 39),
  bg_none          = list(c(0, 22, 23, 24, 27, 28, 29, 39    ), 49),
  no_bg_color      = list(c(0, 22, 23, 24, 27, 28, 29, 39    ), 49)
)

# nocov end

is_builtin_style <- function(x) {
  is_string(x) && x %in% names(ansi_builtin_styles)
}

ansi_fg_r <- c(
  "black" = "black",
  "red" = "red",
  "green" = "green",
  "yellow" = "yellow",
  "blue" = "blue",
  "magenta" = "magenta",
  "cyan" = "cyan",
  "white" = "white",
  "silver" = "grey"
)

ansi_fg_rgb <- grDevices::col2rgb(ansi_fg_r)

ansi_bg_r <- c(
  "bg_black" = "black",
  "bg_red" = "red",
  "bg_green" = "green",
  "bg_yellow" = "yellow",
  "bg_blue" = "blue",
  "bg_magenta" = "magenta",
  "bg_cyan" = "cyan",
  "bg_white" = "white"
)

ansi_bg_rgb <- grDevices::col2rgb(ansi_bg_r)

ansi_style_str <- function(x) {
  paste0("\u001b[", x, "m", collapse = "")
}

create_ansi_style_tag <- function(name, open, close, palette = NULL) {
  structure(
    list(list(open = open, close = close, palette = palette)),
    names = name
  )
}

create_ansi_style_fun <- function(styles) {
  fun <- eval(substitute(function(...) {
    txt <- paste0(...)
    nc <- num_ansi_colors()
    if (nc > 1 && length(txt) > 0) {
      mystyles <- .styles
      for (st in rev(mystyles)) {
        if (!is.null(st$palette)) st <- get_palette_color(st, nc)
        txt <- paste0(
          st$open,
          gsub(st$close, st$open, txt, fixed = TRUE),
          st$close
        )
      }
    }
    class(txt) <- c("cli_ansi_string", "ansi_string", "character")
    txt
  }, list(.styles = styles)))

  class(fun) <- c("cli_ansi_style", "ansi_style")
  attr(fun, "_styles") <- styles
  fun
}

create_ansi_style <- function(name, open = NULL, close = NULL) {
  open <- open %||% ansi_style_str(ansi_builtin_styles[[name]][[1]])
  close <- close %||% ansi_style_str(ansi_builtin_styles[[name]][[2]])
  palette <- ansi_builtin_styles[[name]]$palette
  style <- create_ansi_style_tag(name, open, close, palette)
  create_ansi_style_fun(style)
}

#' @export

print.cli_ansi_string <- function(x, ...) {
  cat("<cli_ansi_string>\n")
  if (length(x)) {
    cat(format(paste0("[", seq_along(x), "] ", format(x))), sep = "\n")
  }
  invisible(x)
}

#' @export

print.cli_ansi_style <- function(x, ...) {
  cat("<cli_ansi_style>\n")
  cat(x("Example output"))
  cat("\n")
  invisible(x)
}

#' Create a new ANSI style
#'
#' Create a function that can be used to add ANSI styles to text.
#'
#' @param ... The style to create. See details and examples below.
#' @param bg Whether the color applies to the background.
#' @param grey Whether to specifically create a grey color.
#'   This flag is included, because ANSI 256 has a finer color scale
#'   for greys, then the usual 0:5 scale for red, green and blue components.
#'   It is only used for RGB color specifications (either numerically
#'   or via a hexadecimal string), and it is ignored on eight color ANSI
#'   terminals.
#' @param colors Number of colors, detected automatically
#'   by default.
#' @return A function that can be used to color (style) strings.
#'
#' @details
#' The `...` style argument can be any of the following:
#' * A cli ANSI style function of class `cli_ansi_style`. This is returned
#'   as is, without looking at the other arguments.
#' * An R color name, see [grDevices::colors()].
#' * A 6- or 8-digit hexadecimal color string, e.g. `#ff0000` means
#'   red. Transparency (alpha channel) values are ignored.
#' * A one-column matrix with three rows for the red, green
#'   and blue channels, as returned by [grDevices::col2rgb()].
#'
#' `make_ansi_style()` detects the number of colors to use
#' automatically (this can be overridden using the `colors`
#' argument). If the number of colors is less than 256 (detected or given),
#' then it falls back to the color in the ANSI eight color mode that
#' is closest to the specified (RGB or R) color.
#'
#'
#' @family ANSI styling
#' @export
#' @examples
#' make_ansi_style("orange")
#' make_ansi_style("#123456")
#' make_ansi_style("orange", bg = TRUE)
#'
#' orange <- make_ansi_style("orange")
#' orange("foobar")
#' cat(orange("foobar"))

make_ansi_style <- function(..., bg = FALSE, grey = FALSE,
                            colors = num_ansi_colors()) {

  style <- list(...)[[1]]
  if (inherits(style, "cli_ansi_style")) return(style)
  if (inherits(style, "crayon")) {
    return(create_ansi_style_fun(attr(style, "_styles")))
  }

  if (identical(style, "dim")) style <- "blurred"

  orig_style_name <- style_name <- names(args)[1]

  stop_if_not(
    is.character(style) && length(style) == 1 ||
    is_rgb_matrix(style) && ncol(style) == 1,
    message = c(
      "{.arg style} must be an ANSI style",
      "i" = paste(
        "an ANSI style is a character scalar (cli style name, RGB or R color",
        "name), or a [3x1] or [4x1] numeric RGB matrix"),
      "i" = "{.arg style} is {.type {style}}"
    )
  )
  stopifnot(
    is.logical(bg) && length(bg) == 1,
    is.numeric(colors) && length(colors) == 1
  )

  ansi_seqs <- if (is_builtin_style(style)) {
    if (bg && substr(style, 1, 3) != "bg_") {
      style <- paste0("bg_", style)
    }
    if (is.null(style_name)) style_name <- style
    ansi_builtin_styles[[style]]

  } else if (is_r_color(style)) {
    if (is.null(style_name)) style_name <- style
    ansi_style_from_r_color(style, bg, colors, grey)

  } else if (is_rgb_matrix(style)) {
    if (is.null(style_name)) {
      style_name <- paste0(
        c("rgb", style, if (bg) "-bg", if (grey) "-grey"),
        collapse = "-"
      )
    }
    ansi_style_from_rgb(style, bg, colors, grey)

  } else {
    throw(cli_error(
      "Unknown style specification: {.val style}, it must be one of",
      "*" = "a builtin cli style, e.g. {.val bold} or {.val red},",
      "*" = "an R color name, see {.help grDevices::colors}.",
      "*" = "a [3x1] or [4x1] numeric RGB matrix with, range 0-255."
    ))
  }

  create_ansi_style(style_name, ansi_seqs$open, ansi_seqs$close)
}

hash_color_regex <- "^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{8})$"

is_r_color <- function(x) {
  if (!is.character(x) || length(x) != 1 || is.na(x)) {
    FALSE
  } else {
    x %in% grDevices::colors() || grepl(hash_color_regex, x)
  }
}

is_rgb_matrix <- function(x) {
  is.matrix(x) && is.numeric(x) && (nrow(x) == 3 || nrow(x) == 4)
}

ansi_style_from_r_color <- function(color, bg, num_colors, grey) {
  ansi_style_from_rgb(grDevices::col2rgb(color), bg, num_colors, grey)
}

ansi_style_8_from_rgb <- function(rgb, bg) {
  ansi_cols <- if (bg) ansi_bg_rgb else ansi_fg_rgb
  dist <- colSums((ansi_cols - as.vector(rgb)) ^ 2 )
  builtin_name <- names(which.min(dist))[1]
  btn <- ansi_builtin_styles[[builtin_name]]
  list(open = ansi_style_str(btn[[1]]), close = ansi_style_str(btn[[2]]))
}

ansi_style_from_rgb <- function(rgb, bg, num_colors, grey) {
  if (num_colors < 256) { return(ansi_style_8_from_rgb(rgb, bg)) }
  if (num_colors < truecolor || grey) return(ansi256(rgb, bg, grey))
  return(ansitrue(rgb, bg))
}

# nocov start
fgcodes <- c(paste0('\x1b[38;5;', 0:255, 'm'), '\x1b[39m')
bgcodes <- c(paste0('\x1b[48;5;', 0:255, 'm'), '\x1b[49m')

rgb_index <- 17:232
gray_index <- 233:256
reset_index <- 257
# nocov end

ansi_scale <- function(x, from = c(0, 255), to = c(0, 5), round = TRUE) {
  y <- (x - from[1]) /
    (from[2] - from[1]) *
    (to[2] - to[1]) +
    to[1]

  if (round) {
    round(y)
  } else {
    y
  }
}

ansi256 <- function(rgb, bg = FALSE, grey = FALSE) {
  codes <- if (bg) bgcodes else fgcodes
  if (grey) {
    ## Gray
    list(
      open = codes[gray_index][ansi_scale(rgb[1], to = c(0, 23)) + 1],
      close = codes[reset_index]
    )

  } else {
    ## Not gray
    list(
      open = codes[ansi256_rgb_index(rgb[1L], rgb[2L], rgb[3L])],
      close = codes[reset_index]
    )
  }
}

## This is based off the algorithm in the ruby "paint" gem, as
## implemented in rainbowrite.
ansi256_rgb_index <- function(red, green, blue) {
  gray_possible <- TRUE
  sep <- 42.5
  while (gray_possible) {
    if (red < sep || green < sep || blue < sep) {
      gray <- red < sep && green < sep && blue < sep
      gray_possible <- FALSE
    }
    sep <- sep + 42.5
  }

  ## NOTE: The +1 here translates from base0 to base1 for the index
  ## that does the same.  Not ideal, but that does get the escape
  ## characters in nicely.
  if (gray) {
    232 + round((red + green + blue) / 33) + 1
  } else {
    16 + sum(floor(6 * c(red, green, blue) / 256) * c(36, 6, 1)) + 1
  }
}

ansitrue <- function(rgb, bg = FALSE) {
  if (bg) {
    list(
      open = paste0("\x1b[48;2;", rgb[1], ";", rgb[2], ";", rgb[3], "m"),
      close = "\x1b[49m"
    )
  } else {
    list(
      open = paste0("\x1b[38;2;", rgb[1], ";", rgb[2], ";", rgb[3], "m"),
      close = "\x1b[39m"
    )
  }
}

#' Combine two or more ANSI styles
#'
#' Combine two or more styles or style functions into a new style function
#' that can be called on strings to style them.
#'
#' It does not usually make sense to combine two foreground
#' colors (or two background colors), because only the first one
#' applied will be used.
#'
#' It does make sense to combine different kind of styles,
#' e.g. background color, foreground color, bold font.
#'
#' @param ... The styles to combine. For character strings, the
#'   [make_ansi_style()] function is used to create a style first.
#'   They will be applied from right to left.
#' @return The combined style function.
#'
#' @family ANSI styling
#' @export
#' @examples
#' ## Use style names
#' alert <- combine_ansi_styles("bold", "red4")
#' cat(alert("Warning!"), "\n")
#'
#' ## Or style functions
#' alert <- combine_ansi_styles(style_bold, col_red, bg_cyan)
#' cat(alert("Warning!"), "\n")
#'
#' ## Combine a composite style
#' alert <- combine_ansi_styles(
#'   "bold",
#'   combine_ansi_styles("red", bg_cyan))
#' cat(alert("Warning!"), "\n")

combine_ansi_styles <- function(...) {
  styles <- lapply(
    list(...),
    function(x) attr(make_ansi_style(x), "_styles")
  )
  styles <- unlist(styles, recursive = FALSE)
  create_ansi_style_fun(styles)
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/ansiex.R"
#' Labels a character vector as containing ANSI control codes.
#'
#' This function sets the class of its argument, activating
#' ANSI-string-specific methods such as for printing.
#'
#' @param x A character vector or something that can be
#'   coerced into one.
#' @return A `cli_ansi_string` object, a subclass of
#'   `character`, with the same length and contents
#'   as `x`.
#' @family low level ANSI functions
#' @export
ansi_string <- function(x) {
  if (!is.character(x)) x <- as.character(x)
  x <- enc2utf8(x)
  class(x) <- unique(c("cli_ansi_string", "ansi_string", class(x), "character"))
  x
}

#' Perl compatible regular expression that matches ANSI escape
#' sequences
#'
#' Don't forget to use `perl = TRUE` when using this with [grepl()] and
#' friends.
#'
#' @return String scalar, the regular expression.
#'
#' @family low level ANSI functions
#' @export

ansi_regex <- function() {
  paste0(
    "(?:(?:\\x{001b}\\[)|\\x{009b})",
    "(?:(?:[0-9]{1,3})?(?:(?:;[0-9]{0,3})*)?[A-M|f-m])",
    "|\\x{001b}[A-M]",
    # this is for hyperlinks, we must be non-greedy
    "|\\x{001b}\\]8;.*?;.*?\\x{001b}\\\\",
    "|\\x{001b}\\]8;.*?;.*?\\x{0007}"
  )
}

#' Check if a string has some ANSI styling
#'
#' @param string The string to check. It can also be a character
#'   vector.
#' @param sgr Whether to look for SGR (styling) control sequences.
#' @param csi Whether to look for non-SGR control sequences.
#' @param link Whether to look for ANSI hyperlinks.
#' @return Logical vector, `TRUE` for the strings that have some
#'   ANSI styling.
#'
#' @family low level ANSI functions
#' @export
#' @examples
#' ## The second one has style if ANSI colors are supported
#' ansi_has_any("foobar")
#' ansi_has_any(col_red("foobar"))

ansi_has_any <- function(string, sgr = TRUE, csi = TRUE, link = TRUE) {
  if (!is.character(string)) string <- as.character(string)
  string <- enc2utf8(string)
  stopifnot(
    is_flag(sgr),
    is_flag(csi),
    is_flag(link)
  )
  .Call(clic_ansi_has_any, string, sgr, csi, link)
}

#' Remove ANSI escape sequences from a string
#'
#' The input may be of class `cli_ansi_string` class, this is also dropped
#' from the result.
#'
#' @param string The input string.
#' @param sgr Whether to remove for SGR (styling) control sequences.
#' @param csi Whether to remove for non-SGR control sequences.
#' @param link Whether to remove ANSI hyperlinks.
#' @return The cleaned up string. Note that `ansi_strip()` always drops
#' the `cli_ansi_string` class, even if `sgr` and sci` are `FALSE`.
#'
#' @family low level ANSI functions
#' @export
#' @examples
#' ansi_strip(col_red("foobar")) == "foobar"

ansi_strip <- function(string, sgr = TRUE, csi = TRUE, link = TRUE) {
  if (!is.character(string)) string <- as.character(string)
  string <- enc2utf8(string)
  stopifnot(
    is_flag(sgr),
    is_flag(csi),
    is_flag(link)
  )
  clean <- .Call(clic_ansi_strip, string, sgr, csi, link)
  class(clean) <- setdiff(class(clean), c("cli_ansi_string", "ansi_string"))
  clean
}

#' Count number of characters in an ANSI colored string
#'
#' This is a color-aware counterpart of [utf8_nchar()]. By default it
#' counts Unicode grapheme clusters, instead of code points.
#'
#' @param x Character vector, potentially ANSI styled, or a vector to be
#'   coerced to character. If it converted to UTF-8.
#' @param type Whether to count graphemes (characters), code points,
#'   bytes, or calculate the display width of the string.
#' @return Numeric vector, the length of the strings in the character
#'   vector.
#'
#' @family ANSI string operations
#' @export
#' @examples
#' str <- paste(
#'   col_red("red"),
#'   "default",
#'   col_green("green")
#' )
#'
#' cat(str, "\n")
#' nchar(str)
#' ansi_nchar(str)
#' nchar(ansi_strip(str))

ansi_nchar <- function(x,
                       type = c("chars", "bytes", "width", "graphemes",
                                "codepoints")) {
  type <- match.arg(type)
  if (type == "chars") type <- "graphemes"
  type <- match(type, c("graphemes", "bytes", "width", "codepoints"))
  if (!is.character(x)) x <- as.character(x)
  x <- enc2utf8(x)
  .Call(clic_ansi_nchar, x, type)
}

#' Substring(s) of an ANSI colored string
#'
#' This is a color-aware counterpart of [base::substr()].
#' It works exactly like the original, but keeps the colors
#' in the substrings. The ANSI escape sequences are ignored when
#' calculating the positions within the string.
#'
#' @param x Character vector, potentially ANSI styled, or a vector to
#'   coerced to character.
#' @param start Starting index or indices, recycled to match the length
#'   of `x`.
#' @param stop Ending index or indices, recycled to match the length
#'   of `x`.
#' @return Character vector of the same length as `x`, containing
#'   the requested substrings. ANSI styles are retained.
#'
#' @family ANSI string operations
#' @export
#' @examples
#' str <- paste(
#'   col_red("red"),
#'   "default",
#'   col_green("green")
#' )
#'
#' cat(str, "\n")
#' cat(ansi_substr(str, 1, 5), "\n")
#' cat(ansi_substr(str, 1, 15), "\n")
#' cat(ansi_substr(str, 3, 7), "\n")
#'
#' substr(ansi_strip(str), 1, 5)
#' substr(ansi_strip(str), 1, 15)
#' substr(ansi_strip(str), 3, 7)
#'
#' str2 <- paste(
#'   "another",
#'   col_red("multi-", style_underline("style")),
#'   "text"
#' )
#'
#' cat(str2, "\n")
#' cat(ansi_substr(c(str, str2), c(3,5), c(7, 18)), sep = "\n")
#' substr(ansi_strip(c(str, str2)), c(3,5), c(7, 18))

ansi_substr <- function(x, start, stop) {
  if (!is.character(x)) x <- as.character(x)
  if (!length(x)) return(ansi_string(x))
  start <- suppressWarnings(as.integer(start))
  stop <- suppressWarnings(as.integer(stop))
  if (!length(start) || !length(stop)) {
    throw(cli_error(
      "{.code ansi_substr()} must have non-empty {.arg start} and {.arg stop} arguments",
      "i" = if (!length(start)) "{.arg start} has length {length(start)}",
      "i" = if (!length(stop)) "{.arg stop} has length {length(stop)}"
    ))
  }
  nastart <- anyNA(start)
  nastop <- anyNA(stop)
  if (nastart || nastop) {
    throw(cli_error(
      "{.arg start} and {.arg stop} must not have {.code NA} values",
      "i" = if (nastart) paste(
              "{.arg start} has {sum(is.na(start))}",
              "{.code NA} value{?s}, after coercion to integer"),
      "i" = if (nastop) paste(
              "{.arg stop} has {sum(is.na(stop))} {.code NA} value{?s},",
              "after coercion to integer")
    ))
  }
  x <- enc2utf8(x)
  start <- rep_len(start, length(x))
  stop <- rep_len(stop, length(x))
  .Call(clic_ansi_substr, x, start, stop)
}

#' Substring(s) of an ANSI colored string
#'
#' This is the color-aware counterpart of [base::substring()].
#' It works exactly like the original, but keeps the colors in the
#' substrings. The ANSI escape sequences are ignored when
#' calculating the positions within the string.
#'
#' @param text Character vector, potentially ANSI styled, or a vector to
#'   coerced to character. It is recycled to the longest of `first`
#'   and `last`.
#' @param first Starting index or indices, recycled to match the length
#'   of `x`.
#' @param last Ending index or indices, recycled to match the length
#'   of `x`.
#' @return Character vector of the same length as `x`, containing
#'   the requested substrings. ANSI styles are retained.
#'
#' @family ANSI string operations
#' @export
#' @examples
#' str <- paste(
#'   col_red("red"),
#'   "default",
#'   col_green("green")
#' )
#'
#' cat(str, "\n")
#' cat(ansi_substring(str, 1, 5), "\n")
#' cat(ansi_substring(str, 1, 15), "\n")
#' cat(ansi_substring(str, 3, 7), "\n")
#'
#' substring(ansi_strip(str), 1, 5)
#' substring(ansi_strip(str), 1, 15)
#' substring(ansi_strip(str), 3, 7)
#'
#' str2 <- paste(
#'   "another",
#'   col_red("multi-", style_underline("style")),
#'   "text"
#' )
#'
#' cat(str2, "\n")
#' cat(ansi_substring(str2, c(3,5), c(7, 18)), sep = "\n")
#' substring(ansi_strip(str2), c(3,5), c(7, 18))

ansi_substring <- function(text, first, last = 1000000L) {
  if (!is.character(text)) text <- as.character(text)
  n <- max(lt <- length(text), length(first), length(last))
  if (lt && lt < n) text <- rep_len(text, length.out = n)
  text <- enc2utf8(text)
  first <- rep_len(as.integer(first), n)
  last <- rep_len(as.integer(last), n)
  .Call(clic_ansi_substr, text, first, last)
}


#' Split an ANSI colored string
#'
#' This is the color-aware counterpart of [base::strsplit()].
#' It works almost exactly like the original, but keeps the colors in the
#' substrings.
#'
#' @param x Character vector, potentially ANSI styled, or a vector to
#'   coerced to character.
#' @param split Character vector of length 1 (or object which can be coerced to
#'   such) containing regular expression(s) (unless `fixed = TRUE`) to use
#'   for splitting.  If empty matches occur, in particular if `split` has
#'   zero characters, `x` is split into single characters.
#' @param ... Extra arguments are passed to `base::strsplit()`.
#' @return A list of the same length as `x`, the `i`-th element of
#'   which contains the vector of splits of `x[i]`. ANSI styles are
#'   retained.
#'
#' @family ANSI string operations
#' @export
#' @examples
#' str <- paste0(
#'   col_red("I am red---"),
#'   col_green("and I am green-"),
#'   style_underline("I underlined")
#' )
#'
#' cat(str, "\n")
#'
#' # split at dashes, keep color
#' cat(ansi_strsplit(str, "[-]+")[[1]], sep = "\n")
#' strsplit(ansi_strip(str), "[-]+")
#'
#' # split to characters, keep color
#' cat(ansi_strsplit(str, "")[[1]], "\n", sep = " ")
#' strsplit(ansi_strip(str), "")

ansi_strsplit <- function(x, split, ...) {
  split <- try(as.character(split), silent = TRUE)
  if (inherits(split, "try-error") || !is.character(split) || length(split) > 1L) {
    throw(cli_error(
      "{.arg split} must be character of length <= 1, or must coerce to that",
      i = "{.arg split} is (or was coerced to) {.type {split}}"
    ))
  }
  if (!is.character(x)) x <- as.character(x)
  x <- enc2utf8(x)
  if(!length(split)) split <- ""
  plain <- ansi_strip(x)
  splits <- re_table(split, plain, ...)
  chunks <- non_matching(splits, plain, empty = TRUE)
  # silently recycle `split`; doesn't matter currently since we don't support
  # split longer than 1, but might in future
  split.r <- rep(split, length.out=length(x))
  # Drop empty chunks to align with `substr` behavior
  chunks <- lapply(
    seq_along(chunks),
    function(i) {
      y <- chunks[[i]]
      # empty split means drop empty first match
      if(nrow(y) && !nzchar(split.r[[i]]) && !utils::head(y, 1L)[, "length"]) {
        y <- y[-1L, , drop=FALSE]
      }
      # drop empty last matches
      if(nrow(y) && !utils::tail(y, 1L)[, "length"]) y[-nrow(y), , drop=FALSE] else y
    }
  )
  zero.chunks <- !vapply(chunks, nrow, integer(1L))
  # Pull out zero chunks from colored string b/c ansi_substring won't work
  # with them
  res <- vector("list", length(chunks))
  res[zero.chunks] <- list(character(0L))
  res[!zero.chunks] <- mapply(
    chunks[!zero.chunks], x[!zero.chunks], SIMPLIFY = FALSE,
    FUN = function(tab, xx) ansi_substring(xx, tab[, "start"], tab[, "end"])
  )
  lapply(res, ansi_string)
}

#' Align an ANSI colored string
#'
#' @details
#'
#' ```{asciicast ansi-align}
#' str <- c(
#'   col_red("This is red"),
#'   style_bold("This is bold")
#' )
#' astr <- ansi_align(str, width = 30)
#' boxx(astr)
#' ```
#'
#' ```{asciicast ansi-align-center}
#' str <- c(
#'   col_red("This is red"),
#'   style_bold("This is bold")
#' )
#' astr <- ansi_align(str, align = "center", width = 30)
#' boxx(astr)
#' ```
#'
#' ```{asciicast ansi-align-right}
#' str <- c(
#'   col_red("This is red"),
#'   style_bold("This is bold")
#' )
#' astr <- ansi_align(str, align = "right", width = 30)
#' boxx(astr)
#' ```
#'
#' @param text The character vector to align.
#' @param width Width of the field to align in.
#' @param align Whether to align `"left"`, `"center"` or `"right"`.
#' @param type Passed on to [ansi_nchar()] and there to [nchar()]
#' @return The aligned character vector.
#'
#' @family ANSI string operations
#' @export

# TODO: show wide Unicode charadcters, once they work in asciicast

ansi_align <- function(text, width = console_width(),
                      align = c("left", "center", "right"),
                      type = "width") {

  align <- match.arg(align)
  text <- enc2utf8(text)
  nc <- ansi_nchar(text, type = type)

  if (!length(text)) return(ansi_string(text))

  res <- if (align == "left") {
    paste0(text, make_space(width - nc))

  } else if (align == "center") {
    paste0(make_space(ceiling((width - nc) / 2)),
           text,
           make_space(floor((width - nc) / 2)))

  } else {
    paste0(make_space(width - nc), text)
  }

  ansi_string(res)
}

make_space <- function(num, filling = " ") {
  num <- pmax(0, num)
  res <- strrep(filling, num)
  Encoding(res) <- Encoding(filling)
  res
}

strrep <- function (x, times) {
  x = as.character(x)
  if (length(x) == 0L) return(x)

  mapply(
    function(x, times) {
      if (is.na(x) || is.na(times)) {
        NA_character_
      } else if (times <= 0L) {
        ""
      } else {
        paste0(rep(x, times), collapse = "")
      }
    },
    x, times,
    USE.NAMES = FALSE
  )
}

#' Remove leading and/or trailing whitespace from an ANSI string
#'
#' This function is similar to [base::trimws()] but works on ANSI strings,
#' and keeps color and other styling.
#'
#' @param x ANSI string vector.
#' @param which Whether to remove leading or trailing whitespace or both.
#' @return ANSI string, with the whitespace removed.
#'
#' @family ANSI string operations
#' @export
#' @examples
#' trimws(paste0("   ", col_red("I am red"), "   "))
#' ansi_trimws(paste0("   ", col_red("I am red"), "   "))
#' trimws(col_red("   I am red   "))
#' ansi_trimws(col_red("   I am red   "))

ansi_trimws <- function(x, which = c("both", "left", "right")) {

  if (!is.character(x)) x <- as.character(x)
  which <- match.arg(which)
  x <- enc2utf8(x)
  if (!length(x)) return(ansi_string(x))

  sl <- 0L
  if (which %in% c("both", "left")) {
    xs <- ansi_strip(x)
    xl <- trimws(xs, "left")
    nxs <- nchar(xs)
    sl <- nxs - nchar(xl)
  }

  rl <- 0L
  if (which %in% c("both", "right")) {
    xs <- ansi_strip(x)
    xr <- trimws(xs, "right")
    nxs <- nchar(xs)
    rl <- nxs - nchar(xr)
  }

  if (any(sl > 0L | rl > 0L)) {
    start <- rep_len(1L + sl, length(x))
    x <- .Call(clic_ansi_substr, x, start, ansi_nchar(x) - rl)
  }

  ansi_string(x)
}

#' Wrap an ANSI styled string to a certain width
#'
#' This function is similar to [base::strwrap()], but works on ANSI
#' styled strings, and leaves the styling intact.
#'
#' @param x ANSI string.
#' @param width Width to wrap to.
#' @param indent Indentation of the first line of each paragraph.
#' @param exdent Indentation of the subsequent lines of each paragraph.
#' @param simplify Whether to return all wrapped strings in a single
#'   character vector, or wrap each element of `x` independently and return
#'   a list.
#' @return If `simplify` is `FALSE`, then a list of character vectors,
#'   each an ANSI string. Otherwise a single ANSI string vector.
#'
#' @family ANSI string operations
#' @export
#' @examples
#' text <- cli:::lorem_ipsum()
#' # Highlight some words, that start with 's'
#' rexp <- gregexpr("\\b([sS][a-zA-Z]+)\\b", text)
#' regmatches(text, rexp) <- lapply(regmatches(text, rexp), col_red)
#' cat(text)
#'
#' wrp <- ansi_strwrap(text, width = 40)
#' cat(wrp, sep = "\n")

ansi_strwrap <- function(x, width = console_width(), indent = 0,
                         exdent = 0, simplify = TRUE) {

  if (!is.character(x)) x <- as.character(x)
  x <- enc2utf8(x)
  if (length(x) == 0) {
    return(ansi_string(x))
  }
  if (length(x) > 1) {
    wrp <- lapply(x, ansi_strwrap, width = width, indent = indent,
                  exdent = exdent, simplify = FALSE)
    if (simplify) wrp <- ansi_string(unlist(wrp))
    return(wrp)
  }

  # Workaround for bad Unicode width
  x <- unicode_pre(x)

  # Form feeds are forced line breaks
  # R 4.2 removes the \f after <https://github.com/wch/r-source/commit/101b142d04dd5456a2039d54de9483240bcc1512>
  # se we need to put in a random marker instead
  mark <- "yShtnpteEk"
  smark <- paste0("\n\n", mark, "\n\n")
  x <- gsub_("\f", smark, x, fixed = TRUE, useBytes = TRUE)
  fix_ff <- function(x) {
    xs <- ansi_strip(x)
    rem <- which(xs == mark)
    if (length(rem)) {
      x <- x[-c(rem - 1, rem + 1)]
      xs <- xs[-c(rem - 1, rem + 1)]
      if (xs[length(xs)] == mark) {
        x <- c(x, mark)
        xs <- c(xs, mark)
      }
      if (length(x) >= 2 && x[1] == "" && xs[2] == mark) {
        x <- x[-1]
        xs <- xs[-1]
      }
      # At this point, we have as many marks as many newlines we need
      # But (except for the begnning) we need one less empty lines than
      # newlines, because an empty line corresponds to two newlines at
      # the end of a non-empty line.
      del <- which(xs[-1] == mark & xs[-length(xs)] != mark) + 1L
      if (length(del) > 0) {
        x <- x[-del]
        xs <- xs[-del]
      }
      x[xs == mark] <- ""
      x
    } else {
      x
    }

  }

  # First we need to remove the multiple spaces, to make it easier to
  # map the strings later on. We do this per paragraph, to keep paragraphs.
  pars <- strsplit(x, "\n[ \t\n]*\n", perl = TRUE)
  pars <- lapply(pars, ansi_trimws)

  # Within paragraphs, replace multiple spaces with one, except when there
  # were two spaces at the end of a sentence, where we keep two.
  # This does not work well, when some space is inside an ANSI tag, and
  # some is outside, but for now, we'll live with this limitation.
  pars <- lapply(pars, function(s) {
    # First replace multiple spaces that are not at the end of a sentence
    s <- gsub("(?<![.!?])[ \t\n][ \t\n]*", " ", s, perl = TRUE)
    # Handle multiple spaces at the end of a sentence
    s <- gsub("(?<=[.!?])[ \t\n][ \t\n][ \t\n]*", "  ", s, perl = TRUE)
    # Handle simple space at the end of a sentence
    gsub("(?<=[.!?])[ \t\n]", " ", s, perl = TRUE)
  })

  # Put them back together
  xx <- vcapply(pars, function(s) paste(s, collapse = "\n\n"))

  xs <- ansi_strip(xx)
  xw0 <- base::strwrap(xs, width = width, indent = indent, exdent = exdent)
  if (xs == xx) return(ansi_string(unicode_post(fix_ff(xw0))))

  xw <- trimws(xw0, "left")
  indent <- nchar(xw0) - nchar(xw)

  # Now map the positions from xw back to xs by going over both in parallel
  splits <- 1L
  drop <- integer()
  xslen <- nchar(xs)
  xsidx <- 1L
  xwlen <- nchar(xw[1])
  xwidx <- c(1L, 1L)

  while (xsidx <= xslen) {
    xsc <- substr(xs, xsidx, xsidx)
    xwc <- substr(xw[xwidx[1]], xwidx[2], xwidx[2])
    if (is.na(xwc)) {
      # colored trailing white space in input?
      xsidx <- xsidx + 1L
    } else if (xsc == xwc) {
      xsidx <- xsidx + 1L
      xwidx[2] <- xwidx[2] + 1L
    } else if (xsc %in% c(" ", "\n", "\t")) {
      drop <- c(drop, xsidx)
      xsidx <- xsidx + 1L
    } else if (xwc == " ") {
      xwidx[2] <- xwidx[2] + 1L
    } else {
      throw(cli_error("Internal error in {.fun cli::ansi_strwrap}")) # nocov
    }

    while (xsidx <= xslen && xwidx[1] <= length(xw) && xwidx[2] > xwlen) {
      splits <- c(splits, xsidx)
      xwidx[1] <- xwidx[1] + 1L
      xwidx[2] <- 1L
      xwlen <- nchar(xw[xwidx[1]])
    }
  }
  splits <- c(splits, xsidx)

  wrp <- vcapply(seq_along(splits[-1]), function(i) {
    from <- splits[i]
    to <- splits[i + 1L] - 1L
    while (from %in% drop) from <- from + 1L
    .Call(clic_ansi_substr, xx, from, to)
  })

  indent <- strrep(" ", indent)
  ansi_string(unicode_post(fix_ff(paste0(indent, wrp))))
}

#' Truncate an ANSI string
#'
#' This function is similar to [base::strtrim()], but works correctly with
#' ANSI styled strings. It also adds `...` (or the corresponding Unicode
#' character if Unicode characters are allowed) to the end of truncated
#' strings.
#'
#' Note: `ansi_strtrim()` does not support NA values currently.
#'
#' @param x Character vector of ANSI strings.
#' @param width The width to truncate to.
#' @param ellipsis The string to append to truncated strings. Supply an
#'   empty string if you don't want a marker.
#'
#' @family ANSI string operations
#' @export
#' @examples
#' text <- cli::col_red(cli:::lorem_ipsum())
#' ansi_strtrim(c(text, "foobar"), 40)

ansi_strtrim <- function(x, width = console_width(),
                         ellipsis = symbol$ellipsis) {

  if (width < 0) {
    throw(cli_error(
      "{.arg width} must be non-negative in {.fun cli::ansi_strtrim}."
    ))
  }

  x <- enc2utf8(x)

  # Unicode width notes. We have nothing to fix here, because we'll just
  # use ansi_substr() and ansi_nchar(), which work correctly with wide
  # characters.

  # if ellipsis is already longer than width, then we just return that
  tw <- ansi_nchar(ellipsis, "width")
  if (tw == width) {
    x[] <- ellipsis
    return(x)
  } else if (tw > width) {
    x[] <- ansi_strtrim(ellipsis, width, ellipsis = "")
    return(x)
  }

  # First we cut according to _characters_. This might be too wide if we
  # have wide characters.
  lx <- length(x)
  xt <- .Call(clic_ansi_substr, x, rep(1L, lx), rep(as.integer(width), lx))

  # If there was a cut, or xt is too wide (using _width_!), that's bad
  # We keep the initial bad ones, these are the ones that need an ellipsis.
  # Then we keep chopping off single characters from the too wide ones,
  # until they are narrow enough.
  if (ansi_nzchar(ellipsis)) {
    bad0 <- bad <- !is.na(x) &
      (ansi_strip(xt) != ansi_strip(x) | ansi_nchar(xt, "width") > width)
  } else {
    # if ellipsis is zero length, then the truncated ones are not bad
    bad0 <- bad <- !is.na(x) & ansi_nchar(xt, "width") > width
  }

  while (any(bad)) {
    xt[bad] <- .Call(
      clic_ansi_substr,
      xt[bad],
      rep(1L, sum(bad)),
      ansi_nchar(xt[bad]) - 1L
    )
    bad <- ansi_nchar(xt, "width") > width - tw
  }

  xt[bad0] <- paste0(xt[bad0], ellipsis)
  xt
}

#' Format a character vector in multiple columns
#'
#' This function helps with multi-column output of ANSI styles strings.
#' It works well together with [boxx()], see the example below.
#'
#' If a string does not fit into the specified `width`, it will be
#' truncated using [ansi_strtrim()].
#'
#' ```{asciicast ansi-column}
#' fmt <- ansi_columns(
#'   paste(col_red("foo"), 1:10),
#'   width = 50,
#'   fill = "rows",
#'   max_cols=10,
#'   align = "center",
#'   sep = "   "
#' )
#' boxx(fmt, padding = c(0,1,0,1), header = col_cyan("Columns"))
#' ```
#'
#' @param text Character vector to format. Each element will formatted
#'   as a cell of a table.
#' @param width Width of the screen.
#' @param sep Separator between the columns. It may have ANSI styles.
#' @param fill Whether to fill the columns row-wise or column-wise.
#' @param max_cols Maximum number of columns to use. Will not use more,
#'   even if there is space for it.
#' @param align Alignment within the columns.
#' @param type Passed to [ansi_nchar()] and [ansi_align()]. Most probably
#'   you want the default, `"width"`.
#' @inheritParams ansi_strtrim
#' @return ANSI string vector.
#'
#' @family ANSI string operations
#' @export

ansi_columns <- function(text, width = console_width(), sep = " ",
                         fill = c("rows", "cols"), max_cols = 4,
                         align = c("left", "center", "right"),
                         type = "width", ellipsis = symbol$ellipsis) {

  fill <- match.arg(fill)
  align <- match.arg(align)

  text <- enc2utf8(text)

  if (length(text) == 0) return(ansi_string(text))

  swdh <- ansi_nchar(sep, type = "width")
  twdh <- max(ansi_nchar(text, type = type)) + swdh
  cols <- min(floor(width / twdh), max_cols)
  if (cols == 0) {
    cols <- 1
    text <- ansi_strtrim(text, width = width, ellipsis = ellipsis)
  }

  len <- length(text)
  extra <- ceiling(len / cols) * cols - len
  text <- c(text, rep("", extra))
  tm <- matrix(text, byrow = fill == "rows", ncol = cols)

  colwdh <- diff(c(0, round((width / cols)  * (1:cols))))
  for (c in seq_len(ncol(tm))) {
    tm[, c] <- ansi_align(
      paste0(tm[, c], if (cols > 1) sep),
      colwdh[c],
      align = align,
      type = type
    )
  }

  clp <- apply(tm, 1, paste0, collapse = "")
  ansi_string(clp)
}

#' ANSI character translation and case folding
#'
#' There functions are similar to [toupper()], [tolower()] and
#' [chartr()], but they keep the ANSI colors of the string.
#'
#' @inheritParams base::chartr
#' @param x Input string. May have ANSI colors and styles.
#' @return Character vector of the same length as `x`, containing
#'   the translated strings. ANSI styles are retained.
#'
#' @family ANSI string operations
#' @export
#' @examples
#' ansi_toupper(col_red("Uppercase"))
#'
#' ansi_tolower(col_red("LowerCase"))
#'
#' x <- paste0(col_green("MiXeD"), col_red(" cAsE 123"))
#' ansi_chartr("iXs", "why", x)

ansi_toupper <- function(x) {
  ansi_convert(x, toupper)
}

#' @family ANSI string operations
#' @export
#' @rdname ansi_toupper

ansi_tolower <- function(x) {
  ansi_convert(x, tolower)
}

#' @family ANSI string operations
#' @export
#' @rdname ansi_toupper

ansi_chartr <- function(old, new, x) {
  ansi_convert(x, chartr, old, new)
}

ansi_convert <- function(x, converter, ...) {
  x <- enc2utf8(x)
  ansi <- re_table(ansi_regex(), x)
  text <- non_matching(ansi, x, empty=TRUE)
  out <- mapply(x, text, USE.NAMES = FALSE, FUN = function(x1, t1) {
    t1 <- t1[t1[,1] <= t1[,2], , drop = FALSE]
    for (i in seq_len(nrow(t1))) {
      substring(x1, t1[i, 1], t1[i, 2]) <-
        converter(x = substring(x1, t1[i, 1], t1[i, 2]), ...)
    }
    x1
  })

  ansi_string(out)
}

#' Simplify ANSI styling tags
#'
#' It creates an equivalent, but possibly shorter ANSI styled string, by
#' removing duplicate and empty tags.
#'
#' @param x Input string
#' @param csi What to do with non-SGR ANSI sequences, either `"keep"`,
#'   or `"drop"` them.
#' @return Simplified `cli_ansi_string` vector.
#'
#' @export

ansi_simplify <- function(x, csi = c("keep", "drop")) {
  if (!is.character(x)) x <- as.character(x)
  csi <- match.arg(csi)
  x <- enc2utf8(x)
  .Call(clic_ansi_simplify, x, csi == "keep")
}

#' Convert ANSI styled text to HTML
#'
#' @param x Input character vector.
#' @param escape_reserved Whether to escape characters that are reserved
#'   in HTML (`&`, `<` and `>`).
#' @param csi What to do with non-SGR ANSI sequences, either `"keep"`,
#'   or `"drop"` them.
#' @return Character vector of HTML.
#'
#' @family ANSI to HTML conversion
#' @export
#' @examplesIf cli:::has_packages(c("htmltools", "withr"))
#' ## Syntax highlight the source code of an R function with ANSI tags,
#' ## and export it to a HTML file.
#' code <- withr::with_options(
#'   list(ansi.num_colors = 256),
#'   code_highlight(format(ansi_html))
#' )
#' hcode <- paste(ansi_html(code), collapse = "\n")
#' css <- paste(format(ansi_html_style()), collapse=  "\n")
#' page <- htmltools::tagList(
#'   htmltools::tags$head(htmltools::tags$style(css)),
#'   htmltools::tags$pre(htmltools::HTML(hcode))
#' )
#'
#' if (interactive()) htmltools::html_print(page)

ansi_html <- function(x, escape_reserved = TRUE, csi = c("drop", "keep")) {
  if (!is.character(x)) x <- as.character(x)
  csi <- match.arg(csi)
  x <- enc2utf8(x)
  if (escape_reserved) {
    x <- gsub_("&", "&amp;", x, fixed = TRUE, useBytes = TRUE)
    x <- gsub_("<", "&lt;",  x, fixed = TRUE, useBytes = TRUE)
    x <- gsub_(">", "&gt;",  x, fixed = TRUE, useBytes = TRUE)
  }
  .Call(clic_ansi_html, x, csi == "keep")
}

#' CSS styles for the output of `ansi_html()`
#'
#'
#'
#' @param colors Whether or not to include colors. `FALSE` will not include
#'   colors, `TRUE` or `8` will include eight colors (plus their bright
#'   variants), `256` will include 256 colors.
#' @param palette Character scalar, palette to use for the first eight colors
#'   plus their bright variants. Terminals define these colors differently,
#'   and cli includes a couple of examples. Sources of palettes:
#'   * https://en.wikipedia.org/wiki/ANSI_escape_code#3-bit_and_4-bit
#'   * iTerm2 builtin palettes
#'   * <https://github.com/sindresorhus/iterm2-snazzy>
#' @return Named list of CSS declaration blocks, where the names are
#'   CSS selectors. It has a `format()` and `print()` methods, which you
#'   can use to write the output to a CSS or HTML file.
#'
#' @family ANSI to HTML conversion
#' @export
#' @examples
#' ansi_html_style(colors = FALSE)
#' ansi_html_style(colors = 8, palette = "iterm-snazzy")

ansi_html_style <- function(colors = TRUE, palette = NULL) {
  if (is.character(palette)) {
    palette <- match.arg(palette)
    palette <- as.list(ansi_palettes[palette, ])
  }

  stopifnot(
    isTRUE(colors) || identical(colors, FALSE) ||
      (is_count(colors) && colors %in% c(8,256)),
    is_string(palette) || is.list(palette) && length(palette) == 16
  )

  ret <- list(
    ".ansi-bold"       = "{ font-weight: bold;             }",
    # .ansi-faint ???
    ".ansi-italic"     = "{ font-style: italic;            }",
    ".ansi-underline"  = "{ text-decoration: underline;    }",
    ".ansi-blink"      = "{ text-decoration: blink;        }",
    # .ansi-inverse ???
    ".ansi-hide"       = "{ visibility: hidden;            }",
    ".ansi-crossedout" = "{ text-decoration: line-through; }",
    ".ansi-link:hover" = "{ text-decoration: underline;    }"
  )

  if (!identical(colors, FALSE)) {
    fg <- structure(
      names = paste0(".ansi-color-", 0:15),
      paste0("{ color: ", palette, " }")
    )
    bg <- structure(
      names = paste0(".ansi-bg-color-", 0:15),
      paste0("{ background-color: ", palette, " }")
    )
    ret <- c(ret, fg, bg)
  }

  if (isTRUE(colors) || colors == 256) {
    grid <- expand.grid(r = 0:5, g = 0:5, b = 0:5)
    num <- 16 + 36 * grid$r + 6 * grid$g + grid$b
    cols <- grDevices::rgb(grid$r, grid$g, grid$b, maxColorValue = 5)
    fg256 <- structure(
      names = paste0(".ansi-color-", num),
      paste0("{ color: ", tolower(cols), " }")
    )
    bg256 <- structure(
      names = paste0(".ansi-bg-color-", num),
      paste0("{ background-color: ", tolower(cols), " }")
    )
    gr <- seq(1, 24)
    grcols <- grDevices::rgb(gr, gr, gr, maxColorValue = 25)
    fggrey <- structure(
      names = paste0(".ansi-color-", 232:255),
      paste0("{ color: ", tolower(grcols), " }")
    )
    bggrey <- structure(
      names = paste0(".ansi-bg-color-", 232:255),
      paste0("{ background-color: ", tolower(grcols), " }")
    )
    ret <- c(ret, fg256, fggrey, bg256, bggrey)
  }

  class(ret) <- "cli_ansi_html_style"
  ret
}

# This avoids duplication, but messes up the source ref of the function...
formals(ansi_html_style)$palette <- c("vscode", setdiff(rownames(ansi_palettes), "vscode"))
attr(body(ansi_html_style), "srcref") <- NULL
attr(body(ansi_html_style), "wholeSrcref") <- NULL
attr(body(ansi_html_style), "srcfile") <- NULL

#' @export

format.cli_ansi_html_style <- function(x, ...) {
  paste0(format(names(x)), " ", x)
}

#' @export

print.cli_ansi_html_style <- function(x, ...) {
  cat(format(x, ...), sep = "\n")
}

#' Like [base::grep()] and [base::grepl()], but for ANSI strings
#'
#' First ANSI sequences will be stripped with [ansi_strip()], both
#'
#' Note that these functions work on code points (or bytes if
#' `useBytes = TRUE`), and not graphemes.
#'
#' Unlike [base::grep()] and [base::grepl()] these functions do not special
#' case factors.
#'
#' Both `pattern` and `x` are converted to UTF-8.
#'
#' @param pattern Character scalar, regular expression or fixed string
#'   (if `fixed = TRUE`), the pattern to search for. Other objects will be
#'   coerced using [as.character()].
#' @param x Character vector to search in. Other objects will be coerced
#'   using [as.character()].
#' @param ignore.case,perl,value Passed to [base::grep()].
#' @param ... Extra arguments are passed to [base::grep()] or [base::grepl()].
#' @return The same as [base::grep()] and [base::grepl()], respectively.
#'
#' @export
#' @examples
#' red_needle <- col_red("needle")
#' haystack <- c("foo", "needle", "foo")
#' green_haystack <- col_green(haystack)
#' ansi_grepl(red_needle, haystack)
#' ansi_grepl(red_needle, green_haystack)

ansi_grep <- function(pattern, x, ignore.case = FALSE, perl = FALSE,
                      value = FALSE, ...) {

  # if value = FALSE, then we want to return the original values as
  # ansi strings, so we need to special case that
  if (value) {
    idx <- ansi_grep(pattern, x, ignore.case = ignore.case, perl = perl,
                     value = FALSE, ...)
    ansi_string(x[idx])
  } else {
    ansi_grep_internal(grep, pattern, x, ignore.case = ignore.case,
                       perl = perl, value = value, ...)
  }
}

#' @rdname ansi_grep
#' @export

ansi_grepl <- function(pattern, x, ...) {
  ansi_grep_internal(grepl, pattern, x, ...)
}

ansi_grep_internal <- function(fun, pattern, x, ...) {
  pattern <- ansi_strip(pattern)
  x <- ansi_strip(x)
  fun(pattern, x, ...)
}

#' Like [base::nzchar()], but for ANSI strings
#'
#' @param x Charcater vector. Other objects are coarced using
#'   [base::as.character()].
#' @param ... Passed to [base::nzchar()].
#' @export
#' @examples
#' ansi_nzchar("")
#' ansi_nzchar(col_red(""))

ansi_nzchar <- function(x, ...) {
  x <- ansi_strip(x)
  nzchar(x, ...)
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/app.R"

cliappenv <- new.env()
cliappenv$stack <- list()
cliappenv$pid <- Sys.getpid()

#' Start, stop, query the default cli application
#'
#' `start_app` creates an app, and places it on the top of the app stack.
#'
#' `stop_app` removes the top app, or multiple apps from the app stack.
#'
#' `default_app` returns the default app, the one on the top of the stack.
#'
#' @param theme Theme to use.
#' @param output How to print the output.
#' @param .auto_close Whether to stop the app, when the calling frame
#'   is destroyed.
#' @param .envir The environment to use, instead of the calling frame,
#'   to trigger the stop of the app.
#' @param app App to stop. If `NULL`, the current default app is stopped.
#'   Otherwise we find the supplied app in the app stack, and remote it,
#'   together with all the apps above it.
#' @return
#'   `start_app` returns the new app, `default_app` returns the default app.
#'   `stop_app` does not return anything.
#'
#' @export

start_app <- function(theme = getOption("cli.theme"),
                      output = c("auto", "message", "stdout", "stderr"),
                      .auto_close = TRUE, .envir = parent.frame()) {

  if (! inherits(output, "connection")) output <- match.arg(output)

  app <- cliapp(
    theme = theme,
    user_theme = getOption("cli.user_theme"),
    output = output
  )
  cliappenv$stack[[length(cliappenv$stack) + 1]] <- app

  if (.auto_close && !identical(.envir, globalenv())) {
    defer(stop_app(app = app), envir = .envir, priority = "first")
  }

  invisible(app)
}

#' @export
#' @name start_app

stop_app <- function(app = NULL) {
  if (is.null(app)) {
    cliappenv$stack <- utils::head(cliappenv$stack, -1)

  } else {
    if (!inherits(app, "cliapp")) {
      throw(cli_error(
        "{.arg app} must be a CLI app",
        "i" = "{.arg app} is {.type {app}}"
      ))
    }
    ndl <- format.default(app)
    nms <- vapply(cliappenv$stack, format.default, character(1))
    if (! ndl %in% nms) {
      warning("No app to end")
      return()
    }
    wh <- which(nms == ndl)[1]
    cliappenv$stack <- utils::head(cliappenv$stack, wh - 1)
  }

  invisible()
}

#' @export
#' @name start_app

default_app <- function() {
  top <- utils::tail(cliappenv$stack, 1)
  if (length(top)) top[[1]] else NULL
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/assertions.R"

is_string <- function(x) {
  is.character(x) && length(x) == 1 && !is.na(x)
}

is_flag <- function(x) {
  is.logical(x) && length(x) == 1 && !is.na(x)
}

is_border_style <- function(x) {
  is_string(x) && x %in% rownames(box_styles())
}

is_padding_or_margin <- function(x) {
  is.numeric(x) && length(x) %in% c(1, 4) && !anyNA(x) &&
    all(as.integer(x) == x)
}

is_col <- function(x) {
  is.null(x) || is_string(x) || is.function(x)
}

is_count <- function(x) {
  is.numeric(x) && length(x) == 1 && !is.na(x) && as.integer(x) == x &&
    x >= 0
}

is_tree_style <- function(x) {
  is.list(x) &&
    length(x) == 4 &&
    !is.null(names(x)) &&
    all(sort(names(x)) == sort(c("h", "v", "l", "j"))) &&
    all(sapply(x, is_string))
}

is_named <- function(x) {
  !is.null(names(x))
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/box-styles.R"

box_styles <- function() {

  styles <- list(
    single = list(
      top_left     = "\u250c",
      top_right    = "\u2510",
      bottom_right = "\u2518",
      bottom_left  = "\u2514",
      vertical    = "\u2502",
      horizontal  = "\u2500"
    ),
    double = list(
      top_left = "\u2554",
      top_right = "\u2557",
      bottom_right = "\u255d",
      bottom_left = "\u255a",
      vertical = "\u2551",
      horizontal = "\u2550"
    ),
    round= list(
      top_left = "\u256d",
      top_right = "\u256e",
      bottom_right = "\u256f",
      bottom_left = "\u2570",
      vertical = "\u2502",
      horizontal = "\u2500"
    ),
    "single-double" = list(
      top_left = "\u2553",
      top_right = "\u2556",
      bottom_right = "\u255c",
      bottom_left = "\u2559",
      vertical = "\u2551",
      horizontal = "\u2500"
    ),
    "double-single" = list(
      top_left = "\u2552",
      top_right = "\u2555",
      bottom_right = "\u255b",
      bottom_left = "\u2558",
      vertical = "\u2502",
      horizontal = "\u2550"
    ),
    classic = list(
      top_left = "+",
      top_right = "+",
      bottom_right = "+",
      bottom_left = "+",
      vertical = "|",
      horizontal = "-"
    ),
    none = list(
      top_left = " ",
      top_right = " ",
      bottom_right = " ",
      bottom_left = " ",
      vertical = " ",
      horizontal = " "
    )
  )

  ## If the platform is not UTF-8, then we replace the styles that have
  ## Unicode characters, with the classic style.

  if (!is_utf8_output()) {
    for (n in setdiff(names(styles), c("classic", "none"))) {
      styles[[n]] <- styles[["classic"]]
    }
  }

  do.call(rbind, styles)
}

#' @export
#' @rdname boxx

list_border_styles <- function() {
  rownames(box_styles())
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/boxes.R"


#' Draw a banner-like box in the console
#'
#' @details
#'
#' ## Defaults
#'
#' ```{asciicast box-default}
#' boxx("Hello there!")
#' ```
#'
#' ## Change border style
#'
#' ```{asciicast box-border}
#' boxx("Hello there!", border_style = "double")
#' ```
#'
#' ## Multiple lines
#'
#' ```{asciicast box-lines}
#' boxx(c("Hello", "there!"), padding = 1)
#' ```
#'
#' ## Padding
#'
#' ```{asciicast box-padding}
#' boxx("Hello there!", padding = 1)
#' boxx("Hello there!", padding = c(1, 5, 1, 5))
#' ```
#'
#' ## Floating
#'
#' ```{asciicast box-float}
#' boxx("Hello there!", padding = 1, float = "center")
#' boxx("Hello there!", padding = 1, float = "right")
#' ```
#'
#' ## Text color
#'
#' ```{asciicast box-text-color}
#' boxx(col_cyan("Hello there!"), padding = 1, float = "center")
#' ```
#'
#' ## Background color
#'
#' ```{asciicast box-bg-color}
#' boxx("Hello there!", padding = 1, background_col = "brown")
#' boxx("Hello there!", padding = 1, background_col = bg_red)
#' ```
#'
#' ## Border color
#'
#' ```{asciicast box-border-color}
#' boxx("Hello there!", padding = 1, border_col = "green")
#' boxx("Hello there!", padding = 1, border_col = col_red)
#' ```
#'
#' ## Label alignment
#'
#' ```{asciicast box-label-align}
#' boxx(c("Hi", "there", "you!"), padding = 1, align = "left")
#' boxx(c("Hi", "there", "you!"), padding = 1, align = "center")
#' boxx(c("Hi", "there", "you!"), padding = 1, align = "right")
#' ```
#'
#' ## A very customized box
#'
#' ```{asciicast box-custom}
#' star <- symbol$star
#' label <- c(paste(star, "Hello", star), "  there!")
#' boxx(
#'   col_white(label),
#'   border_style="round",
#'   padding = 1,
#'   float = "center",
#'   border_col = "tomato3",
#'   background_col="darkolivegreen"
#' )
#' ```
#'
#' @param label Label to show, a character vector. Each element will be
#'   in a new line. You can color it using the `col_*`, `bg_*` and
#'   `style_*` functions, see [ANSI styles][ansi-styles] and the examples
#'   below.
#' @param header Text to show on top border of the box. If too long,
#'   it will be cut.
#' @param footer Text to show on the bottom border of the box. If too long,
#'   it will be cut.
#' @param border_style String that specifies the border style.
#'   `list_border_styles` lists all current styles.
#' @param padding Padding within the box. Either an integer vector of
#'   four numbers (bottom, left, top, right), or a single number `x`, which
#'   is interpreted as `c(x, 3*x, x, 3*x)`.
#' @param margin Margin around the box. Either an integer vector of four
#'   numbers (bottom, left, top, right), or a single number `x`, which is
#'   interpreted as `c(x, 3*x, x, 3*x)`.
#' @param float Whether to display the box on the `"left"`, `"center"`, or
#'   the `"right"` of the screen.
#' @param background_col Background color of the inside of the box.
#'   Either a style function (see [ANSI styles][ansi-styles]), or a color
#'   name which will be used in [make_ansi_style()] to create a
#'   *background* style (i.e. `bg = TRUE` is used).
#' @param col Color of text, and default border color. Either a style
#'   function (see [ANSI styles][ansi-styles]) or a color name that is
#'   passed to [make_ansi_style()].
#' @param border_col Color of the border. Either a style function
#'   (see [ANSI styles][ansi-styles]) or a color name that is passed to
#'   [make_ansi_style()].
#' @param align Alignment of the label within the box: `"left"`,
#'   `"center"`, or `"right"`.
#' @param width Width of the screen, defaults to [console_width()].
#'
#' @section About fonts and terminal settings:
#' The boxes might or might not look great in your terminal, depending
#' on the box style you use and the font the terminal uses. We found that
#' the Menlo font looks nice in most terminals an also in Emacs.
#'
#' RStudio currently has a line height greater than one for console output,
#' which makes the boxes ugly.
#'
#' @export

boxx <- function(label, header = "", footer = "",
                 border_style = "single", padding = 1, margin = 0,
                 float = c("left", "center", "right"),
                 col = NULL, background_col = NULL, border_col = col,
                 align = c("left", "center", "right"),
                 width = console_width()) {

  label <- apply_style(as.character(label), col)
  widest <- max(ansi_nchar(label, "width"), 0)

  stopifnot(
    is_border_style(border_style),
    is_padding_or_margin(padding),
    is_padding_or_margin(margin)
  )
  float <- match.arg(float)
  align <- match.arg(align)

  if (length(padding) == 1) {
    padding <- c(padding, padding * 3, padding, padding * 3)
  }
  if (length(margin) == 1) {
    margin <- c(margin, margin * 3, margin, margin * 3)
  }

  label <- ansi_align(label, align = align, width = widest)
  content_width <- widest + padding[2] + padding[4]

  mar_left <- if (float == "center") {
    make_space((width - content_width) / 2)
  } else if (float == "right") {
    make_space(max(width - content_width - 2, 0))
  } else {
    make_space(margin[2])
  }

  color_border <- function(x) apply_style(x, border_col)
  color_content <- function(x) apply_style(x, background_col, bg = TRUE)

  label <- c(rep("", padding[3]), label, rep("", padding[1]))

  chars <- box_styles()[border_style, ]

  pad_left <- make_space(padding[2])
  pad_right <- make_space(
    content_width - ansi_nchar(label, "width") - padding[2]
  )

  if (header != "") {
    header <- paste0(" ", ansi_strtrim(header, content_width - 2), " ")
  }
  hdw <- ansi_nchar(header, "width")
  if (footer != "") {
    footer <- paste0(" ", ansi_strtrim(footer, content_width - 2), " ")
  }
  ftw <- ansi_nchar(footer, "width")

  hdline <- paste0(header, strrep(chars$horizontal, content_width - hdw))
  top <- color_border(paste0(
    strrep("\n", margin[3]),
    mar_left, chars$top_left, hdline, chars$top_right
  ))
  ftline <- paste0(strrep(chars$horizontal, content_width - ftw), footer)
  bottom <- color_border(paste0(
    mar_left, chars$bottom_left, ftline, chars$bottom_right,
    strrep("\n", margin[1])
  ))
  side <- color_border(chars$vertical)

  middle <- paste0(mar_left, side,
                   color_content(paste0(pad_left, label, pad_right)), side)

  box <- paste0(top, "\n", paste0(middle, collapse = "\n"), "\n", bottom)

  class(box) <- unique(c("cli_boxx", "boxx", class(box), "character"))
  box
}

methods::setOldClass(c("cli_boxx", "character"))

#' @export

print.cli_boxx <- function(x, ..., sep = "\n") {
  cat(x, ..., sep = sep)
  invisible(x)
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/bullets.R"

#' List of items
#'
#' It is often useful to print out a list of items, tasks a function or
#' package performs, or a list of notes.
#'
#' @details
#'
#' Items may be formatted differently, e.g. they can have a prefix symbol.
#' Formatting is specified by the names of `text`, and can be themed.
#' cli creates a `div` element of class `bullets` for the whole bullet list.
#' Each item is another `div` element of class `bullet-<name>`, where
#' `<name>` is the name of the entry in `text`. Entries in `text` without
#' a name create a `div` element of class `bullet-empty`, and if the
#' name is a single space character, the class is `bullet-space`.
#'
#' The built-in theme defines the following item types:
#' * No name: Item without a prefix.
#' * ` `: Indented item.
#' * `*`: Item with a bullet.
#' * `>`: Item with an arrow or pointer.
#' * `v`: Item with a green "tick" symbol, like [cli_alert_success()].
#' * `x`: Item with a ref cross, like [cli_alert_danger()].
#' * `!`: Item with a yellow exclamation mark, like [cli_alert_warning()].
#' * `i`: Info item, like [cli_alert_info()].
#'
#' You can define new item type by simply defining theming for the
#' corresponding `bullet-<name>` classes.
#'
#' ```{asciicast cli-bullets}
#' cli_bullets(c(
#'         "noindent",
#'   " " = "indent",
#'   "*" = "bullet",
#'   ">" = "arrow",
#'   "v" = "success",
#'   "x" = "danger",
#'   "!" = "warning",
#'   "i" = "info"
#' ))
#' ```
#'
#' @param text Character vector of items. See details below on how names
#' are interpreted.
#' @param id Optional id of the `div.bullets` element, can be used in themes.
#' @param class Optional additional class(es) for the `div.bullets` element.
#' @param .envir Environment to evaluate the glue expressions in.
#'
#' @seealso This function supports [inline markup][inline-markup].
#' @family functions supporting inline markup
#' @export

cli_bullets <- function(text, id = NULL, class = NULL,
                     .envir = parent.frame()) {
  cli__message(
    "bullets",
    list(
      text = structure(
        lapply(text, glue_cmd, .envir = .envir),
        names = names(text)
      ),
      id = id,
      class = class
    )
  )
}

#' List of verbatim items
#'
#' `cli_format_bullets_raw()` is similar to [cli_bullets()], but it does
#' not perform any inline styling or glue substitutions in the input.
#'
#' `format_bullets_raw()` returns the output instead of printing it.
#'
#' @param text Character vector of items. See details below on how names
#' are interpreted.
#' @param id Optional id of the `div.bullets` element, can be used in themes.
#' @param class Optional additional class(es) for the `div.bullets` element.
#'
#' @seealso These functions support [inline markup][inline-markup].
#' @seealso See [cli_bullets()] for examples.
#' @family functions supporting inline markup
#' @export

cli_bullets_raw <- function(text, id = NULL, class = NULL) {
  text <- cli_escape(text)
  cli__message(
    "bullets",
    list(
      text = structure(
        lapply(text, glue_no_cmd),
        names = names(text)
      ),
      id = id,
      class = class
    )
  )
}

#' @rdname cli_bullets_raw
#' @export

format_bullets_raw <- function(text, id = NULL, class = NULL) {
  cli_fmt(cli_bullets_raw(text, id, class))
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/cat.R"
#' `cat()` helpers
#'
#' These helpers provide useful wrappers around [cat()]: most importantly
#' they all set `sep = ""`, and `cat_line()` automatically adds a newline.
#'
#' @export
#' @param ... For `cat_line()` and `cat_bullet()`, pasted together with
#'   `collapse = "\n"`. For `cat_rule()` and `cat_boxx()` passed on to
#'   [rule()] and [boxx()] respectively.
#' @param bullet Name of bullet character. Indexes into [symbol]
#' @param col,background_col,bullet_col Colors for text, background, and
#'   bullets respectively.
#' @param x An object to print.
#' @param file Output destination. Defaults to standard output.
#' @examples
#' cat_line("This is ", "a ", "line of text.", col = "red")
#' cat_bullet(letters[1:5])
#' cat_bullet(letters[1:5], bullet = "tick", bullet_col = "green")
#' cat_rule()
cat_line <- function(..., col = NULL, background_col = NULL, file = stdout()) {
  out <- paste0(..., collapse = "\n")
  out <- apply_style(out, col)
  out <- apply_style(out, background_col, bg = TRUE)

  cat(out, "\n", sep = "", file = file, append = TRUE)
}

#' @export
#' @rdname cat_line
cat_bullet <- function(..., col = NULL, background_col = NULL,
                       bullet = "bullet", bullet_col = NULL,
                       file = stdout()) {
  out <- apply_style(paste0(...), col)
  bullet <- apply_style(symbol[[bullet]], bullet_col)

  cat_line(paste(bullet, out), background_col = background_col, file = file)
}

#' @export
#' @rdname cat_line
cat_boxx <- function(..., file = stdout()) {
  cat_line(boxx(...), file = file)
}

#' @export
#' @rdname cat_line
cat_rule <- function(..., file = stdout()) {
  cat_line(rule(...), file = file)
}

#' @export
#' @rdname cat_line
cat_print <- function(x, file = "") {
  if (!identical(file, "")) {
    sink(file)
    on.exit(sink(NULL))
  }

  print(x)
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/cli-errors.R"

cli_error <- function(..., .data = NULL, .class = NULL, .envir = parent.frame(),
                      call. = TRUE) {
  .hide_from_trace <- TRUE
  cnd <- new_error(
    call. = call.,
    format_error(
      .envir = .envir,
      c(
        ...
      )
    )
  )

  if (length(.data)) cnd[names(.data)] <- .data
  if (length(class)) class(cnd) <- c(.class, class(cnd))

  cnd
}

stop_if_not <- function(message, ..., .envir = parent.frame(),
                        call. = sys.call(-1)) {
  conds <- list(...)
  for (cond in conds) {
    if (!cond) {
      throw(
        new_error(format_error(.envir = .envir, message), call. = call.),
        frame = .envir
      )
    }
  }
}

`%??%` <- function(expr, err) {
  chain_error(expr, err, srcref = utils::getSrcref(sys.call()))
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/cli-package.R"
#' @aliases cli-package NULL
#' @keywords internal
"_PACKAGE"

## usethis namespace: start
## usethis namespace: end
NULL
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/cli.R"

#' Compose multiple cli functions
#'
#' `cli()` will record all `cli_*` calls in `expr`, and emit them together
#' in a single message. This is useful if you want to built a larger
#' piece of output from multiple `cli_*` calls.
#'
#' Use this function to build a more complex piece of CLI that would not
#' make sense to show in pieces.
#'
#' ```{asciicast cli-cli}
#' cli({
#'   cli_h1("Title")
#'   cli_h2("Subtitle")
#'   cli_ul(c("this", "that", "end"))
#' })
#' ```
#'
#' @param expr Expression that contains `cli_*` calls. Their output is
#' collected and sent as a single message.
#' @return Nothing.
#'
#' @export

cli <- function(expr) {
  cond <- cli__message_create("meta", cli__rec(expr))
  # cli() might be nested
  record <- getOption("cli.record")
  if (is.null(record)) {
    cli__message_emit(cond)
  } else {
    cli_recorded[[record]] <- c(cli_recorded[[record]], list(cond))
  }
  invisible()
}

cli__rec <- function(expr) {
  id <- new_uuid()
  cli_recorded[[id]] <- list()
  on.exit(rm(list = id, envir = cli_recorded), add = TRUE)
  old <- options(cli.record = id)
  on.exit(options(old), add = TRUE)
  expr
  cli_recorded[[id]]
}

cli__fmt <- function(record, collapse = FALSE, strip_newline = FALSE,
                     app = NULL) {
  app <- app %||% default_app() %||% start_app(.auto_close = FALSE)

  old <- app$output
  oldsig <- app$signal
  on.exit(app$output <- old, add = TRUE)
  on.exit(app$signal <- oldsig, add = TRUE)
  out <- rawConnection(raw(1000), open = "wb")
  on.exit(close(out), add = TRUE)
  app$output <- out
  app$signal <- FALSE

  for (msg in record) {
    do.call(app[[msg$type]], msg$args)
  }

  txt <- rawToChar(rawConnectionValue(out))
  Encoding(txt) <- "UTF-8"
  if (!collapse) {
    txt <- unlist(strsplit(txt, "\n", fixed = TRUE))
  } else if (strip_newline) {
    txt <- substr(txt, 1, nchar(txt) - 1L)
  }
  txt
}

#' Capture the output of cli functions instead of printing it
#'
#' @param expr Expression to evaluate, containing `cli_*()` calls,
#'   typically.
#' @param collapse Whether to collapse the output into a single character
#'   scalar, or return a character vector with one element for each line.
#' @param strip_newline Whether to strip the trailing newline.
#'
#' @export
#' @examples
#' cli_fmt({
#'   cli_alert_info("Loading data file")
#'   cli_alert_success("Loaded data file")
#' })

cli_fmt <- function(expr, collapse = FALSE, strip_newline = FALSE) {
  rec <- cli__rec(expr)
  cli__fmt(rec, collapse, strip_newline)
}

#' Format and returns a line of text
#'
#' You can use this function to format a line of cli text, without emitting
#' it to the screen. It uses [cli_text()] internally.
#'
#' `format_inline()` performs no width-wrapping.
#'
#' @param ... Passed to [cli_text()].
#' @param .envir Environment to evaluate the expressions in.
#' @param collapse Whether to collapse the result if it has multiple
#'   lines, e.g. because of `\f` characters.
#' @param keep_whitespace Whether to keep all whitepace (spaces, newlines
#'   and form feeds) as is in the input.
#' @return Character scalar, the formatted string.
#'
#' @seealso This function supports [inline markup][inline-markup].
#' @family functions supporting inline markup
#' @export
#' @examples
#' format_inline("A message for {.emph later}, thanks {.fn format_inline}.")

format_inline <- function(..., .envir = parent.frame(), collapse = TRUE,
                          keep_whitespace = TRUE) {
  opts <- options(cli.width = Inf)
  on.exit(options(opts), add = TRUE)
  fun <- if (keep_whitespace) cli_inline else cli_text
  cli_fmt(
    fun(..., .envir = .envir),
    collapse = collapse,
    strip_newline = TRUE
  )
}

#' CLI text
#'
#' Write some text to the screen. This function is most appropriate for
#' longer paragraphs. See [cli_alert()] for shorter status messages.
#'
#' @details
#'
#' ## Text wrapping
#'
#' Text is wrapped to the console width, see [console_width()].
#'
#' ```{asciicast cli-text}
#' cli_text(cli:::lorem_ipsum())
#' ```
#'
#' ## New lines
#'
#' A `cli_text()` call always appends a newline character to the end.
#'
#' ```{asciicast cli-text-newline}
#' cli_text("First line.")
#' cli_text("Second line.")
#' ```
#'
#' ## Styling
#'
#' You can use [inline markup][inline-markup], as usual.
#'
#' ```{asciicast cli-text-markup}
#' cli_text("The {.fn cli_text} function in the {.pkg cli} package.")
#' ```
#'
#' ## Interpolation
#'
#' String interpolation via glue works as usual. Interpolated vectors
#' are collapsed.
#'
#' ```{asciicast cli-text-glue}
#' pos <- c(5, 14, 25, 26)
#' cli_text("We have {length(pos)} missing measurements: {pos}.")
#' ```
#'
#' ## Styling and interpolation
#'
#' Use double braces to combine styling and string interpolation.
#'
#' ```{asciicast cli-text-glue-style}
#' fun <- "cli-text"
#' pkg <- "cli"
#' cli_text("The {.fn {fun}} function in the {.pkg {pkg}} package.")
#' ```
#'
#' ## Multiple arguments
#'
#' Arguments are concatenated.
#'
#' ```{asciicast cli-text-concat}
#' cli_text(c("This ", "will ", "all "), "be ", "one ", "sentence.")
#' ```
#'
#' ## Containers
#'
#' You can use `cli_text()` within cli [containers].
#'
#' ```{asciicast cli-text-containers}
#' ul <- cli_ul()
#' cli_li("First item.")
#' cli_text("Still the {.emph first} item")
#' cli_li("Second item.")
#' cli_text("Still the {.emph second} item")
#' cli_end(ul)
#' ```
#'
#' @param ... The text to show, in character vectors. They will be
#'   concatenated into a single string. Newlines are _not_ preserved.
#' @param .envir Environment to evaluate the glue expressions in.
#'
#' @seealso This function supports [inline markup][inline-markup].
#' @family functions supporting inline markup
#' @export

cli_text <- function(..., .envir = parent.frame()) {
  cli__message("text", list(text = glue_cmd(..., .envir = .envir, .call = sys.call())))
}

cli_inline <- function(..., .envir = parent.frame()) {
  cli__message(
    "inline_text",
    list(
      text = glue_cmd(..., .envir = .envir, .call = sys.call(), .trim = FALSE)
    )
  )
}

#' CLI verbatim text
#'
#' It is not wrapped, but printed as is. Long lines will overflow.
#' No glue substitution is performed on verbatim text.
#'
#' @details
#'
#' ## Line breaks
#'
#' ```{asciicast cli-verbatim}
#' cli_verbatim("This has\nthree\nlines,")
#' ```
#'
#' ## Special characters
#'
#' No glue substitution happens here.
#'
#' ```{asciicast cli-verbatim-2}
#' cli_verbatim("No string {interpolation} or {.emph styling} here")
#' ```
#'
#' @param ... The text to show, in character vectors. Each element is
#'   printed on a new line.
#' @param .envir Environment to evaluate the glue expressions in.
#'
#' @seealso [cli_code()] for printing R or other source code.
#' @export

cli_verbatim <- function(..., .envir = parent.frame()) {
  cli__message("verbatim", c(list(...), list(.envir = .envir)))
}

#' CLI headings
#'
#' cli has three levels of headings.
#'
#' @details
#'
#' This is how the headings look with the default builtin theme.
#'
#' ```{asciicast, cli-h1}
#' cli_h1("Header {.emph 1}")
#' cli_h2("Header {.emph 2}")
#' cli_h3("Header {.emph 3}")
#' ```
#'
#' @param text Text of the heading. It can contain inline markup.
#' @param id Id of the heading element, string. It can be used in themes.
#' @param class Class of the heading element, string. It can be used in
#'   themes.
#' @param .envir Environment to evaluate the glue expressions in.
#'
#' @seealso These functions supports [inline markup][inline-markup].
#' @family functions supporting inline markup
#' @export

cli_h1 <- function(text, id = NULL, class = NULL, .envir = parent.frame()) {
  cli__message(
    "h1",
    list(
      text = glue_cmd(text, .envir = .envir, .call = sys.call()),
      id = id,
      class = class
    )
  )
}

#' @rdname cli_h1
#' @export

cli_h2 <- function(text, id = NULL, class = NULL, .envir = parent.frame()) {
  cli__message(
    "h2",
    list(
      text = glue_cmd(text, .envir = .envir, .call = sys.call()),
      id = id,
      class = class
    )
  )
}

#' @rdname cli_h1
#' @export

cli_h3 <- function(text, id = NULL, class = NULL, .envir = parent.frame()) {
  cli__message(
    "h3",
    list(
      text = glue_cmd(text, .envir = .envir, .call = sys.call()),
      id = id,
      class = class
    )
  )
}

#' Generic CLI container
#'
#' See [containers]. A `cli_div` container is special, because it may
#' add new themes, that are valid within the container.
#'
#' @details
#'
#' ## Custom themes
#'
#' ```{asciicast cli-div}
#' d <- cli_div(theme = list(h1 = list(color = "cyan",
#'                                     "font-weight" = "bold")))
#' cli_h1("Custom title")
#' cli_end(d)
#' ```
#'
#' ## Auto-closing
#'
#' By default a `cli_div()` is closed automatically when the calling
#' frame exits.
#'
#' ```{asciicast cli-div-close}
#' div <- function() {
#'   cli_div(class = "tmp", theme = list(.tmp = list(color = "yellow")))
#'   cli_text("This is yellow")
#' }
#' div()
#' cli_text("This is not yellow any more")
#' ```
#'
#' @param id Element id, a string. If `NULL`, then a new id is generated
#'   and returned.
#' @param class Class name, sting. Can be used in themes.
#' @param theme A custom theme for the container. See [themes].
#' @param .auto_close Whether to close the container, when the calling
#'   function finishes (or `.envir` is removed, if specified).
#' @param .envir Environment to evaluate the glue expressions in. It is
#'   also used to auto-close the container if `.auto_close` is `TRUE`.
#' @return The id of the new container element, invisibly.
#'
#' @export

cli_div <- function(id = NULL, class = NULL, theme = NULL,
                    .auto_close = TRUE, .envir = parent.frame()) {
  cli__message("div", list(id = id, class = class, theme = theme),
               .auto_close = .auto_close, .envir = .envir)
}

#' CLI paragraph
#'
#' The builtin theme leaves an empty line between paragraphs.
#' See also [containers].
#'
#' ```{asciicast cli-par}
#' clifun <- function() {
#'   cli_par()
#'   cli_text(cli:::lorem_ipsum())
#' }
#' clifun()
#' clifun()
#' ```
#'
#' @param id Element id, a string. If `NULL`, then a new id is generated
#'   and returned.
#' @param class Class name, sting. Can be used in themes.
#' @inheritParams cli_div
#' @return The id of the new container element, invisibly.
#'
#' @export

cli_par <- function(id = NULL, class = NULL, .auto_close = TRUE,
                    .envir = parent.frame()) {
  cli__message("par", list(id = id, class = class),
               .auto_close = .auto_close, .envir = .envir)
}

#' Close a CLI container
#'
#' Containers aut0-close by default, but sometimes you need to explicitly
#' close them. Closing a container also closes all of its nested
#' containers.
#'
#' @details
#'
#' ## Explicit closing
#'
#' ```{asciicast cli-end}
#' cnt <- cli_par()
#' cli_text("First paragraph.")
#' cli_end(cnt)
#' cnt <- cli_par()
#' cli_text("Second paragraph.")
#' cli_end(cnt)
#' ```
#'
#' ## Closing a stack of containers
#'
#' ```{asciicast cli-end-many}
#' list <- cli_ul()
#' cli_li("Item one:")
#' cli_li("Item two:")
#' cli_par()
#' cli_text("Still item two.")
#' cli_end(list)
#' cli_text("Not in the list any more")
#' ```
#'
#' ## Omitting `id`
#'
#' If `id` is omitted, the container that was opened last will be closed.
#'
#' ```{asciicast cli-end-noid}
#' cli_par()
#' cli_text("First paragraph")
#' cli_end()
#' cli_par()
#' cli_text("Second paragraph")
#' cli_end()
#' ```
#'
#' ## Debugging containers
#'
#' You can use the internal `cli:::cli_debug_doc()` function to see the
#' currently open containers.
#'
#' ```{asciicast cli-end-debug}
#' fun <- function() {
#'   cli_div(id = "mydiv")
#'   cli_par(class = "myclass")
#'   cli:::cli_debug_doc()
#' }
#' fun()
#' ```
#'
#' @param id Id of the container to close. If missing, the current
#' container is closed, if any.
#'
#' @export

cli_end <- function(id = NULL) {
  cli__message("end", list(id = id %||% NA_character_))
}

#' Unordered CLI list
#'
#' An unordered list is a container, see [containers].
#'
#' @details
#'
#' ## Adding all items at once
#'
#' ```{asciicast cli-ul}
#' fun <- function() {
#'   cli_ul(c("one", "two", "three"))
#' }
#' fun()
#' ```
#'
#' ## Adding items one by one
#'
#' ```{asciicast cli-ul-2}
#' fun <- function() {
#'   cli_ul()
#'   cli_li("{.emph one}")
#'   cli_li("{.emph two}")
#'   cli_li("{.emph three}")
#'   cli_end()
#' }
#' fun()
#' ```
#'
#' @param items If not `NULL`, then a character vector. Each element of
#'   the vector will be one list item, and the list container will be
#'   closed by default (see the `.close` argument).
#' @param id Id of the list container. Can be used for closing it with
#'   [cli_end()] or in themes. If `NULL`, then an id is generated and
#'   returned invisibly.
#' @param class Class of the list container. Can be used in themes.
#' @param .close Whether to close the list container if the `items` were
#'   specified. If `FALSE` then new items can be added to the list.
#' @inheritParams cli_div
#' @return The id of the new container element, invisibly.
#'
#' @seealso This function supports [inline markup][inline-markup].
#' @family functions supporting inline markup
#' @export


cli_ul <- function(items = NULL, id = NULL, class = NULL,
                   .close = TRUE, .auto_close = TRUE,
                   .envir = parent.frame()) {
  cli__message(
    "ul",
    list(
      items = lapply(items, glue_cmd, .envir = .envir, .call = sys.call()),
      id = id,
      class = class,
      .close = .close
    ),
    .auto_close = .auto_close, .envir = .envir
  )
}

#' Ordered CLI list
#'
#' An ordered list is a container, see [containers].
#'
#' @details
#'
#' ## Adding all items at once
#'
#' ```{asciicast cli-ol}
#' fun <- function() {
#'   cli_ol(c("one", "two", "three"))
#' }
#' fun()
#' ```
#'
#' ## Adding items one by one
#'
#' ```{asciicast cli-ol-2}
#' ## Adding items one by one
#' fun <- function() {
#'   cli_ol()
#'   cli_li("{.emph one}")
#'   cli_li("{.emph two}")
#'   cli_li("{.emph three}")
#'   cli_end()
#' }
#' fun()
#' ```
#'
#' ## Nested lists
#'
#' ```{asciicast cli-ol-3}
#' fun <- function() {
#'   cli_div(theme = list(ol = list("margin-left" = 2)))
#'   cli_ul()
#'   cli_li("one")
#'   cli_ol(c("foo", "bar", "foobar"))
#'   cli_li("two")
#'   cli_end()
#'   cli_end()
#' }
#' fun()
#' ```
#'
#' @inheritParams cli_ul
#' @return The id of the new container element, invisibly.
#'
#' @seealso This function supports [inline markup][inline-markup].
#' @family functions supporting inline markup
#' @export

cli_ol <- function(items = NULL, id = NULL, class = NULL,
                   .close = TRUE, .auto_close = TRUE,
                   .envir = parent.frame()) {
  cli__message(
    "ol",
    list(
      items = lapply(items, glue_cmd, .envir = .envir, .call = sys.call()),
      id = id,
      class = class,
      .close = .close
    ),
    .auto_close = .auto_close, .envir = .envir
  )
}

#' Definition list
#'
#' A definition list is a container, see [containers].
#'
#' @details
#'
#' ## All items at once
#'
#' ```{asciicast cli-dl}
#' fun <- function() {
#'   cli_dl(c(foo = "one", bar = "two", baz = "three"))
#' }
#' fun()
#' ```
#'
#' ## Items one by one
#'
#' ```{asciicast cli-dl-2}
#' fun <- function() {
#'   cli_dl()
#'   cli_li(c(foo = "{.emph one}"))
#'   cli_li(c(bar = "two"))
#'   cli_li(c(baz = "three"))
#' }
#' fun()
#' ```
#'
#' @param items Named character vector, or `NULL`. If not `NULL`, they
#'   are used as list items.
#' @param labels Item labels. Defaults the names in `items`.
#' @inheritParams cli_ul
#' @return The id of the new container element, invisibly.
#'
#' @seealso This function supports [inline markup][inline-markup].
#' @family functions supporting inline markup
#' @export

cli_dl <- function(items = NULL, labels = names(items), id = NULL,
                   class = NULL, .close = TRUE, .auto_close = TRUE,
                   .envir = parent.frame()) {
  if (!is.null(items) && !is_named(items)) {
    throw(cli_error(
      "{.arg items} must be a named character vector",
      "i" = if (!is_named(items)) "{.arg items} is not named"
    ))
  }

  cli__message(
    "dl",
    list(
      items = lapply(items, glue_cmd, .envir = .envir, .call = sys.call()),
      labels = if (!is.null(labels)) {
                 lapply(labels, glue_cmd, .envir = .envir, .call = sys.call())
               },
      id = id,
      class = class, .close = .close),
    .auto_close = .auto_close, .envir = .envir)
}

#' CLI list item(s)
#'
#' A list item is a container, see [containers].
#'
#' @details
#'
#' ## Nested lists
#'
#' ```{asciicast cli-li}
#' fun <- function() {
#'   ul <- cli_ul()
#'   cli_li("one:")
#'   cli_ol(letters[1:3])
#'   cli_li("two:")
#'   cli_li("three")
#'   cli_end(ul)
#' }
#' fun()
#' ```
#'
#' @param items Character vector of items, or `NULL`.
#' @param labels For definition lists the item labels.
#' @param id Id of the new container. Can be used for closing it with
#'   [cli_end()] or in themes. If `NULL`, then an id is generated and
#'   returned invisibly.
#' @param class Class of the item container. Can be used in themes.
#' @inheritParams cli_div
#' @return The id of the new container element, invisibly.
#'
#' @seealso This function supports [inline markup][inline-markup].
#' @family functions supporting inline markup
#' @export

cli_li <- function(items = NULL, labels = names(items), id = NULL,
                   class = NULL, .auto_close = TRUE,
                   .envir = parent.frame()) {
  cli__message(
    "li",
    list(
      items = lapply(items, glue_cmd, .envir = .envir, .call = sys.call()),
      labels = if (!is.null(labels)) {
                 lapply(labels, glue_cmd, .envir = .envir, .call = sys.call())
               },
      id = id,
      class = class),
    .auto_close = .auto_close, .envir = .envir)
}

#' CLI alerts
#'
#' Alerts are typically short status messages.
#'
#' @details
#'
#' ## Success
#'
#' ```{asciicast alert-success}
#' nbld <- 11
#' tbld <- prettyunits::pretty_sec(5.6)
#' cli_alert_success("Built {.emph {nbld}} status report{?s} in {tbld}.")
#' ```
#'
#' ## Info
#'
#' ```{asciicast alert-info}
#' cfl <- "~/.cache/files/latest.cache"
#' cli_alert_info("Updating cache file {.path {cfl}}.")
#' ```
#'
#' ## Warning
#'
#' ```{asciicast alert-warning}
#' cfl <- "~/.cache/files/latest.cache"
#' cli_alert_warning("Failed to update cache file {.path {cfl}}.")
#' ```
#'
#' ## Danger
#'
#' ```{asciicast alert-danger}
#' cfl <- "~/.config/report.yaml"
#' cli_alert_danger("Cannot validate config file at {.path {cfl}}.")
#' ```
#'
#' ## Text wrapping
#'
#' Alerts are printed without wrapping, unless you set `wrap = TRUE`:
#'
#' ```{asciicast alert-wrap, asciicast_rows = 4}
#' cli_alert_info("Data columns: {.val {names(mtcars)}}.")
#' cli_alert_info("Data columns: {.val {names(mtcars)}}.", wrap = TRUE)
#' ```
#'
#' @param text Text of the alert.
#' @param id Id of the alert element. Can be used in themes.
#' @param class Class of the alert element. Can be used in themes.
#' @param wrap Whether to auto-wrap the text of the alert.
#' @param .envir Environment to evaluate the glue expressions in.
#'
#' @seealso These functions supports [inline markup][inline-markup].
#' @family functions supporting inline markup
#' @export

cli_alert <- function(text, id = NULL, class = NULL, wrap = FALSE,
                      .envir = parent.frame()) {
  cli__message(
    "alert",
    list(
      text = glue_cmd(text, .envir = .envir, .call = sys.call()),
      id = id,
      class = class,
      wrap = wrap
    )
  )
}

#' @rdname cli_alert
#' @export

cli_alert_success <- function(text, id = NULL, class = NULL, wrap = FALSE,
                              .envir = parent.frame()) {
  cli__message(
    "alert_success",
    list(
      text = glue_cmd(text, .envir = .envir, .call = sys.call()),
      id = id,
      class = class,
      wrap = wrap
    )
  )
}

#' @rdname cli_alert
#' @export

cli_alert_danger <- function(text, id = NULL, class = NULL, wrap = FALSE,
                              .envir = parent.frame()) {
  cli__message(
    "alert_danger",
    list(
      text = glue_cmd(text, .envir = .envir, .call = sys.call()),
      id = id,
      class = class,
      wrap = wrap
    )
  )
}

#' @rdname cli_alert
#' @export

cli_alert_warning <- function(text, id = NULL, class = NULL, wrap = FALSE,
                               .envir = parent.frame()) {
  cli__message(
    "alert_warning",
    list(
      text = glue_cmd(text, .envir = .envir, .call = sys.call()),
      id = id,
      class = class,
      wrap = wrap
    )
  )
}

#' @rdname cli_alert
#' @export

cli_alert_info <- function(text, id = NULL, class = NULL, wrap = FALSE,
                            .envir = parent.frame()) {
  cli__message(
    "alert_info",
    list(
      text = glue_cmd(text, .envir = .envir, .call = sys.call()),
      id = id,
      class = class,
      wrap = wrap
    )
  )
}

#' CLI horizontal rule
#'
#' It can be used to separate parts of the output.
#'
#' @details
#'
#' ## Inline styling and interpolation
#'
#' ```{asciicast cli-rule}
#' pkg <- "mypackage"
#' cli_rule(left = "{.pkg {pkg}} results")
#' ```
#'
#' ## Theming
#'
#' The line style of the rule can be changed via the the `line-type`
#' property. Possible values are:
#'
#' * `"single"`: (same as `1`), a single line,
#' * `"double"`: (same as `2`), a double line,
#' * `"bar1"`, `"bar2"`, `"bar3"`, etc., `"bar8"` uses varying height bars.
#'
#' Colors and background colors can similarly changed via a theme.
#'
#' ```{asciicast cli-rule-line-type}
#' d <- cli_div(theme = list(rule = list(
#'   color = "cyan",
#'   "line-type" = "double")))
#' cli_rule("Summary", right = "{.pkg mypackage}")
#' cli_end(d)
#' ```
#'
#' @param .envir Environment to evaluate the glue expressions in.
#' @inheritParams rule
#' @inheritParams cli_div
#'
#' @seealso This function supports [inline markup][inline-markup].
#' @family functions supporting inline markup
#' @export

cli_rule <- function(left = "", center = "", right = "", id = NULL,
                     .envir = parent.frame()) {
  cli__message("rule", list(left = glue_cmd(left, .envir = .envir, .call = sys.call()),
                            center = glue_cmd(center, .envir = .envir, .call = sys.call()),
                            right = glue_cmd(right, .envir = .envir, .call = sys.call()),
                            id = id))
}

#' CLI block quote
#'
#' A section that is quoted from another source. It is typically indented.
#'
#' @details
#'
#' ```{asciicast cli-blockquote}
#' evil <- paste(
#'   "The real problem is that programmers have spent far too much time",
#'   "worrying about efficiency in the wrong places and at the wrong",
#'   "times; premature optimization is the root of all evil (or at least",
#'   "most of it) in programming.")
#' cli_blockquote(evil, citation = "Donald Ervin Knuth")
#' ```
#'
#' @param quote Text of the quotation.
#' @param citation Source of the quotation, typically a link or the name
#'   of a person.
#' @inheritParams cli_div
#'
#' @seealso This function supports [inline markup][inline-markup].
#' @family functions supporting inline markup
#' @export

cli_blockquote <- function(quote, citation = NULL, id = NULL,
                           class = NULL, .envir = parent.frame()) {
  cli__message(
    "blockquote",
    list(
      quote = glue_cmd(quote, .envir = .envir, .call = sys.call()),
      citation = glue_cmd(citation, .envir = .envir, .call = sys.call()),
      id = id,
      class = class
    )
  )
}

#' A block of code
#'
#' A helper function that creates a `div` with class `code` and then calls
#' `cli_verbatim()` to output code lines. The builtin theme formats these
#' containers specially. In particular, it adds syntax highlighting to
#' valid R code.
#'
#' @details
#'
#' ```{asciicast cli-code}
#' myfun <- function() {
#'   message("Just an example function")
#'   graphics::pairs(iris, col = 1:4)
#' }
#' cli_code(format(myfun))
#' ```
#'
#' @param lines Character vector, each line will be a line of code, and
#'   newline characters also create new lines. Note that _no_ glue
#'   substitution is performed on the code.
#' @param ... More character vectors, they are appended to `lines`.
#' @param language Programming language. This is also added as a class,
#'   in addition to `code`.
#' @param .auto_close Passed to `cli_div()` when creating the container of
#'   the code. By default the code container is closed after emitting
#'   `lines` and `...` via `cli_verbatim()`. You can keep that container
#'   open with `.auto_close` and/or `.envir`, and then calling
#'   `cli_verbatim()` to add (more) code. Note that the code will be
#'   formatted and syntax highlighted separately for each `cli_verbatim()`
#'   call.
#' @param .envir Passed to `cli_div()` when creating the container of the
#'   code.
#' @return The id of the container that contains the code.
#'
#' @export

cli_code <- function(lines = NULL, ..., language = "R",
                     .auto_close = TRUE, .envir = environment()) {
  lines <- c(lines, unlist(list(...)))
  id <- cli_div(
    class = paste("code", language),
    .auto_close = .auto_close,
    .envir = .envir
  )
  cli_verbatim(lines)
  invisible(id)
}

cli_recorded <- new.env(parent = emptyenv())

cli__message <- function(type, args, .auto_close = TRUE, .envir = NULL,
                         record = getOption("cli.record")) {

  if ("id" %in% names(args) && is.null(args$id)) args$id <- new_uuid()

  if (.auto_close && !is.null(.envir) && !identical(.envir, .GlobalEnv)) {
    if (type == "status") {
      defer(cli_status_clear(id = args$id, result = args$auto_result),
            envir = .envir, priority = "first")
    } else {
      defer(cli_end(id = args$id), envir = .envir, priority = "first")
    }
  }

  cond <- cli__message_create(type, args)

  if (is.null(record)) {
    cli__message_emit(cond)
  } else {
    cli_recorded[[record]] <- c(cli_recorded[[record]], list(cond))
  }

  invisible(args$id)
}

cli__message_create <- function(type, args) {
  cond <- list(message = paste("cli message", type),
               type = type, args = args, pid = clienv$pid)

  class(cond) <- c(
    getOption("cli.message_class"),
    "cli_message",
    "condition"
  )

  cond
}

cli__message_emit <- function(cond) {
  withRestarts(
  {
    signalCondition(cond)
    cli__default_handler(cond)
  },
  cli_message_handled = function() NULL)
}

cli__default_handler <- function(msg) {
  custom_handler <- getOption("cli.default_handler")

  if (is.function(custom_handler)) {
    custom_handler(msg)
  } else {
    cli_server_default(msg)
  }
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/cliapp-docs.R"

#' @title About inline markup in the semantic cli
#'
#' @description
#' To learn how to use cli’s semantic markup, start with the ‘Building
#' a semantic CLI’ article at <https://cli.r-lib.org>.
#'
#' @section Command substitution:
#'
#' All text emitted by cli supports glue interpolation. Expressions
#' enclosed by braces will be evaluated as R code. See [glue::glue()] for
#' details.
#'
#' In addition to regular glue interpolation, cli can also add classes
#' to parts of the text, and these classes can be used in themes. For
#' example
#'
#' ```{asciicast inline-text}
#' cli_text("This is {.emph important}.")
#' ```
#'
#' adds a class to the "important" word, class `"emph"`. Note that in this
#' case the string within the braces is usually not a valid R expression.
#' If you want to mix classes with interpolation, add another pair of
#' braces:
#'
#' ```{asciicast inline-text-2}
#' adjective <- "great"
#' cli_text("This is {.emph {adjective}}.")
#' ```
#'
#' An inline class will always create a `span` element internally. So in
#' themes, you can use the `span.emph` CSS selector to change how inline
#' text is emphasized:
#'
#' ```{asciicast inline-text-3}
#' cli_div(theme = list(span.emph = list(color = "red")))
#' adjective <- "nice and red"
#' cli_text("This is {.emph {adjective}}.")
#' ```
#'
#' @section Classes:
#'
#' The default theme defines the following inline classes:
#' * `arg` for a function argument.
#' * `cls` for an S3, S4, R6 or other class name.
#' * `code` for a piece of code.
#' * `dt` is used for the terms in a definition list ([cli_dl()]).
#' * `dd` is used for the descriptions in a definition list ([cli_dl()]).
#' * `email` for an email address.
#'   If the terminal supports ANSI hyperlinks (e.g. RStudio, iTerm2, etc.),
#'   then cli creates a clickable link.
#'   See [links] for more information about cli hyperlinks.
#' * `emph` for emphasized text.
#' * `envvar` for the name of an environment variable.
#' * `field` for a generic field, e.g. in a named list.
#' * `file` for a file name. If the terminal supports ANSI hyperlinks (e.g.
#'   RStudio, iTerm2, etc.), then cli creates a clickable link that opens
#'   the file in RStudio or with the default app for the file type.
#'   See [links] for more information about cli hyperlinks.
#' * `fn` for a function name. If it is in the `package::function_name`
#'   form, and the terminal supports ANSI hyperlinks (e.g. RStudio,
#'   iTerm2, etc.), then cli creates a clickable link.
#'   See [links] for more information about cli hyperlinks.
#' * `fun` same as `fn`.
#' * `help` is a help page of a _function_.
#'   If the terminal supports ANSI hyperlinks to help pages (e.g. RStudio),
#'   then cli creates a clickable link. It supports link text.
#'   See [links] for more information about cli hyperlinks.
#' * `href` creates a hyperlink, potentially with a link text.
#'   If the terminal supports ANSI hyperlinks (e.g. RStudio, iTerm2, etc.),
#'   then cli creates a clickable link.
#'   See [links] for more information about cli hyperlinks.
#' * `kbd` for a keyboard key.
#' * `key` same as `kbd`.
#' * `obj_type_friendly` formats the type of an R object in a readable way,
#'   and it should be used with `{}`, see an example below.
#' * `or` changes the string that separates the last two elements of
#'   collapsed vectors (see below) from "and" to "or".
#' * `path` for a path (the same as `file` in the default theme).
#' * `pkg` for a package name.
#' * `run` is an R expression, that is potentially clickable if the terminal
#'   supports ANSI hyperlinks to runnable code (e.g. RStudio).
#'   It supports link text. See [links] for more information about cli hyperlinks.
#' * `str` for a double quoted string escaped by [base::encodeString()].
#' * `strong` for strong importance.
#' * `topic` is a help page of a _topic_.
#'   If the terminal supports ANSI hyperlinks to help pages (e.g. RStudio),
#'   then cli creates a clickable link. It supports link text.
#'   See [links] for more information about cli hyperlinks.
#' * `type` formats the type of an R object in a readable way, and it
#'   should be used with `{}`, see an example below.
#' * `url` for a URL. If the terminal supports ANSI hyperlinks (e.g.
#'   RStudio, iTerm2, etc.), then cli creates a clickable link.
#'   See [links] for more information about cli hyperlinks.
#' * `var` for a variable name.
#' * `val` for a generic "value".
#' * `vignette` is a vignette.
#'   If the terminal supports ANSI hyperlinks to help pages (e.g. RStudio),
#'   then cli creates a clickable link. It supports link text.
#'   See [links] for more information about cli hyperlinks.
#'
#' ```{asciicast inline-examples}
#' ul <- cli_ul()
#' cli_li("{.emph Emphasized} text.")
#' cli_li("{.strong Strong} importance.")
#' cli_li("A piece of code: {.code sum(a) / length(a)}.")
#' cli_li("A package name: {.pkg cli}.")
#' cli_li("A function name: {.fn cli_text}.")
#' cli_li("A keyboard key: press {.kbd ENTER}.")
#' cli_li("A file name: {.file /usr/bin/env}.")
#' cli_li("An email address: {.email bugs.bunny@acme.com}.")
#' cli_li("A URL: {.url https://example.com}.")
#' cli_li("An environment variable: {.envvar R_LIBS}.")
#' cli_li("`mtcars` is {.obj_type_friendly {mtcars}}")
#' cli_end(ul)
#' ```
#'
#' You can add new classes by defining them in the theme, and then using
#' them.
#'
#' ```{asciicast inline-newclass}
#' cli_div(theme = list(
#'   span.myclass = list(color = "lightgrey"),
#'   "span.myclass" = list(before = "<<"),
#'   "span.myclass" = list(after = ">>")))
#' cli_text("This is {.myclass in angle brackets}.")
#' cli_end()
#' ```
#'
#' ## Highlighting weird-looking values
#'
#' Often it is useful to highlight a weird file or path name, e.g. one
#' that starts or ends with space characters. The built-in theme does this
#' for `.file`, `.path` and `.email` by default. You can highlight
#' any string inline by adding the `.q` class to it.
#'
#' The current highlighting algorithm
#' * adds single quotes to the string if it does not start or end with an
#'   alphanumeric character, underscore, dot or forward slash.
#' * Highlights the background colors of leading and trailing spaces on
#'   terminals that support ANSI colors.
#'
#' @section Collapsing inline vectors:
#'
#' When cli performs inline text formatting, it automatically collapses
#' glue substitutions, after formatting. This is handy to create lists of
#' files, packages, etc.
#'
#' ```{asciicast inline-collapse}
#' pkgs <- c("pkg1", "pkg2", "pkg3")
#' cli_text("Packages: {pkgs}.")
#' cli_text("Packages: {.pkg {pkgs}}.")
#' ```
#'
#' Class names are collapsed differently by default
#'
#' ```{asciicast inline-collapse-2}
#' x <- Sys.time()
#' cli_text("Hey, {.var x} has class {.cls {class(x)}}.")
#' ```
#'
#' By default cli truncates long vectors. The truncation limit is by default
#' twenty elements, but you can change it with the `vec-trunc` style.
#'
#' ```{asciicast inline-collapse-trunc}
#' nms <- cli_vec(names(mtcars), list("vec-trunc" = 5))
#' cli_text("Column names: {nms}.")
#' ```
#'
#' @section Formatting values:
#'
#' The `val` inline class formats values. By default (c.f. the built-in
#' theme), it calls the [cli_format()] generic function, with the current
#' style as the argument. See [cli_format()] for examples.
#'
#' `str` is for formatting strings, it uses [base::encodeString()] with
#' double quotes.
#'
#' @section Escaping `{` and `}`:
#'
#' It might happen that you want to pass a string to `cli_*` functions,
#' and you do _not_ want command substitution in that string, because it
#' might contain `{` and `}` characters. The simplest solution for this is
#' to refer to the string from a template:
#'
#' ```{asciicast inline-escape}
#' msg <- "Error in if (ncol(dat$y)) {: argument is of length zero"
#' cli_alert_warning("{msg}")
#' ```
#'
#' If you want to explicitly escape `{` and `}` characters, just double
#' them:
#'
#' ```{asciicast inline-escape-2}
#' cli_alert_warning("A warning with {{ braces }}.")
#' ```
#'
#' See also examples below.
#'
#' @section Pluralization:
#'
#' All cli commands that emit text support pluralization. Some examples:
#'
#' ```{asciicast inline-plural}
#' ndirs <- 1
#' nfiles <- 13
#' pkgs <- c("pkg1", "pkg2", "pkg3")
#' cli_alert_info("Found {ndirs} director{?y/ies} and {nfiles} file{?s}.")
#' cli_text("Will install {length(pkgs)} package{?s}: {.pkg {pkgs}}")
#' ```
#'
#' See [pluralization] for details.
#'
#' @section Wrapping:
#'
#' Most cli containers wrap the text to width the container's width,
#' while observing margins requested by the theme.
#'
#' To avoid a line break, you can use the UTF_8 non-breaking space
#' character: `\u00a0`. cli will not break a line here.
#'
#' To force a line break, insert a form feed character: `\f` or
#' `\u000c`. cli will insert a line break there.
#'
#' @name inline-markup
NULL

#' About cli containers
#'
#' Container elements may contain other elements. Currently the following
#' commands create container elements: [cli_div()], [cli_par()], the list
#' elements: [cli_ul()], [cli_ol()], [cli_dl()], and list items are
#' containers as well: [cli_li()].
#'
#' ## Themes
#'
#' A container can add a new theme, which is removed when the container
#' exits.
#'
#' ```{asciicast cnt-theme}
#' d <- cli_div(theme = list(h1 = list(color = "blue",
#'                                     "font-weight" = "bold")))
#' cli_h1("Custom title")
#' cli_end(d)
#' ```
#'
#' ## Auto-closing
#'
#' Container elements are closed with [cli_end()]. For convenience,
#' by default they are closed automatically when the function that created
#' them terminated (either regularly or with an error). The default
#' behavior can be changed with the `.auto_close` argument.
#'
#' ```{asciicast cnt-auto-close}
#' div <- function() {
#'   cli_div(class = "tmp", theme = list(.tmp = list(color = "yellow")))
#'   cli_text("This is yellow")
#' }
#' div()
#' cli_text("This is not yellow any more")
#' ```
#'
#' ## Debugging
#'
#' You can use the internal `cli:::cli_debug_doc()` function to see the
#' currently open containers.
#'
#' ```{asciicast cnt-debug, echo = -1}
#' stop_app()
#' fun <- function() {
#'   cli_div(id = "mydiv")
#'   cli_par(class = "myclass")
#'   cli:::cli_debug_doc()
#' }
#' fun()
#' ```
#'
#' @name containers
NULL

#' About cli themes
#'
#' CLI elements can be styled via a CSS-like language of selectors and
#' properties. Only a small subset of CSS3 is supported, and
#' a lot visual properties cannot be implemented on a terminal, so these
#' will be ignored as well.
#'
#' @section Adding themes:
#' The style of an element is calculated from themes from four sources.
#' These form a stack, and the themes on the top of the stack take
#' precedence, over themes in the bottom.
#'
#' 1. The cli package has a built-in theme. This is always active.
#'    See [builtin_theme()].
#' 2. When an app object is created via [start_app()], the caller can
#'    specify a theme, that is added to theme stack. If no theme is
#'    specified for [start_app()], the content of the `cli.theme` option
#'    is used. Removed when the corresponding app stops.
#' 3. The user may specify a theme in the `cli.user_theme` option. This
#'    is added to the stack _after_ the app's theme (step 2.), so it can
#'    override its settings. Removed when the app that added it stops.
#' 4. Themes specified explicitly in [cli_div()] elements. These are
#'    removed from the theme stack, when the corresponding [cli_div()]
#'    elements are closed.
#'
#' @section Writing themes:
#' A theme is a named list of lists. The name of each entry is a CSS
#' selector. Only a subset of CSS is supported:
#' * Type selectors, e.g. `input` selects all `<input>` elements.
#' * Class selectors, e.g. `.index` selects any element that has a class
#'   of "index".
#' * ID selector. `#toc` will match the element that has the ID "toc".
#' * The descendant combinator, i.e. the space, that selects nodes
#'   that are descendants of the first element. E.g. `div span` will match
#'   all `<span>` elements that are inside a `<div>` element.
#'
#' The content of a theme list entry is another named list, where the
#' names are CSS properties, e.g. `color`, or `font-weight` or
#' `margin-left`, and the list entries themselves define the values of
#' the properties. See [builtin_theme()] and [simple_theme()] for examples.
#'
#' @section Formatter callbacks:
#' For flexibility, themes may also define formatter functions, with
#' property name `fmt`. These will be called once the other styles are
#' applied to an element. They are only called on elements that produce
#' output, i.e. _not_ on container elements.
#'
#' @section Supported properties:
#' Right now only a limited set of properties are supported. These include
#' left, right, top and bottom margins, background and foreground colors,
#' bold and italic fonts, underlined text. The `before` and `after`
#' properties are supported to insert text before and after the
#' content of the element.
#'
#' The current list of properties:
#'
#' * `after`: A string literal to insert after the element. It can also be
#'   a function that returns a string literal. Supported by all inline
#'   elements, list items, alerts and rules.
#' * `background-color`: An R color name, or HTML hexadecimal color.
#'   It can be applied to most elements (inline elements, rules, text,
#'   etc.), but the background of containers is not colored properly
#'   currently.
#' * `before`: A string literal to insert before the element. It can also be
#'   a function that returns a string literal. Supported by all inline
#'   elements, list items, alerts and rules.
#' * `class-map`: Its value can be a named list, and it specifies how
#'   R (S3) class names are mapped to cli class names. E.g.
#'   `list(fs_path = "file")` specifies that `fs_path` objects (from the fs
#'   package) should always print as `.file` objects in cli.
#' * `color`: Text color, an R color name or a HTML hexadecimal color. It
#'   can be applied to most elements that are printed.
#' * `collapse`: Specifies how to collapse a vector, before applying
#'   styling. If a character string, then that is used as the separator.
#'   If a function, then it is called, with the vector as the only
#'   argument.
#' * `digits`: Number of digits after the decimal point for numeric inline
#'   element of class `.val`.
#' * `fmt`: Generic formatter function that takes an input text and returns
#'   formatted text. Can be applied to most elements. If colors are in use,
#'   the input text provided to `fmt` already includes ANSI sequences.
#' * `font-style`: If `"italic"` then the text is printed as cursive.
#' * `font-weight`: If `"bold"`, then the text is printed in boldface.
#' * `line-type`: Line type for [cli_rule()].
#' * `list-style-type`: String literal or functions that returns a string
#'   literal, to be used as a list item marker in un-ordered lists.
#' * `margin-bottom`, `margin-left`, `margin-right`, `margin-top`: Margins.
#' * `padding-left`, `padding-right`: This is currently used the same way
#'   as the margins, but this might change later.
#' * `start`: Integer number, the first element in an ordered list.
#' * `string-quote`: Quoting character for inline elements of class `.val`.
#' * `text-decoration`: If `"underline"`, then underlined text is created.
#' * `text-exdent`: Amount of indentation from the second line of wrapped
#'    text.
#' * `transform`: A function to call on glue substitutions, before
#'   collapsing them. Note that `transform` is applied prior to
#'   implementing color via ANSI sequences.
#' * `vec-last`: The last separator when collapsing vectors.
#' * `vec-sep`: The separator to use when collapsing vectors.
#' * `vec-sep2`: The separator to use for two elements when collapsing
#'   vectors. If not set, then `vec-sep` is used for these as well.
#' * `vec-trunc`: Vectors longer than this will be truncated. Defaults to
#'   100.
#' * `vec-trunc-style`: Select between two ways of collapsing vectors:
#'   - `"both-ends"` is the current default and it shows the beginning and
#'     the end of the vector.
#'   - `"head"` only shows the beginning of the vector.
#'
#' More properties might be added later. If you think that a property is
#' not applied properly to an element, please open an issue about it in
#' the cli issue tracker.
#'
#' @section Examples:
#' Color of headings, that are only active in paragraphs with an
#' 'output' class:
#' ```
#' list(
#'   "par.output h1" = list("background-color" = "red", color = "#e0e0e0"),
#'   "par.output h2" = list("background-color" = "orange", color = "#e0e0e0"),
#'   "par.output h3" = list("background-color" = "blue", color = "#e0e0e0")
#' )
#' ```
#'
#' Create a custom alert type:
#' ```
#' list(
#'   ".alert-start" = list(before = symbol$play),
#'   ".alert-stop"  = list(before = symbol$stop)
#' )
#' ```
#' @name themes

# TODO: examples

NULL

#' cli hyperlinks
#'
#' @description
#' Certain cli styles create clickable links, if your IDE or terminal
#' supports them.
#'
#' # Note: hyperlinks are currently experimental
#'
#' The details of the styles that create hyperlinks will prrobably change
#' in the near future, based on user feedback.
#'
#' # About the links in this manual page
#'
#' The hyperlinks that are included in this manual are demonstrative
#' only, except for the `https:` links. They look like a hyperlink, and
#' you can click on them, but they do nothing. I.e. a `.run` link will
#' not run the linked expression if you click on it.
#'
#' # Hyperlink Support
#'
#' As of today, the latest release of RStudio (version v2022.07.0+548)
#' supports all hyperlink types discussed here. Certain terminals, e.g.
#' iTerm on macOS, Linux terminals based on VTE (GNOME terminal) support
#' `.href`, `.email` and `.file` links.
#'
#' You can use [ansi_has_hyperlink_support()] to check if your terminal or
#' IDE has hyperlink support in general, and [ansi_hyperlink_types()] to
#' check if various types of hyperlinks are supported.
#'
#' If your hyperlink support is not detected properly in your IDE or
#' terminal, please open a cli issue at
#' <https://github.com/r-lib/cli/issues>.
#'
#' ```{asciicast links-setup, include = FALSE, cache = FALSE}
#' options(
#'   cli.hyperlink = TRUE,
#'   cli.hyperlink_run = TRUE,
#'   cli.hyperlink_help = TRUE,
#'   cli.hyperlink_vignette = TRUE
#' )
#' ```
#'
#' # Link text
#'
#' Before we delve into the various types of hyperlinks, a general comment
#' about link texts. Some link styles support a custom link text:
#'
#' * `.href`
#' * `.help`
#' * `.topic`
#' * `.vignette`
#' * `.run`
#'
#' Others, i.e. `.email`, `.file`, `.fun` and `.url` do not support custom
#' link text.
#'
#' The generic syntax for link text is the same as for Markdown hyperlinks:
#' ```
#' {.style [link text](url)}
#' ```
#'
#' ## Vectorization
#'
#' Note that it is not possible to add link text to a vector of URLs. E.g.
#' this will create a list of three URLs, all clickable:
#'
#' ```{asciicast link-example}
#' urls <- paste0("https://httpbin.org/status/", c(200, 403, 404))
#' cli::cli_text("Some httpbin URLs: {.url {urls}}.")
#' ```
#' But it is not possible to use a different link text for them.
#'
#' ## What if hyperlinks are not available?
#'
#' If ANSI hyperlinks are not available, then the link text for of these
#' styles outputs both the link text and the URL in a (hopefully) helpful
#' way. See examples below.
#'
#' # URLs
#'
#' There are two cli styles to link to generic URLs. `.url` does not
#' allow custom link text, but `\href` does.
#'
#' ```{asciicast links-url-1}
#' cli_text(
#'   "See the cli homepage at {.url https://cli.r-lib.org} for details."
#' )
#' ```
#'
#'```{asciicast links-url-2}
#' cli_text(
#'   "See the {.href [cli homepage](https://cli.r-lib.org)} for details."
#' )
#' ```
#'
#' ## Without hyperlink support
#'
#' This is how these links look without hyperlink support:
#'
#' ```{asciicast links-url-3}
#' local({
#'   withr::local_options(cli.hyperlink = FALSE)
#'   cli_text(
#'     "See the cli homepage at {.url https://cli.r-lib.org} for details."
#'   )
#'   cli_text(
#'     "See the {.href [cli homepage](https://cli.r-lib.org)} for details."
#'   )
#' })
#' ```
#'
#' ## URL encoding
#'
#' Note that cli does not encode the url, so you might need to call
#' `utils::URLencode()` on it, especially, if it is substituted in
#' via `{}`.
#'
#' ```{asciicast links-url-4}
#' weirdurl <- utils::URLencode("https://example.com/has some spaces")
#' cli_text("See more at {.url {weirdurl}}.")
#' ```
#'
#' # Files
#'
#' The `.file` style now automatically creates a `file:` hyperlink.
#' Because `file:` hyperlinks must contain an absolute path, cli tries to
#' convert relative paths, and paths starting with `~` to aboslute path.
#'
#' ```{asciicast links-file-1}
#' cli_text("... edit your {.file ~/.Rprofile} file.")
#' ```
#'
#' ## Link text
#'
#' `.file` cannot use a custom link text. If you custom link text, then
#' you can use `.href` with a `file:` URL.
#'
#' ```{asciicast links-file-2}
#' prof <- path.expand("~/.Rprofile")
#' cli_text("... edit your {.href [R profile](file://{prof})}.")
#' ```
#'
#' ## Line and column numbers
#'
#' You may add a line number to a file name, separated by `:`. Handlers
#' typically place the cursor at that line after opening the file.
#' You may also add a column number, after the line number, separated by
#' another `:`.
#'
#' ```{asciicast links-file-3}
#' cli_text("... see line 5 in {.file ~/.Rprofile:5}.")
#' ```
#'
#' ## Default handler
#'
#' In RStudio `file:` URLs open within RStudio. If you click on a file
#' link outside of RStudio, typically the operating system is consulted
#' for the application to open it.
#'
#' ## Without hyperlink support
#'
#' One issue with using `.href` file files is that it does not look great
#' if hyperlinks are not available. This will be improved in the future:
#'
#' ```{asciicast links-file-4}
#' local({
#'   withr::local_options(cli.hyperlink = FALSE)
#'   prof <- path.expand("~/.Rprofile")
#'   cli_text("... edit your {.href [R profile](file://{prof})}.")
#' })
#' ```
#'
#' # Links to the manual
#'
#' `.fun` automatically creates links to the manual page of the function,
#' provided the function name is in the `packagename::functionname` form:
#'
#' ```{asciicast links-fun-1}
#' cli::cli_text("... see {.fun stats::lm} to learn more.")
#' ```
#'
#' ## Link text
#'
#' For a custom link text, use `.help` instead of `.fun`.
#'
#' ```{asciicast links-fun-2}
#' cli::cli_text("... see {.help [{.fun lm}](stats::lm)} to learn more.")
#' ```
#'
#' ## Without hyperlink support
#'
#' The same message without hyperlink support looks like this:
#'
#' ```{asciicast links-fun-3}
#' local({
#'   withr::local_options(cli.hyperlink = FALSE)
#'   cli::cli_text("... see {.help [{.fun lm}](stats::lm)} to learn more.")
#' })
#' ```
#'
#' ## Topics
#'
#' To link to a help topic that is not a function, use `.topic`:
#'
#' ```{asciicast links-topic}
#' cli::cli_text("... the tibble options at {.topic tibble::tibble_options}.")
#' ```
#'
#' `.topic` support link text.
#'
#' ## Vignettes
#'
#' To link to a vignette, use `.vignette`:
#'
#' ```{asciicast links-vignette}
#' cli::cli_text("... see the {.vignette tibble::types} vignette.")
#' ```
#'
#' # Click to run code
#'
#' RStudio also supports a special link type that runs R code in the
#' current R session upon clicking.
#'
#' You can create these links with `.run`:
#'
#' ```{asciicast links-run}
#' cli::cli_text("Run {.run testthat::snapshot_review()} to review")
#' ```
#'
#' ## Link text
#'
#' Sometimes you want to show a slightly different expression in the link,
#' than the one that is evaluated. E.g. the evaluated expression probably
#' needs to qualify packages with `::`, but you might not want to show this:
#'
#' ```{asciicast links-run-2}
#' cli::cli_text(
#'   "Run {.run [snapshot_review()](testthat::snapshot_review())} to review"
#' )
#' ```
#'
#' ## Security considerations
#'
#' To make `.run` hyperlinks more secure, RStudio will not run code
#'
#' * that is not in the `pkg::fun(args)` form,
#' * if `args` contains `(`, `)` or `;`,
#' * if it calls a core package (base, stats, etc.),
#' * if it calls a package that is not loaded, and it is not one of
#'   testthat, devtools, usethis, rlang, pkgload, or pkgdown which are explicitly allowed.
#'
#' When RStudio does not run a `.run` hyperlink, then it shows the code
#' and the user can copy and paste it to the console, if they consider
#' it safe to run.
#'
#' Note that depending on your version of RStudio, the behavior can change.
#' @name links
NULL
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/cliapp.R"

cliapp <- function(theme = getOption("cli.theme"),
                   user_theme = getOption("cli.user_theme"),
                   output = c("auto", "message", "stdout", "stderr")) {

  app <- new_class(
    "cliapp",

    new = function(theme, user_theme, output)
      clii_init(app, theme, user_theme, output),

    ## Meta
    meta = function(...) {
      txt <- cli__fmt(list(...), collapse = TRUE, app = app)
      clii__message(txt, appendLF = FALSE, output = app$output, signal = app$signal)
    },

    ## Themes
    list_themes = function()
      clii_list_themes(app),
    add_theme = function(theme)
      clii_add_theme(app, theme),
    remove_theme = function(id)
      clii_remove_theme(app, id),

    ## Close container(s)
    end = function(id = NULL)
      clii_end(app, id),

    ## Generic container
    div = function(id = NULL, class = NULL, theme = NULL)
      clii_div(app, id, class, theme),

    ## Paragraphs
    par = function(id = NULL, class = NULL)
      clii_par(app, id, class),

    ## Text, wrapped
    text = function(text)
      clii_text(app, text),

    ## Text, not wrapped
    inline_text = function(text)
      clii_inline_text(app, text),

    ## Text, not wrapped, verbatim
    verbatim = function(...)
      clii_verbatim(app, ...),

    ## Markdow(ish) text, wrapped: emphasis, strong emphasis, links, code
    md_text = function(...)
      clii_md_text(app, ...),

    ## Headings
    h1 = function(text, id = NULL, class = NULL)
      clii_h1(app, text, id, class),
    h2 = function(text, id = NULL, class = NULL)
      clii_h2(app, text, id, class),
    h3 = function(text, id = NULL, class = NULL)
      clii_h3(app, text, id, class),

    ## Block quote
    blockquote = function(quote, citation = NULL, id, class = NULL)
      clii_blockquote(app, quote, citation, id, class),

    ## Lists
    ul = function(items = NULL, id = NULL, class = NULL, .close = TRUE)
      clii_ul(app, items, id, class, .close),
    ol = function(items = NULL, id = NULL, class = NULL, .close = TRUE)
      clii_ol(app, items, id, class, .close),
    dl = function(items = NULL, labels = NULL, id = NULL, class = NULL, .close = TRUE)
      clii_dl(app, items, labels, id, class, .close),
    li = function(items = NULL, labels = NULL, id = NULL, class = NULL)
      clii_li(app, items, labels, id, class),

    ## Tables
    table = function(cells, id = NULL, class = NULL)
      clii_table(app, cells, class),

    ## Alerts
    alert = function(text, id = NULL, class = NULL, wrap = FALSE)
      clii_alert(app, "alert", text, id, class, wrap),
    alert_success = function(text, id = NULL, class = NULL, wrap = FALSE)
      clii_alert(app, "alert-success", text, id, class, wrap),
    alert_danger = function(text, id = NULL, class = NULL, wrap = FALSE)
      clii_alert(app, "alert-danger", text, id, class, wrap),
    alert_warning = function(text, id = NULL, class = NULL, wrap = FALSE)
      clii_alert(app, "alert-warning", text, id, class, wrap),
    alert_info = function(text, id = NULL, class = NULL, wrap = FALSE)
      clii_alert(app, "alert-info", text, id, class, wrap),

    ## Bullets
    bullets = function(text, id = NULL, class = NULL)
      clii_bullets(app, text, id, class),

    ## Horizontal rule
    rule = function(left, center, right, id = NULL)
      clii_rule(app, left, center, right, id),

    ## Status bar
    status = function(id = NULL, msg, msg_done = NULL, msg_failed = NULL,
                      keep = FALSE, auto_result = "clear", globalenv = FALSE)
      clii_status(app, id, msg, msg_done, msg_failed, keep, auto_result, globalenv),
    status_clear = function(id = NULL, result, msg_done = NULL, msg_failed = NULL)
      clii_status_clear(app, id, result, msg_done, msg_failed),
    status_update = function(id = NULL, msg, msg_done = NULL, msg_failed = NULL)
      clii_status_update(app, id, msg, msg_done, msg_failed),

    doc = NULL,
    themes = NULL,
    styles = NULL,
    delayed_item = NULL,
    status_bar = list(),

    margin = 0,
    output = NULL,

    get_current_style = function()
      utils::tail(app$styles, 1)[[1]],

    xtext = function(text = NULL, .list = NULL, indent = 0, padding = 0, wrap = TRUE)
      clii__xtext(app, text, .list = .list, indent = indent,
                  padding = padding, wrap = wrap),

    vspace = function(n = 1)
      clii__vspace(app, n),

    inline = function(text = NULL, .list = NULL)
      clii__inline(app, text, .list = .list),

    item_text = function(type, name, cnt_id, items = list(), .list = NULL)
      clii__item_text(app, type, name, cnt_id, items, .list = .list),

    get_width = function(extra = 0)
      clii__get_width(app, extra),
    cat = function(lines)
      clii__cat(app, lines),
    cat_ln = function(lines, indent = 0, padding = 0)
      clii__cat_ln(app, lines, indent, padding)
  )

  if (! inherits(output, "connection")) output <- match.arg(output)
  app$new(theme, user_theme, output)

  app
}

clii_init <- function(app, theme, user_theme, output) {
  app$doc <- list()
  app$output <- output
  app$styles <- NULL

  if (Sys.getenv("CLI_NO_BUILTIN_THEME", "") != "true") {
    app$add_theme(builtin_theme())
  }
  app$add_theme(theme)
  app$add_theme(user_theme)

  clii__container_start(app, "body", id = "body")

  invisible(app)
}

## Text -------------------------------------------------------------

clii_text <- function(app, text) {
  app$xtext(text)
}

clii_inline_text <- function(app, text) {
  app$xtext(text, wrap = FALSE)
}

clii_verbatim <- function(app, ..., .envir) {
  style <- app$get_current_style()
  text <- unlist(strsplit(unlist(list(...)), "\n", fixed = TRUE))
  if (!is.null(style$fmt)) text <- style$fmt(text)
  app$cat_ln(text)
  invisible(app)
}

clii_md_text <- function(app, ...) {
  throw(cli_error("Markdown text is not implemented yet"))
}

## Headings ----------------------------------------------------------

clii_h1 <- function(app, text, id, class) {
  clii__heading(app, "h1", text, id, class)
}

clii_h2 <- function(app, text, id, class) {
  clii__heading(app, "h2", text, id, class)
}

clii_h3 <- function(app, text, id, class) {
  clii__heading(app, "h3", text, id, class)
}

clii__heading <- function(app, type, text, id, class) {
  id <- new_uuid()
  clii__container_start(app, type, id = id, class = class)
  on.exit(clii__container_end(app, id), add = TRUE)
  text <- app$inline(text)
  style <- app$get_current_style()
  if (is.function(style$fmt)) text <- style$fmt(text)
  app$cat_ln(text)
  invisible(app)
}

## Block quote ------------------------------------------------------

clii_blockquote <- function(app, quote, citation, id, class) {
  c1 <- clii__container_start(app, "blockquote", id = id, class = class)
  on.exit(clii__container_end(app, id), add = TRUE)
  app$xtext(quote)

  c2 <- clii__container_start(app, "cite", id = new_uuid())
  app$xtext(citation)
}

## Table ------------------------------------------------------------

clii_table <- function(app, cells, id, class) {
  throw(cli_error("Tables are not implemented yet"))
}

## Rule -------------------------------------------------------------

clii_rule <- function(app, left, center, right, id) {
  left <- app$inline(left)
  center <- app$inline(center)
  right <- app$inline(right)
  clii__container_start(app, "rule", id = id)
  on.exit(clii__container_end(app, id), add = TRUE)
  style <- app$get_current_style()
  before <- call_if_fun(style$before) %||% ""
  after <- call_if_fun(style$after) %||% ""
  width <- console_width() - ansi_nchar(before) - ansi_nchar(after)
  text <- rule(left, center, right, line = style$`line-type` %||% 1)
  text[1] <- paste0(before, text[1])
  text[length(text)] <- paste0(text[length(text)], after)
  if (is.function(style$fmt)) text <- style$fmt(text)
  app$cat_ln(text)
}

## Alerts -----------------------------------------------------------

clii_alert <- function(app, type, text, id, class, wrap) {
  clii__container_start(app, "div", id = id,
                       class = paste(class, "alert", type))
  on.exit(clii__container_end(app, id), add = TRUE)
  if (wrap) {
    app$xtext(text)
  } else {
    text <- app$inline(text)
    style <- app$get_current_style()
    before <- call_if_fun(style$before) %||% ""
    after <- call_if_fun(style$after) %||% ""
    before <- gsub(" ", "\u00a0", before, fixed = TRUE)
    after <- gsub(" ", "\u00a0", after, fixed = TRUE)
    text[1] <- paste0(before, text[1])
    text[length(text)] <- paste0(text[length(text)], after)
    if (is.function(style$fmt)) text <- style$fmt(text)
    app$cat_ln(text)
  }
}

## Bullets -------------------------------------------------------------

clii_bullets <- function(app, text, id, class) {
  clii__container_start(app, "div", id = id, class = paste("memo bullets", class))
  on.exit(clii__container_end(app, id), add = TRUE)

  # Normalize names a bit, so we can use them as class names
  nms <- as.character(names(text))
  length(nms) <- length(text)
  nms[is.na(nms) | nms == ""] <- "empty"
  nms[nms == " "] <- "space"
  nms <- gsub(" ", "-", nms, fixed = TRUE)
  # cls is vectorized here (!)
  cls <- paste0("bullet memo-item bullet-", nms, " memo-item=", nms)

  lapply(seq_along(text), function(i) {
    iid <- new_uuid()
    clii__container_start(app, "div", id = iid, class = cls[i])
    on.exit(clii__container_end(app, iid), add = TRUE)
    app$text(text[[i]])
  })

  invisible()
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/containers.R"

add_child <- function(x, tag, ...) {
  push(x, list(tag = tag, ...))
}

clii__container_start <- function(app, tag, class = NULL,
                                  id = NULL, theme = NULL) {

  id <- id %||% new_uuid()
  if (!length(class)) class <- ""
  class <- setdiff(unique(strsplit(class, " ", fixed = TRUE)[[1]]), "")

  app$doc <- add_child(app$doc, tag, id = id, class = class,
                           theme = theme)

  ## Go over all themes, and collect the selectors that match the
  ## current element
  new_sels <- list()
  for (t in seq_along(app$themes)) {
    theme <- app$themes[[t]]
    for (i in seq_len(nrow(theme))) {
      if (match_selector(theme$parsed[[i]], app$doc)) {
        app$themes[[t]]$cnt[i] <- id
        new_sels <- utils::modifyList(new_sels, theme$style[[i]])
      }
    }
  }
  new_style <- merge_embedded_styles(last(app$styles) %||% list(), new_sels)
  app$styles <- push(app$styles, new_style, name = id)

  ## Top margin, if any
  app$vspace(new_style$`margin-top` %||% 0)

  invisible(id)
}

clii__container_end <- function(app, id) {
  debug <- is_yes(Sys.getenv("CLI_DEBUG_BAD_END", ""))

  ## Defaults to last container
  if (is.null(id) || is.na(id)) id <- last(app$doc)$id

  ## Do not remove the <body>
  if (id == "body") {
    if (debug) warning("No cli container to close")
    return(invisible(app))
  }

  ## Do we have 'id' at all?
  wh <- which(vlapply(app$doc, function(x) identical(x$id, id)))[1]
  if (is.na(wh)) {
    if (debug) warning("Can't find cli container '", id, "' to close")
    return(invisible(app))
  }

  ## ids to remove
  del_ids <- unlist(lapply(utils::tail(app$doc, - (wh - 1L)), "[[", "id"))

  ## themes to remove
  del_thm <- unlist(lapply(utils::tail(app$doc, - (wh - 1L)), "[[", "theme"))

  ## Remove the whole subtree of 'cnt'
  app$doc <- utils::head(app$doc, wh - 1L)

  ## Bottom margin
  del_from <- match(id, names(app$styles))
  bottom <- max(viapply(
    app$styles[del_from:length(app$styles)],
    function(x) as.integer(x$`margin-bottom` %||% 0L)
  ))
  app$vspace(bottom)

  ## Remove styles
  app$styles <- utils::head(app$styles, del_from - 1L)

  ## Remove claimed styles that are not used any more
  for (t in seq_along(app$themes)) {
    m <- app$themes[[t]]$cnt %in% del_ids
    app$themes[[t]]$cnt[m] <- NA_character_
  }

  ## Remove themes
  app$themes <- app$themes[setdiff(names(app$themes), del_thm)]

  invisible(app)
}

## div --------------------------------------------------------------

clii_div <- function(app, id, class, theme) {
  theme_id <- app$add_theme(theme)
  clii__container_start(app, "div", class, id, theme = theme_id)
  id
}

## Paragraph --------------------------------------------------------

clii_par <- function(app, id, class) {
  clii__container_start(app, "par", class, id)
}

## Lists ------------------------------------------------------------

clii_ul <- function(app, items, id, class, .close) {
  id <- clii__container_start(app, "ul", id = id, class = class)
  if (length(items)) { app$li(items); if (.close) app$end(id) }
  invisible(id)
}

clii_ol <- function(app, items, id, class, .close) {
  id <- clii__container_start(app, "ol", id = id, class = class)
  if (length(items)) { app$li(items); if (.close) app$end(id) }
  invisible(id)
}

clii_dl <- function(app, items, labels, id, class, .close) {
  id <- clii__container_start(app, "dl", id = id, class = class)
  if (length(items)) { app$li(items, labels); if (.close) app$end(id) }
  invisible(id)
}

clii_li <- function(app, items, labels, id, class) {
  id <- id %||% new_uuid()

  ## check the last active list container
  last <- length(app$doc)
  while (! app$doc[[last]]$tag %in% c("ul", "ol", "dl", "body")) {
    last <- last - 1L
  }

  ## if not the last container, close the ones below it
  if (app$doc[[last]]$tag != "body" &&
      last != length(app$doc)) {
    app$end(app$doc[[last + 1L]]$id)
  }

  ## if none, then create an ul container
  if (app$doc[[last]]$tag == "body") {
    cnt_id <- app$ul()
    type <- "ul"
  } else {
    cnt_id <- app$doc[[last]]$id
    type <- app$doc[[last]]$tag
  }

  if (length(items) > 0) {
    for (i in seq_along(items)) {
      id <- clii__container_start(app, "li", id = id, class = class)
      app$item_text(type, labels[[i]], cnt_id, items[[i]])
      if (i < length(items)) app$end(id)
    }
  } else {
    app$delayed_item <- list(type = type, cnt_id = cnt_id)
    id <- clii__container_start(app, "li", id = id, class = class)
  }

  invisible(id)
}

clii__item_text <- function(app, type, name, cnt_id, text, .list) {

  style <- app$get_current_style()
  cnt_style <- app$styles[[cnt_id]]

  head <- if (type == "dl") name else glue_delay(name)

  head$str <- if (type == "ul") {
    paste0(call_if_fun(style$`list-style-type`) %||% "*", " ")
  } else if (type == "ol") {
    res <- paste0(cnt_style$start %||% 1L, ". ")
    app$styles[[cnt_id]]$start <- (cnt_style$start %||% 1L) + 1L
    res
  } else if (type == "dl") {
    mrk <- text$values$marker
    text$str <- paste0("<", mrk, ".dd ", text$str, mrk, ">")
    mrk2 <- head$values$marker
    paste0("<", mrk2, ".dt ", head$str, mrk2, ">")
  }

  app$xtext(
    .list = c(list(head), list(text), .list),
    indent = - (style$`padding-left` %||% 0),
    padding = (cnt_style$`padding-left` %||% 0)
  )
}

## Close container(s) -----------------------------------------------

clii_end <- function(app, id) {
  clii__container_end(app, id)
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/debug.R"

#' Debug cli internals
#'
#' Return the current state of a cli app. It includes the currently
#' open tags, their ids, classes and their computed styles.
#'
#' The returned data frame has a print method, and if you want to create
#' a plain data frame from it, index it with an empty bracket:
#' `cli_debug_doc()[]`.
#'
#' To see all currently active themes, use `app$themes`, e.g. for the
#' default app: `default_app()$themes`.
#'
#' @param app The cli app to debug. Defaults to the current app.
#'   if there is no app, then it creates one by calling [start_app()].
#' @return Data frame with columns: `tag`, `id`, `class` (space separated),
#'   theme (id of the theme the element added), `styles` (computed styles
#'   for the element).
#'
#' @seealso [cli_sitrep()]. To debug containers, you can set the
#' `CLI-DEBUG_BAD_END` environment variable to `true`, and then cli will
#' warn when it cannot find the specified container to close (or any
#' contained at all).
#'
#' @examples
#' \dontrun{
#' cli_debug_doc()
#'
#' olid <- cli_ol()
#' cli_li()
#' cli_debug_doc()
#' cli_debug_doc()[]
#'
#' cli_end(olid)
#' cli_debug_doc()
#' }

cli_debug_doc <- function(app = default_app() %||% start_app()) {
  tgs <- vcapply(app$doc, "[[", "tag")
  ids <- vcapply(app$doc, "[[", "id")
  cls <- vcapply(app$doc, function(x) paste(x$class, collapse = " "))
  thm <- lapply(app$doc, function(x) x$theme)

  df <- data.frame(
    stringsAsFactors = FALSE,
    tag    = tgs,
    id     = ids,
    class  = cls,
    theme  = I(as.list(thm)),
    styles = I(as.list(unname(app$styles)))
  )

  class(df) <- c("cli_doc", class(df))
  df
}

#' @export

format.cli_doc <- function(x, ...) {
  nz <- nrow(x) > 0
  c("<cli document>",
    paste0(
      if (nz) "<",
      x$tag,
      if (nz) " id=\"", x$id, if (nz) "\"",
      ifelse (x$class == "", "", paste0(" class=\"", x$class, "\"")),
      if (nz) ">",
      ifelse (vlapply(x$theme, is.null), "", " +theme")
    )
  )
}

#' @export

print.cli_doc <- function(x, ...) {
  cat(format(x, ...), sep = "\n")
  invisible(x)
}

#' @export

`[.cli_doc` <- function(x, ...) {
  class(x) <- setdiff(class(x), "cli_doc")
  NextMethod()
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/defer.R"

# NOTE: patched to use `cli_error()`

# nocov start --- compat-defer ---
#
# This drop-in file implements withr::defer(). Please find the most
# recent version in withr's repository.
#
# 2022-03-03
# * Support for `source()` and `knitr::knit()`
# * Handlers are now stored in environments instead of lists to avoid
#   infinite recursion issues.
# * The handler list is now soft-namespaced.


defer <- function(expr, envir = parent.frame(), priority = c("first", "last")) { }

local({

defer <<- defer <- function(expr, envir = parent.frame(), priority = c("first", "last")) {
  priority <- match.arg(priority)
  invisible(
    add_handler(
      envir,
      handler = new_handler(substitute(expr), parent.frame()),
      front = priority == "first"
    )
  )
}

new_handler <- function(expr, envir) {
  hnd <- new.env(FALSE, size = 2)
  hnd[["expr"]] <- expr
  hnd[["envir"]] <- envir
  hnd
}

add_handler <- function(envir,
                        handler,
                        front,
                        frames = as.list(sys.frames()),
                        calls = as.list(sys.calls())) {
  envir <- exit_frame(envir, frames, calls)

  if (front) {
    handlers <- c(list(handler), get_handlers(envir))
  } else {
    handlers <- c(get_handlers(envir), list(handler))
  }

  set_handlers(envir, handlers, frames = frames, calls = calls)
  handler
}

set_handlers <- function(envir, handlers, frames, calls) {
  if (is.null(get_handlers(envir))) {
    # Ensure that list of handlers called when environment "ends"
    setup_handlers(envir)
  }

  attr(envir, "withr_handlers") <- handlers
}

# Evaluate `frames` lazily
setup_handlers <- function(envir,
                           frames = as.list(sys.frames()),
                           calls = as.list(sys.calls())) {
  if (is_top_level_global_env(envir, frames)) {
    # For session scopes we use reg.finalizer()
    if (is_interactive()) {
      message(
        sprintf("Setting global deferred event(s).\n"),
        "i These will be run:\n",
        "  * Automatically, when the R session ends.\n",
        "  * On demand, if you call `withr::deferred_run()`.\n",
        "i Use `withr::deferred_clear()` to clear them without executing."
      )
    }
    reg.finalizer(envir, function(env) deferred_run(env), onexit = TRUE)
  } else {
    # for everything else we use on.exit()

    call <- make_call(execute_handlers, envir)
    # We have to use do.call here instead of eval because of the way on.exit
    # determines its evaluation context
    # (https://stat.ethz.ch/pipermail/r-devel/2013-November/067867.html)

    do.call(base::on.exit, list(call, TRUE), envir = envir)
  }
}

exit_frame <- function(envir,
                       frames = as.list(sys.frames()),
                       calls = as.list(sys.calls())) {
  frame_loc <- frame_loc(envir, frames)
  if (!frame_loc) {
    return(envir)
  }

  if (in_knitr(envir)) {
    out <- knitr_frame(envir, frames, calls, frame_loc)
    if (!is.null(out)) {
      return(out)
    }
  }

  out <- source_frame(envir, frames, calls, frame_loc)
  if (!is.null(out)) {
    return(out)
  }

  envir
}

knitr_frame <- function(envir, frames, calls, frame_loc) {
  knitr_ns <- asNamespace("knitr")

  # This doesn't handle correctly the recursive case (knitr called
  # within a chunk). Handling this would be a little fiddly for an
  # uncommon edge case.
  for (i in seq(1, frame_loc)) {
    if (identical(topenv(frames[[i]]), knitr_ns)) {
      return(frames[[i]])
    }
  }

  NULL
}

source_frame <- function(envir, frames, calls, frame_loc) {
  i <- frame_loc

  if (i < 4) {
    return(NULL)
  }

  is_call <- function(x, fn) {
    is.call(x) && identical(x[[1]], fn)
  }
  calls <- as.list(calls)

  if (!is_call(calls[[i - 3]], quote(source))) {
    return(NULL)
  }
  if (!is_call(calls[[i - 2]], quote(withVisible))) {
    return(NULL)
  }
  if (!is_call(calls[[i - 1]], quote(eval))) {
    return(NULL)
  }
  if (!is_call(calls[[i - 0]], quote(eval))) {
    return(NULL)
  }

  frames[[i - 3]]
}

frame_loc <- function(envir, frames) {
  n <- length(frames)
  if (!n) {
    return(0)
  }

  for (i in seq_along(frames)) {
    if (identical(frames[[n - i + 1]], envir)) {
      return(n - i + 1)
    }
  }

  0
}

in_knitr <- function(envir) {
  knitr_in_progress() && identical(knitr::knit_global(), envir)
}

is_top_level_global_env <- function(envir, frames) {
  if (!identical(envir, globalenv())) {
    return(FALSE)
  }

  # Check if another global environment is on the stack
  !any(vapply(frames, identical, NA, globalenv()))
}

get_handlers <- function(envir) {
  attr(envir, "withr_handlers")
}

execute_handlers <- function(envir) {
  handlers <- get_handlers(envir)
  errors <- list()
  for (handler in handlers) {
    tryCatch(eval(handler$expr, handler$envir),
      error = function(e) {
        errors[[length(errors) + 1]] <<- e
      }
    )
  }
  attr(envir, "withr_handlers") <- NULL

  for (error in errors) {
    stop(error) %??%
      cli_error("Error in a deferred {.code on.exit()} clause")
  }
}

make_call <- function(...) {
  as.call(list(...))
}

# base implementation of rlang::is_interactive()
is_interactive <- function() {
  opt <- getOption("rlang_interactive")
  if (!is.null(opt)) {
    return(opt)
  }
  if (knitr_in_progress()) {
    return(FALSE)
  }
  if (identical(Sys.getenv("TESTTHAT"), "true")) {
    return(FALSE)
  }
  interactive()
}

knitr_in_progress <- function() {
  isTRUE(getOption("knitr.in.progress"))
}

}) # defer() namespace

# nocov end
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/diff.R"

#' Compare two character vectors elementwise
#'
#' Its printed output is similar to calling `diff -u` at the command
#' line.
#'
#' @param old First character vector.
#' @param new Second character vector.
#' @param max_dist Maximum distance to consider, or `Inf` for no limit.
#'   If the LCS edit distance is larger than this, then the function
#'   throws an error with class `"cli_diff_max_dist"`. (If you specify
#'   `Inf` the real limit is `.Machine$integer.max` but to reach this the
#'   function would have to run a very long time.)
#' @return A list that is a `cli_diff_chr` object, with a `format()` and a
#' `print()` method. You can also access its members:
#'  * `old` and `new` are the original inputs,
#'  * `lcs` is a data frame of LCS edit that transform `old` into `new`.
#'
#' The `lcs` data frame has the following columns:
#' * `operation`: one of `"match"`, `"delete"` or `"insert"`.
#' * `offset`: offset in `old` for matches and deletions, offset in `new`
#'   for insertions.
#' * `length`: length of the operation, i.e. number of matching, deleted
#'   or inserted elements.
#' * `old_offset`: offset in `old` _after_ the operation.
#' * `new_offset`: offset in `new` _after_ the operation.
#'
#' @family diff functions in cli
#' @seealso The diffobj package for a much more comprehensive set of
#' `diff`-like tools.
#' @export
#' @examples
#' letters2 <- c("P", "R", "E", letters, "P", "O", "S", "T")
#' letters2[11:16] <- c("M", "I", "D", "D", "L", "E")
#' diff_chr(letters, letters2)

diff_chr <- function(old, new, max_dist = Inf) {
  stopifnot(
    is.character(old),
    is.character(new),
    max_dist == Inf || is_count(max_dist)
  )
  max_dist2 <- as_max_dist(max_dist)

  lcs <- .Call(clic_diff_chr, old, new, max_dist2)

  if (max_dist2 != 0 && lcs[[4]] == max_dist2) {
    throw(cli_error(
      "Diff edit distance is larger than the limit.",
      "i" = "The edit distance limit is {max_dist}.",
      .data = list(max_dist = max_dist),
      .class = "cli_diff_max_dist"
    ))
  }

  op <- c("match", "delete", "insert")[lcs[[1]]]
  lcs <- data.frame(
    stringsAsFactors = FALSE,
    operation = op,
    offset = lcs[[2]],
    length = lcs[[3]],
    old_offset = cumsum(ifelse(op == "insert", 0, lcs[[3]])),
    new_offset = cumsum(ifelse(op == "delete", 0, lcs[[3]]))
  )

  ret <- structure(
    list(old = old, new = new, lcs = lcs),
    class = c("cli_diff_chr", "cli_diff", "list")
  )

  ret
}

#' Compare two character strings, character by character
#'
#' Characters are defined by UTF-8 graphemes.
#'
#' @param old First string, must not be `NA`.
#' @param new Second string, must not be `NA`.
#' @inheritParams diff_chr
#' @return A list that is a `cli_diff_str` object and also a
#'   `cli_diff_chr` object, see [diff_str] for the details about its
#'   structure.
#'
#' @family diff functions in cli
#' @seealso The diffobj package for a much more comprehensive set of
#' `diff`-like tools.
#'
#' @export
#' @examples
#' str1 <- "abcdefghijklmnopqrstuvwxyz"
#' str2 <- "PREabcdefgMIDDLEnopqrstuvwxyzPOST"
#' diff_str(str1, str2)

diff_str <- function(old, new, max_dist = Inf) {
  stopifnot(
    is_string(old),
    is_string(new)
    # max_dist is checked in diff_chr
  )

  old1 <- utf8_graphemes(old)[[1]]
  new1 <- utf8_graphemes(new)[[1]]

  ret <- diff_chr(old1, new1, max_dist)

  class(ret) <- c("cli_diff_str", class(ret))

  ret
}

#' @export

format.cli_diff_chr <- function(x, context = 3L, ...) {
  stopifnot(context == Inf || is_count(context))
  if (length(list(...)) > 0) {
    warning("Extra arguments were ignored in `format.cli_diff_chr()`.")
  }

  chunks <- get_diff_chunks(x$lcs, context = context)
  out <- lapply(
    seq_len(nrow(chunks)),
    format_chunk,
    x = x,
    chunks = chunks,
    context = context
  )

  ret <- as.character(unlist(out))
  if (context == Inf && length(ret) > 0) ret <- ret[-1]

  ret
}

get_diff_chunks <- function(lcs, context = 3L) {
  # the number of chunks is the number of non-matching sequences if
  # context == 0, but short matching parts do not separate chunks
  runs <- rle(lcs$operation != "match" | lcs$length <= 2 * context)
  nchunks <- sum(runs$values)

  # special case for a single match chunk
  if (nrow(lcs) == 1 && lcs$operation == "match") {
    nchunks <- if (context == Inf) 1 else 0
  }

  chunks <- data.frame(
    op_begin   = integer(nchunks),    # first op in chunk
    op_length  = integer(nchunks),    # number of operations in chunk
    old_begin  = integer(nchunks),    # first line from `old` in chunk
    old_length = integer(nchunks),    # number of lines from `old` in chunk
    new_begin  = integer(nchunks),    # first line from `new` in chunk
    new_length = integer(nchunks)     # number of lines from `new` in chunk
  )

  if (nchunks == 0) return(chunks)

  # infer some data about the original diff input
  old_off <- c(0, lcs$old_offset)
  new_off <- c(0, lcs$new_offset)
  old_size <- old_off[length(old_off)]
  new_size <- new_off[length(new_off)]
  old_empty <- old_size == 0
  new_empty <- new_size == 0

  # avoid working with Inf
  if (context == Inf) context <- max(old_size, new_size)

  # chunk starts at operation number sum(length) before it, plus 1, but
  # at the end we change this to include the context chunks are well
  chunks$op_begin  <- c(0, cumsum(runs$lengths))[which(runs$values)] + 1
  chunks$op_length <- runs$lengths[runs$values]

  # `old` positions are from `old_off`, but need to fix the boundaries
  chunks$old_begin <- old_off[chunks$op_begin] - context + 1
  chunks$old_begin[chunks$old_begin <= 1] <- if (old_empty) 0 else 1
  old_end <- old_off[chunks$op_begin + chunks$op_length] + context
  old_end[old_end > old_size] <- old_size
  chunks$old_length <- old_end - chunks$old_begin + 1

  # `new` positions are similar
  chunks$new_begin <- new_off[chunks$op_begin] - context + 1
  chunks$new_begin[chunks$new_begin <= 1] <- if (new_empty) 0 else 1
  new_end <- new_off[chunks$op_begin + chunks$op_length] + context
  new_end[new_end > new_size] <- new_size
  chunks$new_length <- new_end - chunks$new_begin + 1

  # change to include context chunks
  if (context > 0) {
    # calculae the end before updating the begin
    op_end <- chunks$op_begin + chunks$op_length - 1 + 1
    op_end[op_end > nrow(lcs)] <- nrow(lcs)
    chunks$op_begin <- chunks$op_begin - 1
    chunks$op_begin[chunks$op_begin == 0] <- 1
    chunks$op_length <- op_end - chunks$op_begin + 1
  }

  chunks
}

format_chunk <- function(x, chunks, num, context) {
  hdr <- paste0(
    "@@ -",
    chunks$old_begin[num],
    if ((l <- chunks$old_length[num]) != 1) paste0(",", l),
    " +",
    chunks$new_begin[num],
    if ((l <- chunks$new_length[num]) != 1) paste0(",", l),
    " @@"
  )

  from <- chunks$op_begin[num]
  to <- chunks$op_begin[num] + chunks$op_length[num] - 1

  lines <- lapply(from:to, function(i) {
    op <- x$lcs$operation[i]
    off <- x$lcs$offset[i]
    len <- x$lcs$length[i]
    if (op == "match") {
      if (len > context) {
        if (i == from) {
          # start later
          off <- off + len - context
          len <- context
        } else {
          # finish earlier
          len <- context
        }
      }
      paste0(" ", x$old[off + 1:len])

    } else if (op == "delete") {
      col_blue(paste0("-", x$old[off + 1:len]))

    } else if (op == "insert") {
      col_green(paste0("+", x$new[off + 1:len]))
    }
  })
  c(hdr, lines)
}

#' @export

print.cli_diff_chr <- function(x, ...) {
  writeLines(format(x, ...))
}

#' @export

format.cli_diff_str <- function(x, ...) {
  if (length(list(...)) > 0) {
    warning("Extra arguments were ignored in `format.cli_diff_chr()`.")
  }

  if (num_ansi_colors() == 1) {
    format_diff_str_nocolor(x, ...)
  } else {
    format_diff_str_color(x, ...)
  }
}

format_diff_str_color <- function(x, ...) {
  out <- lapply(seq_len(nrow(x$lcs)), function(i) {
    op <- x$lcs$operation[i]
    off <- x$lcs$offset[i]
    len <- x$lcs$length[i]
    if (op == "match") {
      paste0(x$old[off + 1:len], collapse = "")

    } else if (op == "delete") {
      bg_blue(col_black(paste0(x$old[off + 1:len], collapse = "")))

    } else if (op == "insert") {
      bg_green(col_black(paste0(x$new[off + 1:len], collapse = "")))
    }
  })

  paste(out, collapse = "")
}

format_diff_str_nocolor <- function(x, ...) {
  out <- lapply(seq_len(nrow(x$lcs)), function(i) {
    op <- x$lcs$operation[i]
    off <- x$lcs$offset[i]
    len <- x$lcs$length[i]
    if (op == "match") {
      paste0(x$old[off + 1:len], collapse = "")

    } else if (op == "delete") {
      paste0(c("[-", x$old[off + 1:len], "-]"), collapse = "")

    } else if (op == "insert") {
      paste0(c("{+", x$new[off + 1:len], "+}"), collapse = "")
    }
  })

  paste(out, collapse = "")
}

as_max_dist <- function(max_dist) {
  if (max_dist == Inf) {
    0L
  } else {
    as.integer(max_dist + 1L)
  }
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/docs.R"

#' Frequently Asked Questions
#'
#' @name faq
#' @includeRmd man/chunks/FAQ.Rmd
NULL


docs_progress_c_api <- function() {
  if (file.exists("inst/include/cli/progress.h")) {
    lines <- readLines("inst/include/cli/progress.h")
  } else {
    lines <- readLines("../inst/include/cli/progress.h")
  }

  ## Remove non-matching lines, but leave an empty line between blocks
  ptn <- "^//'[ ]?"
  mtch <- grepl(ptn, lines)
  lines[!mtch] <- ""
  prev <- c("", lines[-length(lines)])
  lines <- lines[mtch | prev != lines]

  ## Remove doc pattern
  lines <- sub(ptn, "", lines)

  tmp <- tempfile(fileext = ".Rmd")
  cat(lines, sep = "\n", file = tmp)
  tmp
}

#' @title The cli progress C API
#' @name progress-c
#' @section The cli progress C API:
#'
#' ```{r include = FALSE, cache = FALSE, child = cli:::docs_progress_c_api()}
#' ```
NULL

#' @title cli environment variables and options
#' @name cli-config
#'
#' @section User facing configuration:
#'
#' ```{r include = FALSE, child = "vignettes/cli-config-user.Rmd"}
#' ```
#'
#' @section Internal configuration:
#'
#' ```{r include = FALSE, child = "vignettes/cli-config-internal.Rmd"}
#' ```
NULL
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/enc-utils.R"

# keep encoding, even if useBytes = TRUE

sub_ <- function(pattern, replacement, x, ...) {
  enc <- Encoding(x)
  ret <- sub(pattern, replacement, x, ...)
  if (length(ret)) Encoding(ret) <- enc
  ret
}

gsub_ <- function(pattern, replacement, x, ...) {
  enc <- Encoding(x)
  ret <- gsub(pattern, replacement, x, ...)
  if (length(ret)) Encoding(ret) <- enc
  ret
}

strsplit_ <- function(x, ...) {
  enc <- Encoding(x)
  ret <- strsplit(x, ...)
  for (i in seq_along(ret)) {
    Encoding(ret[[i]]) <- enc[i]
  }
  ret
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/errors.R"

# # Standalone file for better error handling ----------------------------
#
# If can allow package dependencies, then you are probably better off
# using rlang's functions for errors.
#
# The canonical location of this file is in the processx package:
# https://github.com/r-lib/processx/blob/main/R/errors.R
#
# ## Dependencies
# - rstudio-detect.R for better printing in RStudio
#
# ## Features
#
# - Throw conditions and errors with the same API.
# - Automatically captures the right calls and adds them to the conditions.
# - Sets `.Last.error`, so you can easily inspect the errors, even if they
#   were not caught.
# - It only sets `.Last.error` for the errors that are not caught.
# - Hierarchical errors, to allow higher level error messages, that are
#   more meaningful for the users, while also keeping the lower level
#   details in the error object. (So in `.Last.error` as well.)
# - `.Last.error` always includes a stack trace. (The stack trace is
#   common for the whole error hierarchy.) The trace is accessible within
#   the error, e.g. `.Last.error$trace`. The trace of the last error is
#   also at `.Last.error.trace`.
# - Can merge errors and traces across multiple processes.
# - Pretty-print errors and traces, if the cli package is loaded.
# - Automatically hides uninformative parts of the stack trace when
#   printing.
#
# ## API
#
# ```
# new_cond(..., call. = TRUE, srcref = NULL, domain = NA)
# new_error(..., call. = TRUE, srcref = NULL, domain = NA)
# throw(cond, parent = NULL, frame = environment())
# throw_error(cond, parent = NULL, frame = environment())
# chain_error(expr, err, call = sys.call(-1))
# chain_call(.NAME, ...)
# chain_clean_call(.NAME, ...)
# onload_hook()
# add_trace_back(cond, frame = NULL)
# format$advice(x)
# format$call(call)
# format$class(x)
# format$error(x, trace = FALSE, class = FALSE, advice = !trace, ...)
# format$error_heading(x, prefix = NULL)
# format$header_line(x, prefix = NULL)
# format$srcref(call, srcref = NULL)
# format$trace(x, ...)
# ```
#
# ## Roadmap:
# - better printing of anonymous function in the trace
#
# ## NEWS:
#
# ### 1.0.0 -- 2019-06-18
#
# * First release.
#
# ### 1.0.1 -- 2019-06-20
#
# * Add `rlib_error_always_trace` option to always add a trace
#
# ### 1.0.2 -- 2019-06-27
#
# * Internal change: change topenv of the functions to baseenv()
#
# ### 1.1.0 -- 2019-10-26
#
# * Register print methods via onload_hook() function, call from .onLoad()
# * Print the error manually, and the trace in non-interactive sessions
#
# ### 1.1.1 -- 2019-11-10
#
# * Only use `trace` in parent errors if they are `rlib_error`s.
#   Because e.g. `rlang_error`s also have a trace, with a slightly
#   different format.
#
# ### 1.2.0 -- 2019-11-13
#
# * Fix the trace if a non-thrown error is re-thrown.
# * Provide print_this() and print_parents() to make it easier to define
#   custom print methods.
# * Fix annotating our throw() methods with the incorrect `base::`.
#
# ### 1.2.1 -- 2020-01-30
#
# * Update wording of error printout to be less intimidating, avoid jargon
# * Use default printing in interactive mode, so RStudio can detect the
#   error and highlight it.
# * Add the rethrow_call_with_cleanup function, to work with embedded
#   cleancall.
#
# ### 1.2.2 -- 2020-11-19
#
# * Add the `call` argument to `catch_rethrow()` and `rethrow()`, to be
#   able to omit calls.
#
# ### 1.2.3 -- 2021-03-06
#
# * Use cli instead of crayon
#
# ### 1.2.4 -- 2021-04-01
#
# * Allow omitting the call with call. = FALSE in `new_cond()`, etc.
#
# ### 1.3.0 -- 2021-04-19
#
# * Avoid embedding calls in trace with embed = FALSE.
#
# ### 2.0.0 -- 2021-04-19
#
# * Versioned classes and print methods
#
# ### 2.0.1 -- 2021-06-29
#
# * Do not convert error messages to native encoding before printing,
#   to be able to print UTF-8 error messages on Windows.
#
# ### 2.0.2 -- 2021-09-07
#
# * Do not translate error messages, as this converts them to the native
#   encoding. We keep messages in UTF-8 now.
#
# ### 3.0.0 -- 2022-04-19
#
# * Major rewrite, use rlang compatible error objects. New API.
#
# ### 3.0.1 -- 2022-06-17
#
# * Remove the `rlang_error` and `rlang_trace` classes, because our new
#   deparsed `call` column in the trace is not compatible with rlang.
#
# ### 3.0.2 -- 2022-08-01
#
# * Use a `procsrcref` column for processed source references.
#   Otherwise testthat (and probably other rlang based packages), will
#   pick up the `srcref` column, and they expect an `srcref` object there.
#
# ### 3.1.0 -- 2022-10-04
#
# * Add ANSI hyperlinks to stack traces, if we have a recent enough
#   cli package that supports this.
#
# ### 3.1.1 -- 2022-11-17
#
# * Use `[[` instead of `$` to fix some partial matches.
# * Use fully qualified `base::stop()` to enable overriding `stop()`
#   in a package. (Makes sense if compat files use `stop()`.
# * The `is_interactive()` function is now exported.
#
# ### 3.1.2 -- 2022-11-18
#
# * The `parent` condition can now be an interrupt.
#
# ### 3.1.3 -- 2023-01-15
#
# * Now we do not load packages when walking the trace.

err <- local({

  # -- dependencies -----------------------------------------------------
  rstudio_detect <- rstudio$detect

  # -- condition constructors -------------------------------------------

  #' Create a new condition
  #'
  #' @noRd
  #' @param ... Parts of the error message, they will be converted to
  #'   character and then concatenated, like in [stop()].
  #' @param call. A call object to include in the condition, or `TRUE`
  #'   or `NULL`, meaning that [throw()] should add a call object
  #'   automatically. If `FALSE`, then no call is added.
  #' @param srcref Alternative source reference object to use instead of
  #'   the one of `call.`.
  #' @param domain Translation domain, see [stop()]. We set this to
  #'   `NA` by default, which means that no translation occurs. This
  #'   has the benefit that the error message is not re-encoded into
  #'   the native locale.
  #' @return Condition object. Currently a list, but you should not rely
  #'   on that.

  new_cond <- function(..., call. = TRUE, srcref = NULL, domain = NA) {
    message <- .makeMessage(..., domain = domain)
    structure(
      list(message = message, call = call., srcref = srcref),
      class = c("condition"))
  }

  #' Create a new error condition
  #'
  #' It also adds the `rlib_error` class.
  #'
  #' @noRd
  #' @param ... Passed to [new_cond()].
  #' @param call. Passed to [new_cond()].
  #' @param srcref Passed tp [new_cond()].
  #' @param domain Passed to [new_cond()].
  #' @return Error condition object with classes `rlib_error`, `error`
  #'   and `condition`.

  new_error <- function(..., call. = TRUE, srcref = NULL, domain = NA) {
    cond <- new_cond(..., call. = call., domain = domain, srcref = srcref)
    class(cond) <- c("rlib_error_3_0", "rlib_error", "error", "condition")
    cond
  }

  # -- throwing conditions ----------------------------------------------

  #' Throw a condition
  #'
  #' If the condition is an error, it will also call [stop()], after
  #' signalling the condition first. This means that if the condition is
  #' caught by an exiting handler, then [stop()] is not called.
  #'
  #' @noRd
  #' @param cond Condition object to throw. If it is an error condition,
  #'   then it calls [stop()].
  #' @param parent Parent condition.
  #' @param frame The throwing context. Can be used to hide frames from
  #'   the backtrace.

  throw <- throw_error <- function(cond, parent = NULL, frame = environment()) {
    if (!inherits(cond, "condition")) {
      cond <- new_error(cond)
    }
    if (!is.null(parent) && !inherits(parent, "condition")) {
      throw(new_error("Parent condition must be a condition object"))
    }

    if (isTRUE(cond[["call"]])) {
      cond[["call"]] <- sys.call(-1) %||% sys.call()
    } else if (identical(cond[["call"]], FALSE)) {
      cond[["call"]] <- NULL
    }

    cond <- process_call(cond)

    if (!is.null(parent)) {
      cond$parent <- process_call(parent)
    }

    # We can set an option to always add the trace to the thrown
    # conditions. This is useful for example in context that always catch
    # errors, e.g. in testthat tests or knitr. This options is usually not
    # set and we signal the condition here
    always_trace <- isTRUE(getOption("rlib_error_always_trace"))
    .hide_from_trace <- 1L
    # .error_frame <- cond
    if (!always_trace) signalCondition(cond)

    if (is.null(cond$`_pid`)) cond$`_pid` <- Sys.getpid()
    if (is.null(cond$`_timestamp`)) cond$`_timestamp` <- Sys.time()

    # If we get here that means that the condition was not caught by
    # an exiting handler. That means that we need to create a trace.
    # If there is a hand-constructed trace already in the error object,
    # then we'll just leave it there.
    if (is.null(cond$trace)) cond <- add_trace_back(cond, frame = frame)

    # Set up environment to store .Last.error, it will be just before
    # baseenv(), so it is almost as if it was in baseenv() itself, like
    # .Last.value. We save the print methods here as well, and then they
    # will be found automatically.
    if (! "org:r-lib" %in% search()) {
      do.call("attach", list(new.env(), pos = length(search()),
                             name = "org:r-lib"))
    }
    env <- as.environment("org:r-lib")
    env$.Last.error <- cond
    env$.Last.error.trace <- cond$trace

    # If we always wanted a trace, then we signal the condition here
    if (always_trace) signalCondition(cond)

    # If this is not an error, then we'll just return here. This allows
    # throwing interrupt conditions for example, with the same UI.
    if (! inherits(cond, "error")) return(invisible())
    .hide_from_trace <- NULL

    # Top-level handler, this is intended for testing only for now,
    # and its design might change.
    if (!is.null(th <- getOption("rlib_error_handler")) &&
        is.function(th)) {
      return(th(cond))
    }

    # In non-interactive mode, we print the error + the traceback
    # manually, to make sure that it won't be truncated by R's error
    # message length limit.
    out <- format(
      cond,
      trace = !is_interactive(),
      class = FALSE,
      full = !is_interactive()
    )
    writeLines(out, con = default_output())

    # Dropping the classes and adding "duplicate_condition" is a workaround
    # for the case when we have non-exiting handlers on throw()-n
    # conditions. These would get the condition twice, because stop()
    # will also signal it. If we drop the classes, then only handlers
    # on "condition" objects (i.e. all conditions) get duplicate signals.
    # This is probably quite rare, but for this rare case they can also
    # recognize the duplicates from the "duplicate_condition" extra class.
    class(cond) <- c("duplicate_condition", "condition")

    # Turn off the regular error printing to avoid printing
    # the error twice.
    opts <- options(show.error.messages = FALSE)
    on.exit(options(opts), add = TRUE)

    base::stop(cond)
  }

  # -- rethrow with parent -----------------------------------------------

  #' Re-throw an error with a better error message
  #'
  #' Evaluate `expr` and if it errors, then throw a new error `err`,
  #' with the original error set as its parent.
  #'
  #' @noRd
  #' @param expr Expression to evaluate.
  #' @param err Error object or message to use for the child error.
  #' @param call Call to use in the re-thrown error. See [throw()].

  chain_error <- function(expr, err, call = sys.call(-1), srcref = NULL) {
    .hide_from_trace <- 1
    force(call)
    srcref <- srcref %||% utils::getSrcref(sys.call())
    withCallingHandlers({
      expr
    }, error = function(e) {
      .hide_from_trace <- 0:1
      e$srcref <- srcref
      e$procsrcref <- NULL
      if (!inherits(err, "condition")) {
        err <- new_error(err, call. = call)
      }
      throw_error(err, parent = e)
    })
  }

  # -- rethrowing conditions from C code ---------------------------------

  #' Version of .Call that throw()s errors
  #'
  #' It re-throws error from compiled code. If the error had class
  #' `simpleError`, like all errors, thrown via `error()` in C do, it also
  #' adds the `c_error` class.
  #'
  #' @noRd
  #' @param .NAME Compiled function to call, see [.Call()].
  #' @param ... Function arguments, see [.Call()].
  #' @return Result of the call.

  chain_call <- function(.NAME, ...) {
    .hide_from_trace <- 1:3 # withCallingHandlers + do.call + .handleSimpleError (?)
    call <- sys.call()
    call1 <- sys.call(-1)
    srcref <- utils::getSrcref(call)
    withCallingHandlers(
      do.call(".Call", list(.NAME, ...)),
      error = function(e) {
        .hide_from_trace <- 0:1
        e$srcref <- srcref
        e$procsrcref <- NULL
        e[["call"]] <- call
        name <- native_name(.NAME)
        err <- new_error("Native call to `", name, "` failed", call. = call1)
        cerror <- if (inherits(e, "simpleError")) "c_error"
        class(err) <- c(cerror, "rlib_error_3_0", "rlib_error", "error", "condition")
        throw_error(err, parent = e)
      }
    )
  }

  package_env <- topenv()

  #' Version of entrace_call that supports cleancall
  #'
  #' This function is the same as [entrace_call()], except that it
  #' uses cleancall's [.Call()] wrapper, to enable resource cleanup.
  #' See https://github.com/r-lib/cleancall#readme for more about
  #' resource cleanup.
  #'
  #' @noRd
  #' @param .NAME Compiled function to call, see [.Call()].
  #' @param ... Function arguments, see [.Call()].
  #' @return Result of the call.

  chain_clean_call <- function(.NAME, ...) {
    .hide_from_trace <- 1:3
    call <- sys.call()
    call1 <- sys.call(-1)
    srcref <- utils::getSrcref(call)
    withCallingHandlers(
      package_env$call_with_cleanup(.NAME, ...),
      error = function(e) {
        .hide_from_trace <- 0:1
        e$srcref <- srcref
        e$procsrcref <- NULL
        e[["call"]] <- call
        name <- native_name(.NAME)
        err <- new_error("Native call to `", name, "` failed", call. = call1)
        cerror <- if (inherits(e, "simpleError")) "c_error"
        class(err) <- c(cerror, "rlib_error_3_0", "rlib_error", "error", "condition")
        throw_error(err, parent = e)
      }
    )
  }

  # -- create traceback -------------------------------------------------

  #' Create a traceback
  #'
  #' [throw()] calls this function automatically if an error is not caught,
  #' so there is currently not much use to call it directly.
  #'
  #' @param cond Condition to add the trace to
  #' @param frame Use this context to hide some frames from the traceback.
  #'
  #' @return A condition object, with the trace added.

  add_trace_back <- function(cond, frame = NULL) {

    idx <- seq_len(sys.parent(1L))
    frames <- sys.frames()[idx]

    # TODO: remove embedded objects from calls
    calls <- as.list(sys.calls()[idx])
    parents <- sys.parents()[idx]
    namespaces <- unlist(lapply(
      seq_along(frames),
      function(i) {
        if (is_operator(calls[[i]])) {
          "o"
        } else {
          env_label(topenvx(environment(sys.function(i))))
        }
      }
    ))
    pids <- rep(cond$`_pid` %||% Sys.getpid(), length(calls))

    mch <- match(format(frame), sapply(frames, format))
    if (is.na(mch)) {
      visibles <- TRUE
    } else {
      visibles <- c(rep(TRUE, mch), rep(FALSE, length(frames) - mch))
    }

    scopes <- vapply(idx, FUN.VALUE = character(1), function(i) {
      tryCatch(
        get_call_scope(calls[[i]], namespaces[[i]]),
        error = function(e) ""
      )
    })

    namespaces <- ifelse(scopes %in% c("::", ":::"), namespaces, NA_character_)
    funs <- ifelse(
      is.na(namespaces),
      ifelse(scopes != "", paste0(scopes, " "), ""),
      paste0(namespaces, scopes)
    )
    funs <- paste0(
      funs,
      vapply(calls, function(x) format_name(x[[1]])[1], character(1))
    )
    visibles <- visibles & mark_invisible_frames(funs, frames)

    pcs <- lapply(calls, function(c) process_call(list(call = c)))
    calls <- lapply(pcs, "[[", "call")
    srcrefs <- I(lapply(pcs, "[[", "srcref"))
    procsrcrefs <- I(lapply(pcs, "[[", "procsrcref"))

    cond$trace <- new_trace(
      calls,
      parents,
      visibles = visibles,
      namespaces = namespaces,
      scopes = scopes,
      srcrefs = srcrefs,
      procsrcrefs = procsrcrefs,
      pids
    )

    cond
  }

  is_operator <- function(cl) {
    is.call(cl) && length(cl) >= 1 && is.symbol(cl[[1]]) &&
      grepl("^[^.a-zA-Z]", as.character(cl[[1]]))
  }

  mark_invisible_frames <- function(funs, frames) {
    visibles <- rep(TRUE, length(frames))
    hide <- lapply(frames, "[[", ".hide_from_trace")
    w_hide <- unlist(mapply(seq_along(hide), hide, FUN = function(i, w) {
      i + w
    }, SIMPLIFY = FALSE))
    w_hide <- w_hide[w_hide <= length(frames)]
    visibles[w_hide] <- FALSE

    hide_from <- which(funs %in% names(invisible_frames))
    for (start in hide_from) {
      hide_this <- invisible_frames[[ funs[start] ]]
      for (i in seq_along(hide_this)) {
        if (start + i > length(funs)) break
        if (funs[start + i] != hide_this[i]) break
        visibles[start + i] <- FALSE
      }
    }

    visibles
  }

  invisible_frames <- list(
    "base::source" = c("base::withVisible", "base::eval", "base::eval"),
    "base::stop" = "base::.handleSimpleError",
    "cli::cli_abort" = c(
      "rlang::abort",
      "rlang:::signal_abort",
      "base::signalCondition"),
    "rlang::abort" = c("rlang:::signal_abort", "base::signalCondition")
  )

  call_name <- function(x) {
    if (is.call(x)) {
      if (is.symbol(x[[1]])) {
        as.character(x[[1]])
      } else if (x[[1]][[1]] == quote(`::`) || x[[1]][[1]] == quote(`:::`)) {
        as.character(x[[1]][[2]])
      } else {
        NULL
      }
    } else {
      NULL
    }
  }

  get_call_scope <- function(call, ns) {
    if (is.na(ns)) return("global")
    if (!is.call(call)) return("")
    if (is.call(call[[1]]) &&
        (call[[1]][[1]] == quote(`::`) || call[[1]][[1]] == quote(`:::`))) return("")
    if (ns == "base") return("::")
    if (! ns %in% loadedNamespaces()) return("")
    name <- call_name(call)
    if (! ns %in% loadedNamespaces()) return("::")
    nsenv <- asNamespace(ns)$.__NAMESPACE__.
    if (is.null(nsenv)) return("::")
    if (is.null(nsenv$exports)) return(":::")
    if (exists(name, envir = nsenv$exports, inherits = FALSE)) {
      "::"
    } else if (exists(name, envir = asNamespace(ns), inherits = FALSE)) {
      ":::"
    } else {
      "local"
    }
  }

  topenvx <- function(x) {
    topenv(x, matchThisEnv = err_env)
  }

  new_trace <- function (calls, parents, visibles, namespaces, scopes, srcrefs, procsrcrefs, pids) {
    trace <- data.frame(
      stringsAsFactors = FALSE,
      parent = parents,
      visible = visibles,
      namespace = namespaces,
      scope = scopes,
      srcref = srcrefs,
      procsrcref = procsrcrefs,
      pid = pids
    )
    trace[["call"]] <- calls

    class(trace) <- c("rlib_trace_3_0", "rlib_trace", "tbl", "data.frame")
    trace
  }

  env_label <- function(env) {
    nm <- env_name(env)
    if (nzchar(nm)) {
      nm
    } else {
      env_address(env)
    }
  }

  env_address <- function(env) {
    class(env) <- "environment"
    sub("^.*(0x[0-9a-f]+)>$", "\\1", format(env), perl = TRUE)
  }

  env_name <- function(env) {
    if (identical(env, err_env)) {
      return(env_name(package_env))
    }
    if (identical(env, globalenv())) {
      return(NA_character_)
    }
    if (identical(env, baseenv())) {
      return("base")
    }
    if (identical(env, emptyenv())) {
      return("empty")
    }
    nm <- environmentName(env)
    if (isNamespace(env)) {
      return(nm)
    }
    nm
  }

  # -- S3 methods -------------------------------------------------------

  format_error <- function(x, trace = FALSE, class = FALSE,
                           advice = !trace, full = trace, header = TRUE,
                           ...) {
    if (has_cli()) {
      format_error_cli(x, trace, class, advice, full, header, ...)
    } else {
      format_error_plain(x, trace, class, advice, full, header, ...)
    }
  }

  print_error <- function(x, trace = TRUE, class = TRUE,
                          advice = !trace,  ...) {
    writeLines(format_error(x, trace, class, advice, ...))
  }

  format_trace <- function(x, ...) {
    if (has_cli()) {
      format_trace_cli(x, ...)
    } else {
      format_trace_plain(x, ...)
    }
  }

  print_trace <- function(x, ...) {
    writeLines(format_trace(x, ...))
  }

  cnd_message <- function(cond) {
    paste(cnd_message_(cond, full = FALSE), collapse = "\n")
  }

  cnd_message_ <- function(cond, full = FALSE) {
    if (has_cli()) {
      cnd_message_cli(cond, full)
    } else {
      cnd_message_plain(cond, full)
    }
  }

  # -- format API -------------------------------------------------------

  format_advice <- function(x) {
    if (has_cli()) {
      format_advice_cli(x)
    } else {
      format_advice_plain(x)
    }
  }

  format_call <- function(call) {
    if (has_cli()) {
      format_call_cli(call)
    } else {
      format_call_plain(call)
    }
  }

  format_class <- function(x) {
    if (has_cli()) {
      format_class_cli(x)
    } else {
      format_class_plain(x)
    }
  }

  format_error_heading <- function(x, prefix = NULL) {
    if (has_cli()) {
      format_error_heading_cli(x, prefix)
    } else {
      format_error_heading_plain(x, prefix)
    }
  }

  format_header_line <- function(x, prefix = NULL) {
    if (has_cli()) {
      format_header_line_cli(x, prefix)
    } else {
      format_header_line_plain(x, prefix)
    }
  }

  format_srcref <- function(call, srcref = NULL) {
    if (has_cli()) {
      format_srcref_cli(call, srcref)
    } else {
      format_srcref_plain(call, srcref)
    }
  }

  # -- condition message with cli ---------------------------------------

  cnd_message_robust <- function(cond) {
    class(cond) <- setdiff(class(cond), "rlib_error_3_0")
    conditionMessage(cond) %||%
      (if (inherits(cond, "interrupt")) "interrupt") %||%
      ""
  }

  cnd_message_cli <- function(cond, full = FALSE) {
    exp <- paste0(cli::col_yellow("!"), " ")
    add_exp <- is.null(names(cond$message))
    msg <- cnd_message_robust(cond)

    c(
      paste0(if (add_exp) exp, msg),
      if (inherits(cond$parent, "condition")) {
        msg <- if (full && inherits(cond$parent, "rlib_error_3_0")) {
          format(cond$parent,
                 trace = FALSE,
                 full = TRUE,
                 class = FALSE,
                 header = FALSE,
                 advice = FALSE
          )
        } else if (inherits(cond$parent, "interrupt")) {
          "interrupt"
        } else {
          conditionMessage(cond$parent)
        }
        add_exp <- substr(cli::ansi_strip(msg[1]), 1, 1) != "!"
        if (add_exp) msg[1] <- paste0(exp, msg[1])
        c(format_header_line_cli(cond$parent, prefix = "Caused by error"),
          msg
        )
      }
    )
  }

  # -- condition message w/o cli ----------------------------------------

  cnd_message_plain <- function(cond, full = FALSE) {
    exp <- "! "
    add_exp <- is.null(names(cond$message))
    c(
      paste0(if (add_exp) exp, cnd_message_robust(cond)),
      if (inherits(cond$parent, "condition")) {
        msg <- if (full && inherits(cond$parent, "rlib_error_3_0")) {
          format(cond$parent,
                 trace = FALSE,
                 full = TRUE,
                 class = FALSE,
                 header = FALSE,
                 advice = FALSE
          )
        } else if (inherits(cond$parent, "interrupt")) {
          "interrupt"
        } else {
          conditionMessage(cond$parent)
        }
        add_exp <- substr(msg[1], 1, 1) != "!"
        if (add_exp) {
          msg[1] <- paste0(exp, msg[1])
        }
        c(format_header_line_plain(cond$parent, prefix = "Caused by error"),
          msg
        )
      }
    )
  }

  # -- printing error with cli ------------------------------------------

  # Error parts:
  # - "Error:" or "Error in " prefix, the latter if the error has a call
  # - the call, possibly syntax highlightedm possibly trimmed (?)
  # - source ref, with link to the file, potentially in a new line in cli
  # - error message, just `conditionMessage()`
  # - advice about .Last.error and/or .Last.error.trace

  format_error_cli <- function(x, trace = TRUE, class = TRUE,
                               advice = !trace, full = trace,
                               header = TRUE, ...) {
    p_class <- if (class) format_class_cli(x)
    p_header <- if (header) format_header_line_cli(x)
    p_msg <- cnd_message_cli(x, full)
    p_advice <- if (advice) format_advice_cli(x) else NULL
    p_trace <- if (trace && !is.null(x$trace)) {
      c("---", "Backtrace:", format_trace_cli(x$trace))
    }

    c(p_class,
      p_header,
      p_msg,
      p_advice,
      p_trace)
  }

  format_header_line_cli <- function(x, prefix = NULL) {
    p_error <- format_error_heading_cli(x, prefix)
    p_call <- format_call_cli(x[["call"]])
    p_srcref <- format_srcref_cli(conditionCall(x), x$procsrcref %||% x$srcref)
    paste0(p_error, p_call, p_srcref, if (!is.null(conditionCall(x))) ":")
  }

  format_class_cli <- function(x) {
    cls <- unique(setdiff(class(x), "condition"))
    cls # silence codetools
    cli::format_inline("{.cls {cls}}")
  }

  format_error_heading_cli <- function(x, prefix = NULL) {
    str_error <- if (is.null(prefix)) {
      cli::style_bold(cli::col_yellow("Error"))
    } else {
      cli::style_bold(paste0(prefix))
    }
    if (is.null(conditionCall(x))) {
      paste0(str_error, ": ")
    } else {
      paste0(str_error, " in ")
    }
  }

  format_call_cli <- function(call) {
    if (is.null(call)) {
      NULL
    } else {
      cl <- trimws(format(call))
      if (length(cl) > 1) cl <- paste0(cl[1], " ", cli::symbol$ellipsis)
      cli::format_inline("{.code {cl}}")
    }
  }

  format_srcref_cli <- function(call, srcref = NULL) {
    ref <- get_srcref(call, srcref)
    if (is.null(ref)) return("")

    link <- if (ref$file != "") {
      if (Sys.getenv("R_CLI_HYPERLINK_STYLE") == "iterm") {
        cli::style_hyperlink(
          cli::format_inline("{basename(ref$file)}:{ref$line}:{ref$col}"),
          paste0("file://", ref$file, "#", ref$line, ":", ref$col)
        )
      } else {
        cli::style_hyperlink(
          cli::format_inline("{basename(ref$file)}:{ref$line}:{ref$col}"),
          paste0("file://", ref$file),
          params = c(line = ref$line, col = ref$col)
        )
      }
    } else {
      paste0("line ", ref$line)
    }

    cli::col_silver(paste0(" at ", link))
  }

  str_advice <- "Type .Last.error to see the more details."

  format_advice_cli <- function(x) {
    cli::col_silver(str_advice)
  }

  format_trace_cli <- function(x, ...) {
    x$num <- seq_len(nrow(x))

    scope <- ifelse(
      is.na(x$namespace),
      ifelse(x$scope != "", paste0(x$scope, " "), ""),
      paste0(x$namespace, x$scope)
    )

    visible <- if ("visible" %in% names(x)) {
      x$visible
    } else {
      rep(TRUE, nrow(x))
    }

    srcref <- if ("srcref" %in% names(x) || "procsrcref" %in% names(x)) {
      vapply(
        seq_len(nrow(x)),
        function(i) format_srcref_cli(x[["call"]][[i]], x$procsrcref[[i]] %||% x$srcref[[i]]),
        character(1)
      )
    } else {
      unname(vapply(x[["call"]], format_srcref_cli, character(1)))
    }

    lines <- paste0(
      cli::col_silver(format(x$num), ". "),
      ifelse (visible, "", "| "),
      scope,
      vapply(seq_along(x$call), function(i) {
        format_trace_call_cli(x$call[[i]], x$namespace[[i]])
      }, character(1)),
      srcref
    )

    lines[!visible] <- cli::col_silver(cli::ansi_strip(
      lines[!visible],
      link = FALSE
    ))

    lines
  }

  format_trace_call_cli <- function(call, ns = "") {
    envir <- tryCatch({
      if (!ns %in% loadedNamespaces()) stop("no")
      asNamespace(ns)
    }, error = function(e) .GlobalEnv)
    cl <- trimws(format(call))
    if (length(cl) > 1) { cl <- paste0(cl[1], " ", cli::symbol$ellipsis) }
    # Older cli does not have 'envir'.
    if ("envir" %in% names(formals(cli::code_highlight))) {
      fmc <- cli::code_highlight(cl, envir = envir)[1]
    } else {
      fmc <- cli::code_highlight(cl)[1]
    }
    cli::ansi_strtrim(fmc, cli::console_width() - 5)
  }

  # ----------------------------------------------------------------------

  format_error_plain <- function(x, trace = TRUE, class = TRUE,
                                 advice = !trace, full = trace, header = TRUE,
                                 ...) {
    p_class <- if (class) format_class_plain(x)
    p_header <- if (header) format_header_line_plain(x)
    p_msg <- cnd_message_plain(x, full)
    p_advice <- if (advice) format_advice_plain(x) else NULL
    p_trace <- if (trace && !is.null(x$trace)) {
      c("---", "Backtrace:", format_trace_plain(x$trace))
    }

    c(p_class,
      p_header,
      p_msg,
      p_advice,
      p_trace)
  }

  format_trace_plain <- function(x, ...) {
    x$num <- seq_len(nrow(x))

    scope <- ifelse(
      is.na(x$namespace),
      ifelse(x$scope != "", paste0(x$scope, " "), ""),
      paste0(x$namespace, x$scope)
    )

    visible <- if ("visible" %in% names(x)) {
      x$visible
    } else {
      rep(TRUE, nrow(x))
    }

    srcref <- if ("srcref" %in% names(x) || "procsrfref" %in% names(x)) {
      vapply(
        seq_len(nrow(x)),
        function(i) format_srcref_plain(x[["call"]][[i]], x$procsrcref[[i]] %||% x$srcref[[i]]),
        character(1)
      )
    } else {
      unname(vapply(x[["call"]], format_srcref_plain, character(1)))
    }

    lines <- paste0(
      paste0(format(x$num), ". "),
      ifelse (visible, "", "| "),
      scope,
      vapply(x[["call"]], format_trace_call_plain, character(1)),
      srcref
    )

    lines
  }

  format_advice_plain <- function(x, ...) {
    str_advice
  }

  format_header_line_plain <- function(x, prefix = NULL) {
    p_error <- format_error_heading_plain(x, prefix)
    p_call <- format_call_plain(x[["call"]])
    p_srcref <- format_srcref_plain(conditionCall(x), x$procsrcref %||% x$srcref)
    paste0(p_error, p_call, p_srcref, if (!is.null(conditionCall(x))) ":")
  }

  format_error_heading_plain <- function(x, prefix = NULL) {
    str_error <- if (is.null(prefix)) "Error" else prefix
    if (is.null(conditionCall(x))) {
      paste0(str_error, ": ")
    } else {
      paste0(str_error, " in ")
    }
  }

  format_class_plain <- function(x) {
    cls <- unique(setdiff(class(x), "condition"))
    paste0("<", paste(cls, collapse = "/"), ">")
  }

  format_call_plain <- function(call) {
    if (is.null(call)) {
      NULL
    } else {
      cl <- trimws(format(call))
      if (length(cl) > 1) cl <- paste0(cl[1], " ...")
      paste0("`", cl, "`")
    }
  }

  format_srcref_plain <- function(call, srcref = NULL) {
    ref <- get_srcref(call, srcref)
    if (is.null(ref)) return("")

    link <- if (ref$file != "") {
      paste0(basename(ref$file), ":", ref$line, ":", ref$col)
    } else {
      paste0("line ", ref$line)
    }

    paste0(" at ", link)
  }

  format_trace_call_plain <- function(call) {
    fmc <- trimws(format(call)[1])
    if (length(fmc) > 1) { fmc <- paste0(fmc[1], " ...") }
    strtrim(fmc, getOption("width") - 5)
  }

  # -- utilities ---------------------------------------------------------

  cli_version <- function() {
    # this loads cli!
    package_version(asNamespace("cli")[[".__NAMESPACE__."]]$spec[["version"]])
  }

  has_cli <- function() {
    "cli" %in% loadedNamespaces() && cli_version() >= "3.3.0"
  }

  `%||%` <- function(l, r) if (is.null(l)) r else l

  bytes <- function(x) {
    nchar(x, type = "bytes")
  }

  process_call <- function(cond) {
    cond[c("call", "srcref", "procsrcref")] <- list(
      call = if (is.null(cond[["call"]])) {
        NULL
      } else if (is.character(cond[["call"]])) {
        cond[["call"]]
      } else {
        deparse(cond[["call"]], nlines = 2)
      },
      srcref = NULL,
      procsrcref = get_srcref(cond[["call"]], cond$procsrcref %||% cond$srcref)
    )
    cond
  }

  get_srcref <- function(call, srcref = NULL) {
    ref <- srcref %||% utils::getSrcref(call)
    if (is.null(ref)) return(NULL)
    if (inherits(ref, "processed_srcref")) return(ref)
    file <- utils::getSrcFilename(ref, full.names = TRUE)[1]
    if (is.na(file)) file <- ""
    line <- utils::getSrcLocation(ref) %||% ""
    col <- utils::getSrcLocation(ref, which = "column") %||% ""
    structure(
      list(file = file, line = line, col = col),
      class = "processed_srcref"
    )
  }

  is_interactive <- function() {
    opt <- getOption("rlib_interactive")
    if (isTRUE(opt)) {
      TRUE
    } else if (identical(opt, FALSE)) {
      FALSE
    } else if (tolower(getOption("knitr.in.progress", "false")) == "true") {
      FALSE
    } else if (tolower(getOption("rstudio.notebook.executing", "false")) == "true") {
      FALSE
    } else if (identical(Sys.getenv("TESTTHAT"), "true")) {
      FALSE
    } else {
      interactive()
    }
  }

  no_sink <- function() {
    sink.number() == 0 && sink.number("message") == 2
  }

  rstudio_stdout <- function() {
    rstudio <- rstudio_detect()
    rstudio$type %in% c(
      "rstudio_console",
      "rstudio_console_starting",
      "rstudio_build_pane",
      "rstudio_job",
      "rstudio_render_pane"
    )
  }

  default_output <- function() {
    if ((is_interactive() || rstudio_stdout()) && no_sink()) {
      stdout()
    } else {
      stderr()
    }
  }

  onload_hook <- function() {
    reg_env <- Sys.getenv("R_LIB_ERROR_REGISTER_PRINT_METHODS", "TRUE")
    if (tolower(reg_env) != "false") {
      registerS3method("format", "rlib_error_3_0", format_error, baseenv())
      registerS3method("format", "rlib_trace_3_0", format_trace, baseenv())
      registerS3method("print", "rlib_error_3_0", print_error, baseenv())
      registerS3method("print", "rlib_trace_3_0", print_trace, baseenv())
      registerS3method("conditionMessage", "rlib_error_3_0", cnd_message, baseenv())
    }
  }

  native_name <- function(x) {
    if (inherits(x, "NativeSymbolInfo")) {
      x$name
    } else {
      format(x)
    }
  }

  # There is no format() for 'name' in R 3.6.x and before
  format_name <- function(x) {
    if (is.name(x)) {
      as.character(x)
    } else {
      format(x)
    }
  }

  # -- public API --------------------------------------------------------

  err_env <- environment()
  parent.env(err_env) <- baseenv()

  structure(
    list(
      .internal        = err_env,
      new_cond         = new_cond,
      new_error        = new_error,
      throw            = throw,
      throw_error      = throw_error,
      chain_error      = chain_error,
      chain_call       = chain_call,
      chain_clean_call = chain_clean_call,
      add_trace_back   = add_trace_back,
      process_call     = process_call,
      onload_hook      = onload_hook,
      is_interactive   = is_interactive,
      format = list(
        advice        = format_advice,
        call          = format_call,
        class         = format_class,
        error         = format_error,
        error_heading = format_error_heading,
        header_line   = format_header_line,
        srcref        = format_srcref,
        trace         = format_trace
      )
    ),
    class = c("standalone_errors", "standalone"))
})

# These are optional, and feel free to remove them if you prefer to
# call them through the `err` object.

new_cond         <- err$new_cond
new_error        <- err$new_error
throw            <- err$throw
throw_error      <- err$throw_error
chain_error      <- err$chain_error
chain_call       <- err$chain_call
chain_clean_call <- err$chain_clean_call
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/format-conditions.R"

#' Format an error, warning or diagnostic message
#'
#' You can then throw this message with [stop()] or `rlang::abort()`.
#'
#' The messages can use inline styling, pluralization and glue
#' substitutions.
#'
#' ```{asciicast format-error}
#' n <- "boo"
#' stop(format_error(c(
#'         "{.var n} must be a numeric vector",
#'   "x" = "You've supplied a {.cls {class(n)}} vector."
#' )))
#' ```
#'
#' ```{asciicast format-error-2}
#' len <- 26
#' idx <- 100
#' stop(format_error(c(
#'         "Must index an existing element:",
#'   "i" = "There {?is/are} {len} element{?s}.",
#'   "x" = "You've tried to subset element {idx}."
#' )))
#' ```
#'
#' @param message It is formatted via a call to [cli_bullets()].
#' @param .envir Environment to evaluate the glue expressions in.
#'
#' @seealso These functions support [inline markup][inline-markup].
#' @family functions supporting inline markup
#' @export

format_error <- function(message, .envir = parent.frame()) {
  if (length(message) > 0 &&
      (is.null(names(message)) || names(message)[1] == "")) {
    # The default theme will make this bold
    names(message)[1] <- "1"
  }

  if (length(message) > 0) {
    message[1] <- paste0("Error: ", message[1])
  }

  rsconsole <- c("rstudio_console", "rstudio_console_starting")
  oldopt <- options(
    cli.width = getOption("cli.condition_width") %||% getOption("cli.width")
  )
  on.exit(options(oldopt), add =TRUE)

  # We need to create a frame here, so cli_div() is closed.
  # Cannot use local(), it does not work in snapshot tests, it potentially
  # has issues elsewhere as well.
  formatted1 <- cli_fmt((function() {
    cli_div(class = "cli_rlang cli_abort", theme = cnd_theme())
    cli_bullets(message, .envir = .envir)
  })(), collapse = TRUE, strip_newline = TRUE)

  # remove "Error: " that was only needed for the wrapping
  formatted1[1] <- sub("Error:[ ]?", "", formatted1[1])

  update_rstudio_color(formatted1)
}

#' @rdname format_error
#' @export

format_warning <- function(message, .envir = parent.frame()) {
  if (length(message) > 0 &&
      (is.null(names(message)) || names(message)[1] == "")) {
    # The default theme will make this bold
    names(message)[1] <- "1"
  }

  oldopt <- options(
    cli.width = getOption("cli.condition_width") %||% getOption("cli.width")
  )
  on.exit(options(oldopt), add = TRUE)

  formatted1 <- cli_fmt((function() {
    cli_div(class = "cli_rlang cli_warn", theme = cnd_theme())
    cli_bullets(message, .envir = .envir)
  })(), collapse = TRUE, strip_newline = TRUE)

  update_rstudio_color(formatted1)
}

#' @rdname format_error
#' @export

format_message <- function(message, .envir = parent.frame()) {
  oldopt <- options(
    cli.width = getOption("cli.condition_width") %||% getOption("cli.width")
  )
  on.exit(options(oldopt), add = TRUE)
  formatted1 <- cli_fmt((function() {
    cli_div(class = "cli_rlang cli_inform", theme = cnd_theme())
    cli_bullets(message, .envir = .envir)
  })(), collapse = TRUE, strip_newline = TRUE)
  update_rstudio_color(formatted1)
}

update_rstudio_color <- function(message) {
  rscol <- get_rstudio_fg_color()
  if (!is.null(rscol)) {
    # in RStudio we only need to change the color
    message[] <- rscol(message)
  } else {
    # in a terminal we need to undo the bold
    message <- paste0(style_bold(""), message)
  }
  message
}

get_rstudio_fg_color <- function() {
  tryCatch(
    get_rstudio_fg_color0(),
    error = function(e) NULL
  )
}

get_rstudio_fg_color0 <- function() {
  rs <- rstudio_detect()
  oktypes <- c("rstudio_console", "rstudio_console_starting")
  if (! rs$type %in% oktypes) return(NULL)
  if (rs$num_colors == 1) return(NULL)
  colstr <- get_rstudio_theme()$foreground
  if (is.null(colstr)) return(NULL)
  colstr0 <- substr(colstr, 5, nchar(colstr) - 1)
  rgbnum <- scan(text = colstr0, sep = ",", quiet = TRUE)
  rgb <- grDevices::rgb(rgbnum[1]/255, rgbnum[2]/255, rgbnum[3]/255)
  make_ansi_style(rgb)
}

rstudio_detect <- function() {
  rstudio$detect()
}

cnd_theme <- function() {
  list(
    ".cli_rlang .bullets .bullet-v" = list(
      before = function(x) paste0(col_green(cnd_symb("tick")), " ")
    ),
    ".bullets .bullet-x" = list(
      before = function(x) paste0(col_red(cnd_symb("cross")), " ")
    ),
    ".bullets .bullet-i" = list(
      before = function(x) paste0(col_cyan(cnd_symb("info")), " ")
    ),
    ".bullets .bullet-*" = list(
      before = function(x) paste0(col_cyan(cnd_symb("bullet")), " ")
    ),
    ".bullets .bullet->" = list(
      before = function(x) paste0(cnd_symb("arrow_right"), " ")
    )
  )
}

cnd_symb <- function(name) {
  opt <- getOption("cli.condition_unicode_bullets", NULL)
  if (isTRUE(opt)) {
    symbol_utf8[[name]]
  } else if (isFALSE(opt)) {
    symbol_ascii[[name]]
  } else {
    symbol[[name]]
  }
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/format.R"

#' Format a value for printing
#'
#' This function can be used directly, or via the `{.val ...}` inline
#' style. `{.val {expr}}` calls `cli_format()` automatically on the value
#' of `expr`, before styling and collapsing it.
#'
#' ## Default style
#'
#' ```{asciicast cli-format-default}
#' months <- month.name[1:3]
#' cli_text("{.val {months}}")
#' ```
#'
#' ```{asciicast cli-format-num}
#' nums <- 1:5 / 7
#' cli_text("{.val {nums}}")
#' ```
#'
#' ## Styling with themes
#'
#' ```{asciicast cli-format-theme}
#' nums <- 1:5 / 7
#' divid <- cli_div(theme = list(.val = list(digits = 3)))
#' cli_text("{.val {nums}}")
#' cli_end(divid)
#' ```
#'
#' It is possible to define new S3 methods for `cli_format` and then
#' these will be used automatically for `{.val ...}` expressions.
#'
#' ```{asciicast cli-format-class}
#' cli_format.month <- function(x, style = NULL, ...) {
#'   x <- encodeString(substr(x, 1, 3), quote = "\"")
#'   NextMethod("cli_format")
#' }
#' registerS3method("cli_format", "month", cli_format.month)
#' months <- structure(month.name[1:3], class = "month")
#' cli_text("{.val {months}}")
#' ```
#'
#' @param x The object to format.
#' @param style List of formatting options, see the individual methods
#'   for the style options they support.
#' @param ... Additional arguments for methods.
#'
#' @export
#' @seealso [cli_vec()]

cli_format <- function(x, style = NULL, ...) {
  if (is.null(style) && !is.null(default_app())) {
    style <- default_app()$get_current_style()
    cli_format(x, style, ...)
  } else {
    UseMethod("cli_format")
  }
}

#' @rdname cli_format
#' @export

cli_format.default <- function(x, style = NULL, ...) {
  x
}

#' * Styles for character vectors:
#'   - `string-quote` is the quoting character for [encodeString()].
#'
#' @rdname cli_format
#' @export

cli_format.character <- function(x, style = NULL, ...) {
  quote <- style$`string-quote` %||% style$string_quote %||% "\""
  encodeString(x, quote = quote)
}

#' * Styles for numeric vectors:
#'   - `digits` is the number of digits to print after the decimal point.
#'
#' @rdname cli_format
#' @export

cli_format.numeric <- function(x, style = NULL, ...) {
  digits <- style$digits
  if (!is.null(digits)) x <- round(x, digits)
  x
}

#' Add custom cli style to a vector
#'
#' @details
#' You can use this function to change the default parameters of
#' collapsing the vector into a string, see an example below.
#'
#' The style is added as an attribute, so operations that remove
#' attributes will remove the style as well.
#'
#' ## Custom collapsing separator
#'
#' ```{asciicast cli-vec}
#' v <- cli_vec(
#'   c("foo", "bar", "foobar"),
#'   style = list("vec-sep" = " & ", "vec-last" = " & ")
#' )
#' cli_text("My list: {v}.")
#' ```
#'
#' ## Custom truncation
#'
#' ```{asciicast cli-vec-2}
#' x <- cli_vec(names(mtcars), list("vec-trunc" = 3))
#' cli_text("Column names: {x}.")
#' ```
#'
#' @param x Vector that will be collapsed by cli.
#' @param style Style to apply to the vector. It is used as a theme on
#' a `span` element that is created for the vector. You can set `vec-sep`,
#' `vec-sep2`, and `vec-last` to modify the general separator,
#' the 2-item separator, and the last separator.
#'
#' @export
#' @seealso [cli_format()]

cli_vec <- function(x, style = list()) {
  attr(x, "cli_style") <- style
  x
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/friendly-type.R"

# This is based on rlang:::obj_type_friendly, but adapted to cli

friendly_type <- local({

friendly_type <- function(x, value = TRUE, length = FALSE) {
  if (is_missing(x)) {
    return("absent")
  }

  if (is.object(x)) {
    if (inherits(x, "quosure")) {
      return("a {.cls quosure} object")
    } else if (identical(class(x), "data.frame")) {
      return("a data frame")
    } else if (identical(class(x), c("tbl_df", "tbl", "data.frame"))) {
      return("a tibble")
    } else {
      # this is sometimes wrong for 'h', but ce la vie
      fst <- tolower(substr(class(x)[1], 1, 1))
      prop <- if (fst %in% c("a", "e", "i", "o", "u")) {
        "an"
      } else {
        "a"
      }
      return(paste0(prop, " {.cls {class(x)[1]}} object"))
    }
  }

  if (!is_vector(x)) {
    return(as_friendly_type(typeof(x)))
  }

  n_dim <- length(dim(x))

  if (value && !n_dim) {
    if (is_na(x)) {
      return(switch(
        typeof(x),
        logical = "{.code NA}",
        integer = "an integer {.code NA}",
        double = "a numeric {.code NA}",
        complex = "a complex {.code NA}",
        character = "a character {.code NA}",
        typeof(x)
      ))
    }
    if (length(x) == 1 && !is_list(x)) {
      return(switch(
        typeof(x),
        logical = if (x) "{.code TRUE}" else "{.code FALSE}",
        integer = "an integer",
        double = "a number",
        complex = "a complex number",
        character = if (nzchar(x)) "a string" else "{.code \"\"}",
        raw = "a raw value",
        sprintf("a %s value", typeof(x))
      ))
    }
    if (length(x) == 0) {
      return(switch(
        typeof(x),
        logical = "an empty logical vector",
        integer = "an empty integer vector",
        double = "an empty numeric vector",
        complex = "an empty complex vector",
        character = "an empty character vector",
        raw = "an empty raw vector",
        list = "an empty list",
        sprintf("a %s of length one", typeof(x))
      ))
    }
  }

  type <- friendly_vector_type(typeof(x), n_dim)

  if (length && !n_dim) {
    type <- paste0(type, sprintf(" of length %s", length(x)))
  }

  type
}

friendly_vector_type <- function(type, n_dim) {
  if (type == "list") {
    if (n_dim < 2) {
      return("a list")
    } else if (n_dim == 2) {
      return("a list matrix")
    } else {
      return("a list array")
    }
  }

  type <- switch(
    type,
    logical = "a logical %s",
    integer = "an integer %s",
    numeric = ,
    double = "a double %s",
    complex = "a complex %s",
    character = "a character %s",
    raw = "a raw %s",
    type = paste0("a ", type, " %s")
  )

  if (n_dim < 2) {
    kind <- "vector"
  } else if (n_dim == 2) {
    kind <- "matrix"
  } else {
    kind <- "array"
  }
  sprintf(type, kind)
}

as_friendly_type <- function(type) {
  switch(
    type,

    list = "a list",

    NULL = "NULL",
    environment = "an environment",
    externalptr = "a pointer",
    weakref = "a weak reference",
    S4 = "an S4 object",

    name = ,
    symbol = "a symbol",
    language = "a call",
    pairlist = "a pairlist node",
    expression = "an expression vector",

    char = "an internal string",
    promise = "an internal promise",
    ... = "an internal dots object",
    any = "an internal {.code any} object",
    bytecode = "an internal bytecode object",

    primitive = ,
    builtin = ,
    special = "a primitive function",
    closure = "a function",

    type
  )
}

is_missing <- function(x) {
  missing(x) || identical(x, quote(expr = ))
}

is_vector <- function(x) {
  t <- typeof(x)
  t %in% c(
    "logical",
    "integer",
    "double",
    "complex",
    "character",
    "raw",
    "list"
  )
}

is_scalar_vector <- function(x) {
  is_vector(x) && length(x) == 1L
}

is_na <- function(x) {
  is_scalar_vector(x) && is.na(x)
}

is_list <- function(x) {
  typeof(x) == "list"
}

list(
  .internal = environment(),
  friendly_type = friendly_type
)

})

typename <- friendly_type$friendly_type
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/glue.R"

# Compared to glue::glue(), these are fixed:
# - .sep = ""
# - .trim = TRUE
# - .null = character()
# - .literal = TRUE
# - .comment = ""
#
# we also don't allow passing in data as arguments, and `text` is
# a single argument, no need to `paste()` etc.

glue <- function(text, .envir = parent.frame(),
                 .transformer = identity_transformer,
                 .open = "{", .close = "}", .cli = FALSE, .trim = TRUE) {

  text <- paste0(text, collapse = "")

  if (length(text) < 1L) {
    return(text)
  }

  if (is.na(text)) {
    return(text)
  }

  if (.trim) {
    text <- trim(text)
  }

  f <- function(expr) {
    eval_func <- as.character(.transformer(expr, .envir) %||% character())
  }

  res <- .Call(glue_, text, f, .open, .close, .cli)

  res <- drop_null(res)
  if (any(lengths(res) == 0L)) {
    return(character(0L))
  }

  res[] <- lapply(res, function(x) replace(x, is.na(x), "NA"))

  do.call(paste0, res)
}

count_brace_exp <- function(text, .open = "{", .close = "}") {
  cnt <- 0L
  trans <- function(text, envir) {
    cnt <<- cnt + 1L
    ""
  }
  glue(text, .transformer = trans, .open = .open, .close = .close)
  cnt
}

identity_transformer <- function(text, envir) {
  eval(parse(text = text, keep.source = FALSE), envir)
}

drop_null <- function(x) {
  x[!vapply(x, is.null, logical(1L))]
}

#' Collapse a vector into a string scalar
#'
#' @description
#' Features:
#'
#' - custom separator (`sep`),
#' - custom separator for length-two input (`sep2`),
#' - custom last separator (`last`),
#' - adds ellipsis to truncated strings,
#' - uses Unicode ellipsis character on UTF-8 console,
#' - can collapse "from both ends", with `style = "both-ends"`,
#' - can consider a limit for the display width of the result, in characters,
#' - handles ANSI control sequences correctly when measuring display width.
#'
#' @param x Character vector, or an object with an `as.character()` method
#' to collapse.
#' @param sep Separator. A character string.
#' @param sep2 Separator for the special case that `x` contains only two
#' elements. A character string. Defaults to the value of `last` without the
#' serial comma.
#' @param last Last separator, if there is no truncation. E.g. use
#' `", and "` for the [serial
#' comma](https://en.wikipedia.org/wiki/Serial_comma). A character string.
#' @param trunc Maximum number of elements to show. For `style = "head"`
#' at least `trunc = 1` is used. For `style = "both-ends"` at least
#' `trunc = 5` is used, even if a smaller number is specified.
#' @param width Limit for the display width of the result, in characters.
#' This is a hard limit, and the output will never exceed it.
#' This argument is not implemented for the `"both-ends"` style, which
#' always uses `Inf`, with a warning if a finite `width` value is set.
#' @param ellipsis Character string to use at the place of the truncation.
#' By default, the Unicode ellipsis character is used if the console is
#' UTF-8, and three dots otherwise.
#' @param style Truncation style:
#' * `both-ends`: the default, shows the beginning and end of the vector,
#'   and skips elements in the middle if needed.
#' * `head`: shows the beginning of the vector, and skips elements at the
#'   end, if needed.
#' @return Character scalar. It is `NA_character_` if any elements in `x`
#' are `NA`.
#'
#' @seealso `glue_collapse` in the glue package inspired this function.
#' @export
#' @examples
#' ansi_collapse(letters)
#'
#' # truncate
#' ansi_collapse(letters, trunc = 5)
#'
#' # head style
#' ansi_collapse(letters, trunc = 5, style = "head")

ansi_collapse <- function(x, sep = ", ", sep2 = sub("^,", "", last), last = ", and ",
                          trunc = Inf, width = Inf, ellipsis = symbol$ellipsis,
                          style = c("both-ends", "head")) {

  style <- match.arg(style)
  switch(
    style,
    "both-ends" = collapse_both_ends(
      x, sep, sep2, last, trunc, width, ellipsis
    ),
    "head" = collapse_head(x, sep, sep2, last, trunc, width, ellipsis)
  )
}

collapse_head_notrim <- function(x, trunc, sep, sep2, last, ellipsis) {

  lnx <- length(x)

  if (lnx == 1L) return(x)
  if (lnx == 2L) return(paste0(x, collapse = sep2))
  if (lnx <= trunc) {
    # no truncation
    return(paste0(
      paste(x[1:(lnx - 1L)], collapse = sep),
      last,
      x[lnx]
    ))
  } else {
    # truncation, no need for 'last'
    return(paste0(
      paste(x[1:trunc], collapse = sep),
      sep,
      ellipsis
    ))
  }
}

collapse_head <- function(x, sep, sep2, last, trunc, width, ellipsis) {

  trunc <- max(trunc, 1L)
  x <- as.character(x)
  lnx <- length(x)

  # special cases that do not need trimming
  if (lnx == 0L) {
    return("")
  } else if (anyNA(x)) {
    return(NA_character_)
  }

  # easier case, no width trimming
  if (width == Inf) {
    return(collapse_head_notrim(x, trunc, sep, sep2, last, ellipsis))
  }

  # complex case, with width wrapping
  # first we truncate
  tcd <- lnx > trunc
  if (tcd) x <- x[1:trunc]

  # then we calculate the width w/o trimming
  wx    <- ansi_nchar(x)
  wsep  <- ansi_nchar(sep, "width")
  wsep2 <- ansi_nchar(sep2, "width")
  wlast <- ansi_nchar(last, "width")
  well  <- ansi_nchar(ellipsis, "width")
  if (!tcd) {
    # x[1]
    # x[1] and x[2]
    # x[1], x[2], and x[3]
    nsep  <- if (lnx > 2L) lnx - 2L else 0L
    nsep2 <- if (lnx == 2L) 1L else 0L
    nlast <- if (lnx > 2L) 1L else 0L
    wtot  <- sum(wx) + nsep * wsep + nsep2 * wsep2 + nlast * wlast
    if (wtot <= width) {
      if (lnx == 1L) {
        return(x)
      } else if (lnx == 2L) {
        return(paste0(x, collapse = sep2))
      } else {
        return(paste0(
          paste(x[1:(lnx - 1L)], collapse = sep),
          last,
          x[lnx]
        ))
      }
    }

  } else {
    # x[1], x[2], x[trunc], ...
    wtot <- sum(wx) + trunc * wsep + well
    if (wtot <= width) {
      return(paste0(
        paste(x, collapse = sep),
        sep,
        ellipsis
      ))
    }
  }

  # we need to find the longest possible truncation for the form
  # x[1], x[2], x[trunc], ...
  # each item is wx + wsep wide, so we search how many fits, with ellipsis
  last <- function(x) if (length(x) >= 1L) x[length(x)] else x[NA_integer_]
  trunc <- last(which(cumsum(wx + wsep) + well <= width))

  # not even one element fits
  if (is.na(trunc)) {
    if (well > width) {
      return(ansi_strtrim(ellipsis, width, ellipsis = ""))
    } else if (well == width) {
      return(ellipsis)
    } else if (well + wsep >= width) {
      return(paste0(ansi_strtrim(x[1L], width, ellipsis = ""), ellipsis))
    } else {
      return(paste0(
        ansi_strtrim(x[1L], max(width - well - wsep, 0L), ellipsis = ellipsis),
        sep,
        ellipsis
      ))
    }
  }

  return(paste0(
    paste(x[1:trunc], collapse = sep),
    sep,
    ellipsis
  ))
}

collapse_both_ends <- function(x, sep, sep2, last, trunc, width, ellipsis) {

  if (width != Inf) {
    warning(format_warning(c(
      "!" = "finite {.arg width} is not implemented in {.fun cli::ansi_collapse}.",
      "i" = "{.code width = Inf} is used instead."
    )))
    width <- Inf
  }

  # we always list at least 5 elements
  trunc <- max(trunc, 5L)
  trunc <- min(trunc, length(x))
  if (length(x) <= 5L || length(x) <= trunc) {
    return(collapse_head(x, sep, sep2, last, trunc = trunc, width, ellipsis))
  }

  # we have at least six elements in the vector
  # 1, 2, 3, ..., 9, and 10
  x <- as.character(c(x[1:(trunc - 2L)], x[length(x) - 1L], x[length(x)]))
  paste0(
    c(x[1:(trunc - 2L)], ellipsis, paste0(x[trunc - 1L], last, x[trunc])),
    collapse = sep
  )
}

trim <- function(x) {
  has_newline <- function(x) any(grepl("\\n", x))
  if (length(x) == 0L || !has_newline(x)) {
    return(x)
  }
  .Call(trim_, x)
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/hash.R"

#' SHA-256 hash
#'
#' Calculate the SHA-256 hash of each element of a character vector.
#'
#' @param x Character vector. If not a character vector, then
#' [as.character()] is used to try to coerce it into one. `NA` entries
#' will have an `NA` hash.
#' @return `hash_sha256()` returns a character vector of hexadecimal
#' SHA-256 hashes.

#' @family hash functions
#'
#' @export
#' @examples
#' hash_sha256(c("foo", NA, "bar", ""))

hash_sha256 <- function(x) {
  if (!is.character(x)) x <- as.character(x)
  na <- is.na(x)
  x[na] <- NA_character_
  x[!na] <- .Call(clic_sha256, x[!na])
  x
}

#' @export
#' @rdname hash_sha256
#' @details `hash_raw_sha256()` calculates the SHA-256 hash of the bytes
#' of a raw vector.
#'
#' @return `hash_raw_sha256()` returns a character scalar.

hash_raw_sha256 <- function(x) {
  stopifnot(is.raw(x))
  .Call(clic_sha256_raw, x)
}

#' @export
#' @rdname hash_sha256
#' @param serialize_version Workspace format version to use, see
#' [base::serialize()].
#' @details `hash_obj_sha256()` calculates the SHA-256 hash of an R
#' object. The object is serialized into a binary vector first.
#'
#' @return `hash_obj_sha256()` returns a character scalar.

hash_obj_sha256 <- function(x, serialize_version = 2) {
  sr <- serialize(x, NULL, version = serialize_version)[-(1:14)]
  hash_raw_sha256(sr)
}

#' @export
#' @rdname hash_sha256
#' @param paths Character vector of file names.
#' @details `hash_file_sha256()` calculates the SHA-256 hash of one or
#' more files.
#'
#' @return `hash_file_sha256()` returns a character vector of SHA-256
#' hashes.

hash_file_sha256 <- function(paths) {
  if (!is.character(paths)) paths <- as.character(paths)
  paths <- normalizePath(paths, mustWork = FALSE)
  if (is_windows()) {
    paths <- enc2utf8(paths)
  } else {
    paths <- enc2native(paths)
  }
  .Call(clic_sha256_file, paths)
}

#' SHA-1 hash
#'
#' Calculate the SHA-1 hash of each element of a character vector.
#'
#' @param x Character vector. If not a character vector, then
#' [as.character()] is used to try to coerce it into one. `NA` entries
#' will have an `NA` hash.
#' @return `hash_sha1()` returns a character vector of hexadecimal
#' SHA-1 hashes.

#' @family hash functions
#'
#' @export
#' @examples
#' hash_sha1(c("foo", NA, "bar", ""))

hash_sha1 <- function(x) {
  if (!is.character(x)) x <- as.character(x)
  na <- is.na(x)
  x[na] <- NA_character_
  x[!na] <- .Call(clic_sha1, x[!na])
  x
}

#' @export
#' @rdname hash_sha1
#' @details `hash_raw_sha1()` calculates the SHA-1 hash of the bytes
#' of a raw vector.
#'
#' @return `hash_raw_sha1()` returns a character scalar.

hash_raw_sha1 <- function(x) {
  stopifnot(is.raw(x))
  .Call(clic_sha1_raw, x)
}

#' @export
#' @rdname hash_sha1
#' @param serialize_version Workspace format version to use, see
#' [base::serialize()].
#' @details `hash_obj_sha1()` calculates the SHA-1 hash of an R
#' object. The object is serialized into a binary vector first.
#'
#' @return `hash_obj_sha1()` returns a character scalar.

hash_obj_sha1 <- function(x, serialize_version = 2) {
  sr <- serialize(x, NULL, version = serialize_version)[-(1:14)]
  hash_raw_sha1(sr)
}

#' @export
#' @rdname hash_sha1
#' @param paths Character vector of file names.
#' @details `hash_file_sha1()` calculates the SHA-1 hash of one or
#' more files.
#'
#' @return `hash_file_sha1()` returns a character vector of SHA-1
#' hashes.

hash_file_sha1 <- function(paths) {
  if (!is.character(paths)) paths <- as.character(paths)
  paths <- normalizePath(paths, mustWork = FALSE)
  if (is_windows()) {
    paths <- enc2utf8(paths)
  } else {
    paths <- enc2native(paths)
  }
  .Call(clic_sha1_file, paths)
}

#' MD5 hash
#'
#' Calculate the MD5 hash of each element of a character vector.
#'
#' @param x Character vector. If not a character vector, then
#' [as.character()] is used to try to coerce it into one. `NA` entries
#' will have an `NA` hash.
#' @return `hash_md5()` returns a character vector of hexadecimal MD5
#' hashes.
#'
#' @family hash functions
#' @seealso [tools::md5sum()] for a base R MD5 function that works on
#' files.
#'
#' @export
#' @examples
#' hash_md5(c("foo", NA, "bar", ""))

hash_md5 <- function(x) {
  if (!is.character(x)) x <- as.character(x)
  na <- is.na(x)
  x[na] <- NA_character_
  x[!na] <- .Call(clic_md5, x[!na])
  x
}

#' @export
#' @rdname hash_md5
#' @details `hash_raw_md5()` calculates the MD5 hash of the bytes
#' of a raw vector.
#'
#' @return `hash_raw_md5()` returns a character scalar.

hash_raw_md5 <- function(x) {
  stopifnot(is.raw(x))
  .Call(clic_md5_raw, x)
}

#' @export
#' @rdname hash_md5
#' @param serialize_version Workspace format version to use, see
#' [base::serialize()].
#' @details `hash_obj_md5()` calculates the MD5 hash of an R
#' object. The object is serialized into a binary vector first.
#'
#' @return `hash_obj_md5()` returns a character scalar.

hash_obj_md5 <- function(x, serialize_version = 2) {
  sr <- serialize(x, NULL, version = serialize_version)[-(1:14)]
  hash_raw_md5(sr)
}

#' @export
#' @rdname hash_md5
#' @param paths Character vector of file names.
#' @details `hash_file_md5()` calculates the MD5 hash of one or more
#' files.

hash_file_md5 <- function(paths) {
  if (!is.character(paths)) paths <- as.character(paths)
  paths <- normalizePath(paths, mustWork = FALSE)
  if (is_windows()) {
    paths <- enc2utf8(paths)
  } else {
    paths <- enc2native(paths)
  }
  .Call(clic_md5_file, paths)
}

#' Emoji hash
#'
#' @details
#' It uses the first 13 hexadecimal characters (out of the 32) of the MD5
#' hash of the input, and converts them into an emoji representation.
#' It uses a manually selected subset of all emojis, that tend to be
#' displayed correctly.
#'
#' ## Number of possible hash values
#'
#' ```{r include = FALSE}
#' hf <- function(size) {
#'   format(nrow(emojis)**size, big.mark = ",", scientific = FALSE)
#' }
#' ```
#'
#' cli uses `r nrow(emojis)` possible emojis. This is the number of
#' different hashes you can get for different values of `size`:
#'
#' | `size` | size of hash table space |
#' | -----: | -----------------------: |
#' | 1      | `r hf(1)`                |
#' | 2      | `r hf(2)`                |
#' | 3      | `r hf(3)`                |
#' | 4      | `r hf(4)`                |
#'
#' @param x Character vector. `NA` entries will have an `NA` hash.
#' @param size Number of emojis to use in a hash. Currently it has to
#'   be from 1 through 4.
#' @return `hash_emoji()` returns a data frame with columns
#'   * `hash`: the emoji hash, a string of the requested size.
#'   * `emojis`: list column with the emoji characters in character
#'     vectors. Note that an emoji might have multiple code points.
#'   * `text`: text representation of `hash`, comma separated.
#'   * `names`: list column with the text representations of `emojis`, in
#'     character vectors.
#'
#' @family hash functions
#' @seealso the emoji package for a comprehensive list of emojis
#' @export
#' @examples
#' hash_emoji(c("foo", NA, "bar", ""))$text
#'
#' # if you increase `size`, the shorter hash is a prefix of the longer:
#' hash_emoji("foobar", 1)$text
#' hash_emoji("foobar", 2)$text
#' hash_emoji("foobar", 3)$text
#' hash_emoji("foobar", 4)$text

hash_emoji <- function(x, size = 3) {
  # our integer arithmetic does not work if size > 4
  if (!is.character(x)) x <- as.character(x)
  stopifnot(
    is.character(x),
    is_count(size),
    size >= 1 && size <= 4
  )

  hashes <- lapply(x, hash_emoji1, size = size)
  emojis <- lapply(hashes, "[[", "emoji")
  names <- lapply(hashes, "[[", "names")

  data.frame(
    stringsAsFactors = FALSE,
    hash = vapply(emojis, hash_collapse, character(1)),
    emojis = I(emojis),
    text = vapply(names, hash_collapse, character(1), sep = ", "),
    names = I(names)
  )
}

hash_collapse <- function(x, sep = "") {
  if (anyNA(x)) {
    NA_character_
  } else {
    paste(x, collapse = sep)
  }
}

hash_emoji1 <- function(x, size = 3) {
  if (is.na(x)) {
    return(list(
      emoji = rep(NA_character_, size),
      names = rep(NA_character_, size)
    ))
  }

  md5 <- hash_md5(x)
  hash_emoji1_transform(md5, size)
}

hash_emoji1_transform <- function(md5, size) {
  md513 <- substr(md5, 1, 13)
  mdint <- as.integer(as.hexmode(strsplit(md513, "", fixed = TRUE)[[1]]))
  hash <- sum(mdint * 16^(0:12))

  base <- nrow(emojis)
  ehash <- hash %% (base ** size)
  digits <- integer()
  while (ehash > 0) {
    digits <-  c(digits, ehash %% base)
    ehash <- ehash %/% base
  }
  digits <- c(digits, rep(0, 10))[1:size]

  nms <- emojis$name[digits + 1]
  emo <- emojis$emoji[digits + 1]

  list(
    emoji = emo,
    names = nms
  )
}

#' @export
#' @rdname hash_emoji
#' @details `hash_raw_emoji()` calculates the emoji hash of the bytes
#' of a raw vector.
#'
#' @return `hash_raw_emoji()` and `hash_obj_emoji()` return a list with
#' entries:
#' * `hash`: the emoji hash, a string of requested size,
#' * `emojis`: the individual emoji characters in a character vector,
#' * `text`: text representation of `hash`, comma separated,
#' * `names`: names of the emojis, in a character vector.

hash_raw_emoji <- function(x, size = 3) {
  stopifnot(is.raw(x))
  md5 <- hash_raw_md5(x)
  emo <- hash_emoji1_transform(md5, size)

  list(
    hash = hash_collapse(emo$emoji),
    emojis = emo$emoji,
    text = hash_collapse(emo$emoji, sep = ", "),
    names = emo$names
  )
}

#' @export
#' @rdname hash_emoji
#' @param serialize_version Workspace format version to use, see
#' [base::serialize()].
#' @details `hash_obj_emoji()` calculates the emoji hash of an R
#' object. The object is serialized into a binary vector first.

hash_obj_emoji <- function(x, size = 3, serialize_version = 2) {
  sr <- serialize(x, NULL, version = serialize_version)[-(1:14)]
  hash_raw_emoji(sr, size = size)
}

#' Adjective-animal hash
#'
#' @details
#' It uses the first 13 hexadecimal characters (out of the 32) of the MD5
#' hash of the input, and converts them into an adjective-animal form to
#' create a human readable hash.
#'
#' ## Number of possible hash values
#'
#' ```{r include = FALSE}
#' hf <- function(n_adj) {
#'   format(
#'     length(gfycat_adjectives) ** n_adj * length(gfycat_animals),
#'     big.mark = ",",
#'     scientific = FALSE
#'   )
#' }
#' ```
#'
#' `hash_animal()` uses `r length(gfycat_animals)` animal names and
#' `r length(gfycat_adjectives)` different adjectives. The number of
#' different hashes you can get for different values of `n_adj`:
#'
#' | `n_adj` | size of the hash table space |
#' | ------: | ---------------------------: |
#' | 0       | `r hf(0)`                    |
#' | 1       | `r hf(1)`                    |
#' | 2       | `r hf(2)`                    |
#' | 3       | `r hf(3)`                    |
#'
#' ## Source
#'
#' The list of adjectives and animals comes from the ids package,
#' and in turn from
#' <https://github.com/a-type/adjective-adjective-animal>, and
#' from `https://gfycat.com` (now gone).
#'
#' @param x Character vector. `NA` entries will have an `NA` hash.
#' @param n_adj Number of adjectives to use. It must be from 0 through 3.
#' @return A data frame with columns
#'   * `hash`: the hash value, a string.
#'   * `words`: list column with the adjectives and the animal name in a
#'     character vector.
#'
#' @family hash functions
#' @seealso the ids package for generating random adjective-animal ids
#'
#' @export
#' @examples
#' hash_animal(c("foo", "bar"))
#'
#' # if you increase `n_adj`, the shorter hash is a suffix of the longer:
#' hash_animal("cli package", 0)$hash
#' hash_animal("cli package", 1)$hash
#' hash_animal("cli package", 2)$hash
#' hash_animal("cli package", 3)$hash

hash_animal <- function(x, n_adj = 2) {
  if (!is.character(x)) x <- as.character(x)
  stopifnot(
    is.character(x),
    is_count(n_adj),
    n_adj >= 0 && n_adj <= 3
  )

  hashes <- lapply(x, hash_animal1, n_adj = n_adj)

  data.frame(
    stringsAsFactors = FALSE,
    hash = vapply(hashes, hash_collapse, character(1), sep = " "),
    words = I(hashes)
  )
}

hash_animal1 <- function(x, n_adj = 2) {
  if (is.na(x)) {
    return(rep(NA_character_, n_adj + 1))
  }

  md5 <- hash_md5(x)
  hash_animal1_transform(md5, n_adj)
}

hash_animal1_transform <- function(md5, n_adj) {
  md513 <- substr(md5, 1, 13)
  mdint <- as.integer(as.hexmode(strsplit(md513, "", fixed = TRUE)[[1]]))
  hash <- sum(mdint * 16^(0:12))

  len_ani <- length(gfycat_animals)
  len_adj <- length(gfycat_adjectives)
  ehash <- hash %% (len_adj ** n_adj * len_ani)
  digits <- ehash %% len_ani
  ehash <- ehash %/% len_ani

  while (ehash > 0) {
    digits <- c(digits, ehash %% len_adj)
    ehash <- ehash %/% len_adj
  }
  digits <- c(digits, rep(0, 10))[1:(n_adj + 1)]
  digits <- rev(digits)

  c(
    gfycat_adjectives[digits[-length(digits)] + 1],
    gfycat_animals[digits[length(digits)] + 1]
  )
}

#' @export
#' @rdname hash_animal
#' @details `hash_raw_animal()` calculates the adjective-animal hash of
#' the bytes of a raw vector.
#'
#' @return `hash_raw_animal()` and `hash_obj_animal()` return a list
#' with entries:
#' * `hash`: the hash value, a string,
#' * `words: the adjectives and the animal name in a character vector.

hash_raw_animal <- function(x, n_adj = 2) {
  stopifnot(is.raw(x))
  md5 <- hash_raw_md5(x)
  hash <- hash_animal1_transform(md5, n_adj)

  list(
    hash = hash_collapse(hash, sep = ", "),
    words = hash
  )
}

#' @export
#' @rdname hash_animal
#' @param serialize_version Workspace format version to use, see
#' [base::serialize()].
#' @details `hash_obj_animal()` calculates the adjective-animal hash of
#' an R object. The object is serialized into a binary vector first.

hash_obj_animal <- function(x, n_adj = 2, serialize_version = 2) {
  sr <- serialize(x, NULL, version = serialize_version)[-(1:14)]
  hash_raw_animal(sr, n_adj = n_adj)
}

#' xxHash
#'
#' Extremely fast hash algorithm.
#'
#' @param x Character vector. If not a character vector, then
#' [as.character()] is used to try to coerce it into one. `NA` entries
#' will have an `NA` hash.
#' @return `hash_xxhash()` returns a character vector of hexadecimal
#' xxHash hashes.
#'
#' @family hash functions
#'
#' @export
#' @examples
#' hash_xxhash(c("foo", NA, "bar", ""))

hash_xxhash <- function(x) {
  if (!is.character(x)) x <- as.character(x)
  na <- is.na(x)
  x[na] <- NA_character_
  x[!na] <- .Call(clic_xxhash, x[!na])
  x
}

#' @export
#' @rdname hash_xxhash
#' @details `hash_raw_xxhash()` calculates the xxHash hash of the bytes
#' of a raw vector.
#' @return `hash_raw_xxhash()` returns a character scalar.

hash_raw_xxhash <- function(x) {
  stopifnot(is.raw(x))
  .Call(clic_xxhash_raw, x)
}

#' @export
#' @rdname hash_xxhash
#' @param serialize_version Workspace format version to use, see
#' [base::serialize()].
#' @details `hash_obj_xxhash()` calculates the xxHash hash of an R
#' object. The object is serialized into a binary vector first.
#' @return `hash_obj_xxhash()` returns a character scalar.

hash_obj_xxhash <- function(x, serialize_version = 2) {
  sr <- serialize(x, NULL, version = serialize_version)[-(1:14)]
  hash_raw_xxhash(sr)
}

#' @export
#' @rdname hash_xxhash
#' @param paths Character vector of file names.
#' @details `hash_file_xxhash()` calculates the xxHash hash of one or
#' more files.
#'
#' @return `hash_file_xxhash()` returns a character vector of xxHash
#' hashes.

hash_file_xxhash <- function(paths) {
  if (!is.character(paths)) paths <- as.character(paths)
  paths <- normalizePath(paths, mustWork = FALSE)
  if (is_windows()) {
    paths <- enc2utf8(paths)
  } else {
    paths <- enc2native(paths)
  }
  .Call(clic_xxhash_file, paths)
}

#' @export
#' @rdname hash_xxhash
#' @details The `64` functions caculate the 64 bit variant
#' of xxHash. Otherwise they work the same.

hash_xxhash64 <- function(x) {
  if (!is.character(x)) x <- as.character(x)
  na <- is.na(x)
  x[na] <- NA_character_
  x[!na] <- .Call(clic_xxhash64, x[!na])
  x
}

#' @export
#' @rdname hash_xxhash

hash_raw_xxhash64 <- function(x) {
  stopifnot(is.raw(x))
  .Call(clic_xxhash64_raw, x)
}

#' @export
#' @rdname hash_xxhash

hash_obj_xxhash64 <- function(x, serialize_version = 2) {
  sr <- serialize(x, NULL, version = serialize_version)[-(1:14)]
  hash_raw_xxhash64(sr)
}

#' @export
#' @rdname hash_xxhash

hash_file_xxhash64 <- function(paths) {
  if (!is.character(paths)) paths <- as.character(paths)
  paths <- normalizePath(paths, mustWork = FALSE)
  if (is_windows()) {
    paths <- enc2utf8(paths)
  } else {
    paths <- enc2native(paths)
  }
  .Call(clic_xxhash64_file, paths)
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/inline.R"

if (getRversion() >= "2.15.1") utils::globalVariables("app")

inline_generic <- function(app, x, style) {

  if (is.character(x) && any(grepl("\n", x))) {
    if (getOption("cli.warn_inline_newlines", FALSE)) {
      warning("cli replaced newlines within {. ... } with spaces")
    }
    x <- gsub_("\n", " ", x, useBytes = TRUE, fixed = TRUE)
  }

  before <- call_if_fun(style$before)
  after <- call_if_fun(style$after)
  transform <- style$transform
  if (is.function(transform)) {
    if (length(formals(transform)) == 1) {
      x <- transform(x)
    } else {
      x <- transform(x, app = app, style = style)
    }
  }
  collapse <- style$collapse
  if (is.character(collapse)) {
    x <- paste0(x, collapse = collapse[1])
  }
  if (is.function(collapse)) {
    x <- collapse(x)
  }
  xx <- paste0(before, x, after)
  fmt <- style$fmt
  if (!is.null(fmt) && is.function(fmt)) {
    if (length(formals(fmt)) == 1) {
      xx <- vcapply(xx, fmt)
    } else {
      xx <- vcapply(xx, fmt, app = app, style = style)
    }
  }
  prefix <- call_if_fun(style$prefix)
  postfix <- call_if_fun(style$postfix)

  paste0(prefix, xx, postfix)
}

inline_collapse <- function(x, style = list()) {
  last <- style[["vec-last"]] %||% style[["vec_last"]] %||% ", and "
  sep <- style[["vec-sep"]] %||% style[["vec_sep"]] %||% ", "
  sep2 <- style[["vec-sep2"]] %||% style[["vec_sep2"]] %||% sub("^,", "", last)

  trunc <- style[["vec-trunc"]] %||% style[["vec_trunc"]] %||% 20L
  col_style <- style[["vec-trunc-style"]] %||% "both-ends"

  ansi_collapse(
    x,
    sep = sep,
    sep2 = sep2,
    last = last,
    trunc = trunc,
    style = col_style
  )
}

#' This glue transformer performs the inline styling of cli
#'
#' The two rules are the following:
#' * If `code` is a class expression (i.e. it starts with a dot),
#'   then we open a `<span>` with the right class and recurse.
#' * If `code` is not a class expression (i.e. it does not start with a
#'   dor), then we collapse vectors.
#'
#' The rest of the work is about:
#' * Making sure that the outside container's non-inherited style is _not_
#'   applied to the substitution. E.g. in
#'   ```r
#'   cli_h2("This is heading number {n}")
#'   ```
#'   The `before` and `after`, etc. style attributes should not be applied
#'   to `{n}`.
#' * While making sure that the inlide style's non-interited style is
#'   applied to brace expressions. I.e. in
#'   ```r
#'   cli_text("{.fun {x}}")
#'   ```
#'   every element of `x` should be formatted as a function name.
#' * Adding extra classes from the `class-map` to the right `<span>`.
#' * Adding extra styles from [cli_vec()] to the right `<span>`.
#'
#' A class expression is a brace expression if it is of the form:
#' ```
#' {.class {expr}}
#' ```
#' I.e. `{expr}` must be a single glue substitution which is not a class
#' expression. These are treated differently internally, because they do
#' collapsing, and the styling must be applied before collapsing. For other
#' expressions the styling is applied after collapsing. E.g.
#' ```r
#' cli_text("{.fun {1:3}}")
#' #> `1()`, `2()`, and `3()`
#'
#' cli_text("{.fun f{1}}")
#' #> `f1()`
#' ```
#' In the first case `.fun` is applied to each element of `1:3`, whereas
#' in the second case, the `{1}` (rather trivial) substitution is performed
#' first, and then `.fun` is applied to `"f1"`.
#'
#' See the rest of the comments inline (pun intended).
#'
#' @param code The text inside the `{...}` glue substitution.
#' @param envir Environment with the data to perform the styling.
#'   The actual substituted values have the form `v<x>`, where `<x>` is
#'   a number. The rest of the values are metadata. E.g. the app itself is
#'   added as `envir$app`.
#' @return The substituted and styles text, a character scalar.
#'
#' @noRd

inline_transformer <- function(code, envir) {
  app <- envir$app

  match <- regexpr(inline_regex(), code, perl = TRUE)
  has_style <- match != -1

  if (has_style) {
    # styling
    starts <- attr(match, "capture.start")
    ends <- starts + attr(match, "capture.length") - 1L
    captures <- substring(code, starts, ends)
    funname <- captures[[1]]
    text <- captures[[2]]

    id <- clii__container_start(app, "span", class = funname)
    on.exit(clii__container_end(app, id), add = TRUE)

    # If we don't have a brace expression, then we add another class-less
    # `<span>` here, because this will be the one replaced by the pure
    # substitutions (the other branch of the `if`). This ensures that
    # (non-inherited) styling will _not_ be applied before collapsing them,
    # but only to the whole non-brace expression. We don't need to end this
    # container, because the one above (`id`) will end this one as well.

    braceexp <- grepl("^[<][^.][^}]*[>]$", text) &&
      count_brace_exp(text, .open = "<", .close = ">") == 1
    if (!braceexp) {
      id2 <- clii__container_start(app, "span", class = NULL)
    }

    out <- glue(
      text,
      .envir = envir,
      .transformer = inline_transformer,
      .open = paste0("<", envir$marker),
      .close = paste0(envir$marker, ">")
    )

    # If we don't have a brace expression, then (non-inherited) styling was
    # not applied internally, and we need to apply it now. We also need to
    # end the dummy class-less `<span>` here, so we use the original styled
    # contained (`id`).

    if (!braceexp) {
      clii__container_end(app, id2)
      style <- app$get_current_style()
      out <- inline_generic(app, out, style)
    }

    out

  } else {
    # plain substitution
    expr <- parse(text = code, keep.source = FALSE)
    val <- eval(expr, envir = envir)

    # If we are inside another `<span>`, then we'll "replace" that with a
    # new one, so we can add extra classes (from `class-map`) and styles
    # (from [cli_vec()] to it. Replacing means that we look up the right
    # classes and the id, end the container, and create another one with
    # the same classes (+ from `class_map`), the same id, and potentially
    # the styles from [cli_vec()].
    #
    # If we are not inside another `<span>`, then we'll just add a
    # class-less span, so that the non-inherited styles (e.g. `before`) are
    # not used before collapsing.

    node <- utils::tail(app$doc, 1)[[1]]
    if (node$tag == "span") {
      class <- node$class
      id <- node$id
      clii__container_end(app, id = node$id)
    } else {
      class <- NULL
      id <- NULL
    }

    rcls <- class(val)
    stls <- app$get_current_style()$`class-map`
    cls <- na.omit(match(rcls, names(stls)))[1]
    if (!is.na(cls)) class <- c(class, stls[[cls]])

    vec_style <- attr(val, "cli_style")
    tid <- if (!is.null(vec_style)) {
      app$add_theme(list(span = vec_style))
    }

    id <- clii__container_start(
      app, "span", id = id,
      class = paste(class, collapse = " "), theme = tid
    )
    # We don't need to end the replacement container, that happens upstream.
    if (node$tag != "span") {
      on.exit(clii__container_end(app, id), add = TRUE)
    }

    style <- app$get_current_style()
    inline_collapse(
      inline_generic(app, val, style = style),
      style = style
    )
  }
}

clii__inline <- function(app, text, .list) {
  ## Inject that app, so we can style
  texts <- c(if (!is.null(text)) list(text), .list)
  out <- lapply(texts, function(t) {
    t$values$app <- app
    glue(
      t$str,
      .envir = t$values,
      .transformer = inline_transformer,
      .open = paste0("<", t$values$marker),
      .close = paste0(t$values$marker, ">"),
      .trim = FALSE
    )
  })
  paste(out, collapse = "")
}

inline_regex <- function() "(?s)^[.]([-[:alnum:]_]+)[[:space:]]+(.*)"

make_cmd_transformer <- function(values, .call = NULL) {
  values$marker <- random_id()
  values$qty <- NA_integer_
  values$num_subst <- 0L
  values$postprocess <- FALSE
  values$pmarkers <- list()

  # These are common because of purrr's default argument names, so we
  # hardcode them es exceptions. They are in packages
  # crossmap, crosstable, rstudio.prefs, rxode2, starter.
  # rxode2 has the other ones, and we should fix that in rxode2
  # the function calls are in the oolong packagee, need to fix this as well.
  exceptions <- c(
    ".x", ".y", ".",
    ".md", ".met", ".med", ".mul", ".muR", ".dir", ".muU",
    ".sym_flip(bool_word)", ".sym_flip(bool_topic)", ".sym_flip(bool_wsi)"
  )

  # it is not easy to do better than this, we would need to pass a call
  # down from the exported functions

  caller <- .call %||% sys.call(-1)
  function(code, envir) {
    first_char <- substr(code, 1, 1)

    # {?} pluralization
    if (first_char == "?") {
      parse_plural(code, values)

    # {.} cli style
    } else if (first_char == "." && ! code %in% exceptions) {
      m <- regexpr(inline_regex(), code, perl = TRUE)
      has_match <- m != -1
      if (!has_match) {
        throw(cli_error(
          call. = caller,
          "Invalid cli literal: {.code {{{abbrev(code, 10)}}}} starts with a dot.",
          "i" = "Interpreted literals must not start with a dot in cli >= 3.4.0.",
          "i" = paste("{.code {{}}} expressions starting with a dot are",
                      "now only used for cli styles."),
          "i" = paste("To avoid this error, put a space character after",
                      "the starting {.code {'{'}} or use parentheses:",
                      "{.code {{({abbrev(code, 10)})}}}.")
        ))
      }

      starts <- attr(m, "capture.start")
      ends <- starts + attr(m, "capture.length") - 1L
      captures <- substring(code, starts, ends)
      funname <- captures[[1]]
      text <- captures[[2]]

      out <- glue(
        text,
        .envir = envir,
        .transformer = sys.function(),
        .cli = TRUE
      )
      paste0("<", values$marker, ".", funname, " ", out, values$marker, ">")

    # {} plain substitution
    } else {
      expr <- parse(text = code, keep.source = FALSE) %??%
        cli_error(
          call. = caller,
          "Could not parse cli {.code {{}}} expression:
           {.code {abbrev(code, 20)}}."
        )
      res <- eval(expr, envir = envir) %??%
        cli_error(
          call. = caller,
          "Could not evaluate cli {.code {{}}} expression:
           {.code {abbrev(code, 20)}}."
        )

      id <- paste0("v", length(values))
      values[[id]] <- res
      values$qty <- if (length(res) == 0) 0 else res
      values$num_subst <- values$num_subst + 1L
      paste0("<", values$marker, id, values$marker, ">")
    }
  }
}

glue_cmd <- function(..., .envir, .call = sys.call(-1), .trim = TRUE) {
  str <- paste0(unlist(list(...), use.names = FALSE), collapse = "")
  values <- new.env(parent = emptyenv())
  transformer <- make_cmd_transformer(values, .call = .call)
  pstr <- glue(
    str,
    .envir = .envir,
    .transformer = transformer,
    .cli = TRUE,
    .trim = .trim
  )
  glue_delay(
    str = post_process_plurals(pstr, values),
    values = values
  )
}

glue_no_cmd <- function(...) {
  str <- paste0(unlist(list(...), use.names = FALSE), collapse = "")
  values <-new.env(parent = emptyenv())
  glue_delay(
    str = str,
    values = values
  )
}

glue_delay <- function(str, values = NULL) {
  structure(
    list(str = str, values = values),
    class = "cli_glue_delay"
  )
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/internals.R"

call_if_fun <- function(x) {
  if (is.function(x)) x() else x
}

clii__xtext <- function(app, text, .list, indent, padding, ln = TRUE, wrap = TRUE) {
  style <- app$get_current_style()
  text <- app$inline(text, .list = .list)
  exdent <- style$`text-exdent` %||% 0L

  esc <- function(x) gsub(" ", "\u00a0", x, fixed = TRUE)

  bef <- call_if_fun(style$before)
  if (!is.null(bef)) text[1] <- paste0(esc(bef), text[1])
  aft <- call_if_fun(style$after)
  if (!is.null(aft)) text[length(text)] <- paste0(text[length(text)], esc(aft))

  if (!is.null(style$fmt)) text <- style$fmt(text)

  if (wrap) {
    text <- ansi_strwrap(
      text,
      exdent = exdent,
      width = app$get_width(extra = padding)
    )
  } else {
    text <- ansi_simplify(text)
  }

  app$cat_ln(text, indent = indent, padding)
  invisible(app)
}

clii__get_width <- function(app, extra) {
  style <- app$get_current_style()
  left <- style$`margin-left` %||% 0 + style$`padding-left` %||% 0
  right <- style$`margin-right` %||% 0 + style$`padding-right` %||% 0
  console_width() - left - right - extra
}

clii__cat <- function(app, lines) {
  clii__message(lines, appendLF = FALSE, output = app$output, signal = app$signal)
}

clii__cat_ln <- function(app, lines, indent, padding) {
  if (!is.null(item <- app$state$delayed_item)) {
    app$state$delayed_item <- NULL
    return(app$item_text(item$type, NULL, item$cnt_id, .list = lines))
  }

  style <- app$get_current_style()

  ## left margin
  left <- padding + (style$`margin-left` %||% 0) + (style$`padding-left` %||% 0)
  if (length(lines) && left) lines <- paste0(strrep(" ", left), lines)

  ## indent or negative indent
  if (length(lines)) {
    if (indent < 0) {
      lines[1] <- dedent(lines[1], - indent)
    } else if (indent > 0) {
      lines[1] <- paste0(strrep(" ", indent), lines[1])
    }
  }

  ## zero out margin
  app$margin <- 0

  signal <- !identical(app$signal, FALSE)
  if (signal && length(app$status_bar)) clii__clear_status_bar(app)
  app$cat(paste0(paste0(lines, "\n"), collapse = ""))
  if (signal && length(app$status_bar)) {
    app$cat(paste0(app$status_bar[[1]]$content, "\r"))
  }
}

clii__vspace <- function(app, n) {
  if (app$margin < n) {
    sp <- strrep("\n", n - app$margin)
    signal <- !identical(app$signal, FALSE)
    if (signal && length(app$status_bar)) clii__clear_status_bar(app)
    clii__message(sp, appendLF = FALSE, output = app$output, signal = app$signal)
    app$margin <- n
    if (signal && length(app$status_bar)) {
      app$cat(paste0(app$status_bar[[1]]$content, "\r"))
    }
  }
}

get_real_output <- function(output) {
  if (! inherits(output, "connection")) {
    output <- switch(
      output,
      "auto" = cli_output_connection(),
      "message" = ,
      "stderr" = stderr(),
      "stdout" = stdout()
    )
  }
  output
}

clii__message <- function(..., domain = NA, appendLF = TRUE,
                          output = stderr(), signal = TRUE) {

  msg <- .makeMessage(..., domain = domain, appendLF = appendLF)
  output <- get_real_output(output)

  # to avoid non-breaking spaces in files, if output is redirected
  msg <- gsub("\u00a0", " ", msg, fixed = TRUE)

  if (identical(signal, FALSE)) {
    safe_cat0(msg, file = output)

  } else {
    withRestarts(muffleMessage = function() NULL, {
      cond <- simpleMessage(msg)
      class(cond) <- c("cliMessage", class(cond))
      signalCondition(cond)
      safe_cat0(msg, file = output)
    })
  }
}

safe_cat0 <- function(x, file) {
  if (inherits(file, "rawConnection")) {
    x <- enc2utf8(x)
    writeBin(charToRaw(x), file)
  } else {
    cat(x, file = file, sep = "")
  }
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/keypress.R"

#' Read a single keypress at the terminal
#'
#' It currently only works at Linux/Unix and OSX terminals,
#' and at the Windows command line. see \code{\link{has_keypress_support}}.
#'
#' The following special keys are supported:
#' * Arrow keys: 'up', 'down', 'right', 'left'.
#' * Function keys: from 'f1' to 'f12'.
#' * Others: 'home', 'end', 'insert', 'delete', 'pageup', 'pagedown',
#'     'tab', 'enter', 'backspace' (same as 'delete' on OSX keyboards),
#'     'escape'.
#' * Control with one of the following keys: 'a', 'b', 'c', 'd', 'e', 'f',
#'     'h', 'k', 'l', 'n', 'p', 't', 'u', 'w'.
#'
#' @param block Whether to wait for a key press, if there is none
#'   available now.
#' @return The key pressed, a character scalar. For non-blocking reads
#'   `NA` is returned if no keys are available.
#'
#' @family keypress function
#' @export
#' @examplesIf FALSE
#' x <- keypress()
#' cat("You pressed key", x, "\n")

keypress <- function(block = TRUE) {
  if (!has_keypress_support()) {
    stop("Your platform/terminal does not support `keypress()`.")
  }
  block <- as.logical(block)
  if (length(block) != 1) stop("'block' must be a logical scalar")
  ret <- .Call(cli_keypress, block)
  if (ret == "none") NA_character_ else ret
}

#' Check if the current platform/terminal supports reading
#' single keys.
#'
#' @details
#' Supported platforms:
#' * Terminals in Windows and Unix.
#' * RStudio terminal.
#'
#' Not supported:
#' * RStudio (if not in the RStudio terminal).
#' * R.app on macOS.
#' * Rgui on Windows.
#' * Emacs ESS.
#' * Others.
#'
#' @return Whether there is support for waiting for individual
#' keypressses.
#'
#' @family keypress function
#' @export
#' @examples
#' has_keypress_support()

has_keypress_support <- function() {
  ## Supported if we have a terminal or RStudio terminal.
  ## Not supported otherwise in RStudio, R.app, Rgui or Emacs

  rs <- rstudio$detect()

  if (rs$type != "not_rstudio") {
    rs$has_canonical_mode

  } else {
    isatty(stdin()) &&
      Sys.getenv("R_GUI_APP_VERSION") == "" &&
      .Platform$GUI != "Rgui" &&
      ! identical(getOption("STERM"), "iESS") &&
      Sys.getenv("EMACS") != "t" &&
      Sys.getenv("TERM") != "dumb"
  }
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/lorem.R"

lorem_words <- c(
  "ad",
  "adipisicing",
  "aliqua",
  "aliquip",
  "amet",
  "anim",
  "aute",
  "cillum",
  "commodo",
  "consectetur",
  "consequat",
  "culpa",
  "cupidatat",
  "deserunt",
  "do",
  "dolor",
  "dolore",
  "duis",
  "ea",
  "eiusmod",
  "elit",
  "enim",
  "esse",
  "est",
  "et",
  "eu",
  "ex",
  "excepteur",
  "exercitation",
  "fugiat",
  "id",
  "in",
  "incididunt",
  "ipsum",
  "irure",
  "labore",
  "laboris",
  "laborum",
  "Lorem",
  "magna",
  "minim",
  "mollit",
  "nisi",
  "non",
  "nostrud",
  "nulla",
  "occaecat",
  "officia",
  "pariatur",
  "proident",
  "qui",
  "quis",
  "reprehenderit",
  "sint",
  "sit",
  "sunt",
  "tempor",
  "ullamco",
  "ut",
  "velit",
  "veniam",
  "voluptate"
)

lorem_ipsum <- function(paragraphs = 1, par_sentence_range = 5:10,
                        sentence_word_range = 5:15) {
  vcapply(
    1:paragraphs,
    function(x, ...) lorem_paragraph(...),
    par_sentence_range = par_sentence_range,
    sentence_word_range = sentence_word_range
  )
}

lorem_paragraph <- function(par_sentence_range, sentence_word_range) {
  num <- sample(par_sentence_range, 1)
  paste(
    collapse = " ",
    vcapply(
      1:num,
      function(x, ...) lorem_sentence(...),
      sentence_word_range = sentence_word_range
    )
  )
}

lorem_sentence <- function(sentence_word_range) {
  num <- sample(sentence_word_range, 1)
  words <- sample(lorem_words, num, replace = TRUE)
  words[1] <- capitalize(words[1])
  paste0(paste(words, collapse = " "), ".")
}

capitalize <- function(x) {
  substr(x, 1, 1) <- toupper(substr(x, 1, 1))
  x
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/mocks.R"
.Call <- NULL
Sys.time <- NULL
commandArgs <- NULL
get <- NULL
getRversion <- NULL
isatty <- NULL
l10n_info <- NULL
loadedNamespaces <- NULL
system <- NULL
system2 <- NULL
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/num-ansi-colors.R"

#' Detect the number of ANSI colors to use
#'
#' @description
#' Certain Unix and Windows terminals, and also certain R GUIs, e.g.
#' RStudio, support styling terminal output using special control
#' sequences (ANSI sequences).
#'
#' `num_ansi_colors()` detects if the current R session supports ANSI
#' sequences, and if it does how many colors are supported.
#'
#' @param stream The stream that will be used for output, an R connection
#' object. It can also be a string, one of `"auto"`, `"message"`,
#' `"stdout"`, `"stderr"`. `"auto"` will select `stdout()` if the session is
#' interactive and there are no sinks, otherwise it will select `stderr()`.
#' @return Integer, the number of ANSI colors the current R session
#' supports for `stream`.
#'
#' @family ANSI styling
#' @export
#' @examples
#' num_ansi_colors()
#'
#' @details
#' The detection mechanism is quite involved and it is designed to work
#' out of the box on most systems. If it does not work on your system,
#' please report a bug. Setting options and environment variables to turn
#' on ANSI support is error prone, because they are inherited in other
#' environments, e.g. knitr, that might not have ANSI support.
#'
#' If you want to _turn off_ ANSI colors, set the `NO_COLOR` environment
#' variable to a non-empty value.
#'
#' The exact detection mechanism is as follows:

num_ansi_colors <- function(stream = "auto") {
  #' 1. If the `cli.num_colors` options is set, that is returned.

  opt <- getOption("cli.num_colors", NULL)
  if (!is.null(opt)) return(as.integer(opt))

  #' 1. If the `R_CLI_NUM_COLORS` environment variable is set to a
  #'    non-empty value, then it is used.

  if ((env <- Sys.getenv("R_CLI_NUM_COLORS", "")) != "") {
    return(as.integer(env))
  }

  #' 1. If the `crayon.enabled` option is set to `FALSE`, 1L is returned.
  #'    (This is for compatibility with code that uses the crayon package.)
  #' 1. If the `crayon.enabled` option is set to `TRUE` and the
  #'    `crayon.colors` option is not set, then the value of the
  #'    `cli.default_num_colors` option, or if it is unset, then 8L is
  #'    returned.
  #' 1. If the `crayon.enabled` option is set to `TRUE` and the
  #'    `crayon.colors` option is also set, then the latter is returned.
  #'    (This is for compatibility with code that uses the crayon package.)

  cray_opt_has <- getOption("crayon.enabled", NULL)
  cray_opt_num <- getOption("crayon.colors", NULL)
  if (!is.null(cray_opt_has) && !isTRUE(cray_opt_has)) return(1L)
  if (isTRUE(cray_opt_has) && !is.null(cray_opt_num)) {
    return(as.integer(cray_opt_num))
  }
  if (isTRUE(cray_opt_has) && is.null(cray_opt_num)) {
    default <- get_default_number_of_colors()
    return(default %||% 8L)
  }

  #' 1. If the `NO_COLOR` environment variable is set, then 1L is returned.

  if (!is.na(Sys.getenv("NO_COLOR", NA_character_))) return(1L)

  #' 1. If we are in knitr, then 1L is returned, to turn off colors in
  #'    `.Rmd` chunks.

  if (isTRUE(getOption("knitr.in.progress"))) return(1L)

  #' 1. If `stream` is `"auto"` (the default) and there is an active
  #'    sink (either for `"output"` or `"message"`), then we return 1L.
  #'    (In theory we would only need to check the stream that will be
  #'    be actually used, but there is no easy way to tell that.)
  if (stream == "auto" && !no_sink()) return(1L)

  # Defer computation on streams to speed up common case
  # when environment variables are set
  orig_stream <- stream
  stream <- get_real_output(stream)

  is_stdout <- is_stderr <- is_std <- FALSE
  std <- "nope"
  if (identical(stream, stdout())) {
    is_stdout <- is_std <- TRUE
    std <- "stdout"
  } else if (identical(stream, stderr())) {
    is_stderr <- is_std <- TRUE
    std <- "stderr"
  }

  #' 1. If `stream` is not `"auto"`, but it is `stderr()` and there is an
  #'    active sink for it, then 1L is returned.
  #'    (If a sink is active for "output", then R changes the `stdout()`
  #'    stream, so this check is not needed.)

  # If a sink is active for "message" (ie. stderr), then R does not update
  # the `stderr()` stream, so we need to catch this case.
  if (is_stderr && sink.number("message") != 2) return(1L)

  #' 1. If the `cli.default_num_colors` option is set, then we use that.

  dopt <- get_default_number_of_colors()
  if (!is.null(dopt)) return(as.integer(dopt))

  #' 1. If R is running inside RGui on Windows, or R.app on macOS, then we
  #'    return 1L.

  # RStudio sets GUI to RGui initially, so we'll handle that after RStudio.
  if (.Platform$GUI == "AQUA") return(1L)

  #' 1. If R is running inside RStudio, with color support, then the
  #'    appropriate number of colors is returned, usually 256L.

  rstudio <- rstudio$detect()
  rstudio_colors <- c(
    "rstudio_console",
    "rstudio_console_starting",
    "rstudio_build_pane",
    "rstudio_job"
  )
  if (is.na(rstudio$num_colors)) rstudio$num_colors <- 1L
  if (rstudio$type %in% rstudio_colors && is_std) {
    return(rstudio$num_colors)
  }

  # RGui? We need to do this after RStudio, because .Platform$GUI is
  # "Rgui" in RStudio when we are starting up
  if (.Platform$GUI == "Rgui") return(1L)

  #' 1. If R is running on Windows, inside an Emacs version that is recent
  #'    enough to support ANSI colors, then the value of the
  #'    `cli.default_num_colors` option, or if unset 8L is returned.
  #'    (On Windows, Emacs has `isatty(stdout()) == FALSE`, so we need to
  #'    check for this here before dealing with terminals.)

  # Windows Emacs? The top R process will have `--ess` in ESS, but the
  # subprocesses won't. (Without ESS subprocesses will also report 8L
  # colors, this is a problem, but we expect most people use ESS in Emacs.)
  if (os_type() == "windows" &&
      "--ess" %in% commandArgs() &&
      is_emacs_with_color()) {
    default <- get_default_number_of_colors()
    return(default %||% 8L)
  }

  #' 1. If `stream` is not the standard output or standard error  in a
  #'    terminal, then 1L is returned.

  if (!isatty(stream)) return(1L)
  if (!is_std) return(1L)

  #' 1. Otherwise we use and cache the result of the terminal color
  #'     detection (see below).

  # Otherwise use/set the cache
  if (is.null(clienv$num_colors)) clienv$num_colors <- list()
  clienv$num_colors[[std]] <- clienv$num_colors[[std]] %||% detect_tty_colors()
  clienv$num_colors[[std]]
}

#' @rdname num_ansi_colors
#' @details
#' The terminal color detection algorithm:

detect_tty_colors <- function() {

  default <- get_default_number_of_colors()

  #' 1. If the `COLORTERM` environment variable is set to `truecolor` or
  #'    `24bit`, then we return 16 million colors.
  #' 1. If the `COLORTERM` environment variable is set to anything else,
  #'    then we return the value of the `cli.num_default_colors` option,
  #'    8L if unset.

  ct <- Sys.getenv("COLORTERM", NA_character_)
  if (!is.na(ct)) {
    if (ct == "truecolor" || ct == "24bit") {
      return(truecolor)
    } else {
      return(default %||% 8L)
    }
  }

  #' 1. If R is running on Unix, inside an Emacs version that is recent
  #'    enough to support ANSI colors, then the value of the
  #'    `cli.default_num_colors` option is returned, or 8L if unset.

  if (os_type() == "unix" && is_emacs_with_color()) return(default %||% 8L)

  #' 1. If we are on Windows in an RStudio terminal, then apparently
  #'    we only have eight colors, but the `cli.default_num_colors` option
  #'    can be used to override this.

  win10 <- win10_build()
  if (os_type() == "windows" && win10 >= 10586 &&
      rstudio_detect()$type == "rstudio_terminal") {
    # this is rather weird, but echo turns on color support :D
    system2("cmd", c("/c", "echo 1 >NUL"))
    return(default %||% 8L)
  }

  #' 1. If we are in a recent enough Windows 10 terminal, then there
  #'    is either true color (from build 14931) or 256 color (from
  #'    build 10586) support. You can also use the `cli.default_num_colors`
  #'    option to override these.

  if (os_type() == "windows" && win10 >= 10586) {
    # this is rather weird, but echo turns on color support :D
    system2("cmd", c("/c", "echo 1 >NUL"))
    # https://devblogs.microsoft.com/commandline/24-bit-color-in-the-windows-console/
    if (win10 >= 14931) {
      return(default %||% truecolor)
    } else {
      return(default %||% 256L)
    }
  }

  if (os_type() == "windows") {

    #' 1. If we are on Windows, under ConEmu or cmder, or ANSICON is loaded,
    #'    then the value of `cli.default_num_colors`, or 8L if unset, is
    #'    returned.

    if (Sys.getenv("ConEmuANSI") == "ON" ||
        Sys.getenv("CMDER_ROOT") != "") {
      return(default %||% 8L)
    }
    if (Sys.getenv("ANSICON") != "") return(default %||% 8L)

    #' 1. Otherwise if we are on Windows, return 1L.

    return(1L)
  }

  #' 1. Otherwise we are on Unix and try to run `tput colors` to determine
  #'    the number of colors. If this succeeds, we return its return value.

  cols <- suppressWarnings(try(
    silent = TRUE,
    as.numeric(system("tput colors 2>/dev/null", intern = TRUE))[1]
  ))
  if (inherits(cols, "try-error") || !length(cols) || is.na(cols)) {
    return(guess_tty_colors())
  }
  if (cols %in% c(-1, 0, 1)) { return(1) }

  #'    If the `TERM` environment variable is `xterm` and `tput`
  #'    returned 8L, we return 256L, because xterm compatible terminals
  #'    tend to support 256 colors
  #'    (<https://github.com/r-lib/crayon/issues/17>)
  #'    You can override this with the `cli.default_num_colors` option.

  if (cols == 8 && identical(Sys.getenv("TERM"), "xterm")) {
    cols <- default %||% 256
  }

  #' 1. If `TERM` is set to `dumb`, we return 1L.
  #' 1. If `TERM` starts with `screen`, `xterm`, or `vt100`, we return 8L.
  #' 1. If `TERM` contains `color`, `ansi`, `cygwin` or `linux`, we return 8L.
  #' 1. Otherwise we return 1L.

  cols
}

get_default_number_of_colors <- function() {
  dft <- getOption("cli.default_num_colors")
  if (!is.null(dft)) {
    if (!is_count(dft)) {
      warning(
        "The `cli.default_num_colors` option must be an integer scalar"
      )
      dft <- NULL
    }
  }
  dft
}

guess_tty_colors <- function() {
  term <- Sys.getenv("TERM")
  if (term == "dumb") return (1L)

  if (grepl(
    "^screen|^xterm|^vt100|color|ansi|cygwin|linux",
    term,
    ignore.case = TRUE,
    perl = TRUE
  )) {
    8L
  } else {
    1L
  }
}

is_emacs_with_color <- function() {
  (Sys.getenv("EMACS") != "" || Sys.getenv("INSIDE_EMACS") != "") &&
    ! is.na(emacs_version()[1]) && emacs_version()[1] >= 23
}

emacs_version <- function() {
  ver <- Sys.getenv("INSIDE_EMACS")
  if (ver == "") return(NA_integer_)

  ver <- gsub("'", "", ver, fixed = TRUE)

  ver <- strsplit(ver, ",", fixed = TRUE)[[1]]
  ver <- strsplit(ver, ".", fixed = TRUE)[[1]]
  suppressWarnings(as.numeric(ver))
}

win10_build <- function() {
  os <- utils::sessionInfo()$running %||% ""
  if (!grepl("^Windows 10 ", os)) return(0L)
  mch <- re_match(os, "[(]build (?<build>[0-9]+)[)]")
  mch <- suppressWarnings(as.integer(mch))
  if (is.na(mch)) return(0L)
  mch
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/onload.R"

#' @useDynLib cli, .registration=TRUE
NULL

## nocov start

dummy <- function() { }

cli_timer_dynamic <- 200L
cli_timer_non_dynamic <- 3000L

clienv <- new.env(parent = emptyenv())
clienv$pid <- Sys.getpid()
clienv$globalenv <- format(.GlobalEnv)
clienv$status <- list()
clienv$progress <- list()
clienv$progress_ids <- list()

clienv$load_time <- NULL
clienv$speed_time <- 1.0
clienv$tick_time <- 200L

task_callback <- NULL

clienv$unloaded <- FALSE

rstudio_r_fix <- 0

.onLoad <- function(libname, pkgname) {

  err$onload_hook()

  # Try to restore cursor as much as we can
  if (Sys.getenv("R_CLI_HIDE_CURSOR") != "false" && isatty(stdout())) {
    reg.finalizer(clienv, function(e) cli::ansi_show_cursor(), TRUE)
    task_callback <<- addTaskCallback(
      function(...) { cli::ansi_show_cursor(); TRUE },
      "cli-show-cursor"
    )
  }

  # https://github.com/r-lib/cli/issues/352
  rstudio_r_fix <<- (Sys.getenv("RSTUDIO") == 1) + 0L

  pkgenv <- environment(dummy)

  clienv$load_time <- Sys.time()

  clienv$speed_time <- as.double(Sys.getenv("CLI_SPEED_TIME", "1.0"))

  tt <- as.integer(Sys.getenv("CLI_TICK_TIME", NA_character_))
  if (is.na(tt)) {
    tt <- if (interactive() || is_dynamic_tty()) {
      cli_timer_dynamic
    } else {
      cli_timer_non_dynamic
    }
  }

  clienv$tick_time <- as.integer(tt)
  .Call(
    clic_start_thread,
    pkgenv,
    clienv$tick_time,
    clienv$speed_time
  )

  # For valgrind: https://github.com/r-lib/cli/issues/311
  reg.finalizer(asNamespace("cli"), function(x) x$unload(), TRUE)

  if (getRversion() >= "3.5.0") {
    `__cli_update_due` <<- .Call(clic_make_timer);
  } else {
    rm("__cli_update_due", envir = pkgenv)
    makeActiveBinding(
      "__cli_update_due",
      function() .Call(clic_update_due),
      pkgenv
    )
  }

  ccli_tick_reset <<- clic_tick_reset

  makeActiveBinding(
    "symbol",
    function() {
      ## If `cli.unicode` is set we use that
      opt <- getOption("cli.unicode",  NULL)
      if (!is.null(opt)) {
        if (isTRUE(opt)) {
          return(symbol_utf8)
        } else {
          return(symbol_ascii)
        }
      }

      ## Otherwise we try to auto-detect
      rst <- rstudio$detect()$type
      rok <- c("rstudio_console", "rstudio_console_starting")
      if (is_utf8_output()) {
        symbol_utf8
      } else if (is_latex_output()) {
        symbol_ascii
      } else {
        symbol_ascii
      }
    },
    pkgenv
  )

  makeActiveBinding("pb_bar",            cli__pb_bar,           pkgenv)
  makeActiveBinding("pb_current",        cli__pb_current,       pkgenv)
  makeActiveBinding("pb_current_bytes",  cli__pb_current_bytes, pkgenv)
  makeActiveBinding("pb_elapsed",        cli__pb_elapsed,       pkgenv)
  makeActiveBinding("pb_elapsed_clock",  cli__pb_elapsed_clock, pkgenv)
  makeActiveBinding("pb_elapsed_raw",    cli__pb_elapsed_raw,   pkgenv)
  makeActiveBinding("pb_eta",            cli__pb_eta,           pkgenv)
  makeActiveBinding("pb_eta_raw",        cli__pb_eta_raw,       pkgenv)
  makeActiveBinding("pb_eta_str",        cli__pb_eta_str,       pkgenv)
  makeActiveBinding("pb_extra",          cli__pb_extra,         pkgenv)
  makeActiveBinding("pb_id",             cli__pb_id,            pkgenv)
  makeActiveBinding("pb_name",           cli__pb_name,          pkgenv)
  makeActiveBinding("pb_percent",        cli__pb_percent,       pkgenv)
  makeActiveBinding("pb_pid",            cli__pb_pid,           pkgenv)
  makeActiveBinding("pb_rate",           cli__pb_rate,          pkgenv)
  makeActiveBinding("pb_rate_raw",       cli__pb_rate_raw,      pkgenv)
  makeActiveBinding("pb_rate_bytes",     cli__pb_rate_bytes,    pkgenv)
  makeActiveBinding("pb_spin",           cli__pb_spin,          pkgenv)
  makeActiveBinding("pb_status",         cli__pb_status,        pkgenv)
  makeActiveBinding("pb_timestamp",      cli__pb_timestamp,     pkgenv)
  makeActiveBinding("pb_total",          cli__pb_total,         pkgenv)
  makeActiveBinding("pb_total_bytes",    cli__pb_total_bytes,   pkgenv)

  if (is.null(getOption("callr.condition_handler_cli_message"))) {
    options(callr.condition_handler_cli_message = cli__default_handler)
  }
}

unload <- function() {
  if (!clienv$unloaded) .Call(clic_unload)
  clienv$unloaded <- TRUE
}

.onUnload <- function(libpath) {
  tryCatch(removeTaskCallback(task_callback), error = function(e) NULL)
  tryCatch(cli_progress_cleanup(), error = function(e) NULL)
  tryCatch(ansi_show_cursor(), error = function(e) NULL)
  unload()
}

## nocov end
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/pluralize.R"

#' About cli pluralization
#'
#' @name pluralization
#' @family pluralization
#' @includeRmd man/chunks/pluralization.Rmd
NULL

make_quantity <- function(object) {
  val <- if (is.numeric(object)) {
    stopifnot(length(object) == 1)

    if (is.finite(object))
      as.integer(object)
    else
      object
  } else {
    length(object)
  }
}

#' Pluralization helper functions
#'
#' @rdname pluralization-helpers
#' @param expr For `no()` it is an expression that is printed as "no" in
#'   cli expressions, it is interpreted as a zero quantity. For `qty()`
#'   an expression that sets the pluralization quantity without printing
#'   anything. See examples below.
#'
#' @examples
#' nfile <- 0; cli_text("Found {no(nfile)} file{?s}.")
#'
#' #> Found no files.
#'
#' nfile <- 1; cli_text("Found {no(nfile)} file{?s}.")
#'
#' #> Found 1 file.
#'
#' nfile <- 2; cli_text("Found {no(nfile)} file{?s}.")
#'
#' #> Found 2 files.
#'
#' @export
#' @family pluralization

no <- function(expr) {
  stopifnot(is.numeric(expr), length(expr) == 1, !is.na(expr))
  structure(
    expr,
    class = "cli_no"
  )
}

#' @export

as.character.cli_no <- function(x, ...) {
  if (make_quantity(x) == 0) "no" else as.character(unclass(x))
}

#' @rdname pluralization-helpers
#' @export

qty <- function(expr) {
  structure(
    make_quantity(expr),
    class = "cli_noprint"
  )
}

#' @export

as.character.cli_noprint <- function(x, ...) {
  ""
}

parse_plural <- function(code, values) {
  # If we have the quantity already, then process it now.
  # Otherwise we put in a marker for it, and request post-processing.
  qty <- make_quantity(values$qty)
  if (!is.na(qty)) {
    process_plural(qty, code)
  } else {
    values$postprocess <- TRUE
    id <- random_id()
    values$pmarkers[[id]] <- code
    id
  }
}

process_plural <- function(qty, code) {
  parts <- strsplit(str_tail(code), "/", fixed = TRUE)[[1]]
  if (last_character(code) == "/") parts <- c(parts, "")
  if (length(parts) == 1) {
    if (is.finite(qty) & qty == 1) "" else parts[1]
  } else if (length(parts) == 2) {
    if (is.finite(qty) & qty == 1)
      parts[1]
    else
      parts[2]
  } else if (length(parts) == 3) {
    if (is.finite(qty) & qty == 0) {
      parts[1]
    } else if (is.finite(qty) & qty == 1) {
      parts[2]
    } else {
      parts[3]
    }
  } else {
    stop("Invalid pluralization directive: `", code, "`")
  }
}

post_process_plurals <- function(str, values) {
  if (!values$postprocess) return(str)
  if (values$num_subst == 0) {
    stop("Cannot pluralize without a quantity")
  }
  if (values$num_subst != 1) {
    stop("Multiple quantities for pluralization")
  }

  qty <- make_quantity(values$qty)
  for (i in seq_along(values$pmarkers)) {
    mark <- values$pmarkers[i]
    str <- sub(names(mark), process_plural(qty, mark[[1]]), str)
  }

  str
}

#' String templating with pluralization
#'
#' `pluralize()` is similar to [glue::glue()], with two differences:
#' * It supports cli's [pluralization] syntax, using `{?}` markers.
#' * It collapses substituted vectors into a comma separated string.
#'
#' See [pluralization] and some examples below.
#'
#' You need to install the glue package to use this function.
#'
#' @param ...,.envir,.transformer All arguments are passed to [glue::glue()].
#'
#' @export
#' @family pluralization
#' @examplesIf requireNamespace("glue", quietly = TRUE)
#' # Regular plurals
#' nfile <- 0; pluralize("Found {nfile} file{?s}.")
#' nfile <- 1; pluralize("Found {nfile} file{?s}.")
#' nfile <- 2; pluralize("Found {nfile} file{?s}.")
#'
#' # Irregular plurals
#' ndir <- 1; pluralize("Found {ndir} director{?y/ies}.")
#' ndir <- 5; pluralize("Found {ndir} director{?y/ies}.")
#'
#' # Use 'no' instead of zero
#' nfile <- 0; pluralize("Found {no(nfile)} file{?s}.")
#' nfile <- 1; pluralize("Found {no(nfile)} file{?s}.")
#' nfile <- 2; pluralize("Found {no(nfile)} file{?s}.")
#'
#' # Use the length of character vectors
#' pkgs <- "pkg1"
#' pluralize("Will remove the {pkgs} package{?s}.")
#' pkgs <- c("pkg1", "pkg2", "pkg3")
#' pluralize("Will remove the {pkgs} package{?s}.")
#'
#' pkgs <- character()
#' pluralize("Will remove {?no/the/the} {pkgs} package{?s}.")
#' pkgs <- c("pkg1", "pkg2", "pkg3")
#' pluralize("Will remove {?no/the/the} {pkgs} package{?s}.")
#'
#' # Multiple quantities
#' nfiles <- 3; ndirs <- 1
#' pluralize("Found {nfiles} file{?s} and {ndirs} director{?y/ies}")
#'
#' # Explicit quantities
#' nupd <- 3; ntotal <- 10
#' cli_text("{nupd}/{ntotal} {qty(nupd)} file{?s} {?needs/need} updates")

pluralize <- function(..., .envir = parent.frame(),
                      .transformer = glue::identity_transformer) {

  values <- new.env(parent = emptyenv())
  values$empty <- random_id()
  values$qty <- values$empty
  values$num_subst <- 0L
  values$postprocess <- FALSE
  values$pmarkers <- list()

  tf <- function(text, envir) {
    if (substr(text, 1, 1) == "?") {
      if (identical(values$qty, values$empty)) {
        values$postprocess <- TRUE
        id <- random_id()
        values$pmarkers[[id]] <- text
        return(id)
      } else {
        return(process_plural(make_quantity(values$qty), text))
      }

    } else {
      values$num_subst <- values$num_subst + 1
      qty <- .transformer(text, envir)
      values$qty <- qty
      return(inline_collapse(qty))
    }
  }

  raw <- glue::glue(..., .envir = .envir, .transformer = tf, .comment = "")
  post_process_plurals(raw, values)
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/prettycode.R"

operator_tokens <- function() {
  c(
    "'-'", "'+'", "'!'", "'~'", "'?'", "':'", "'*'", "'/'", "'^'",
    "SPECIAL", "LT", "GT", "EQ", "GE", "LE", "AND", "AND2", "OR", "OR2",
    "LEFT_ASSIGN", "RIGHT_ASSIGN", "'$'", "'@'", "EQ_ASSIGN", "PIPE"
  )
}

reserved_words <- function() {
  c("FUNCTION", "'\\\\'", "IF", "ELSE",
    "REPEAT", "WHILE", "FOR", "IN", "NEXT", "BREAK")
}


#' Syntax highlight R code
#'
#' @details
#' See [code_theme_list()] for the default syntax highlighting theme and
#' how to change it.
#'
#' If `code` does not parse, then it is returned unchanged and a
#' `cli_parse_failure` condition is thrown. Note that this is not an error,
#' and the condition is ignored, unless explicitly caught.
#'
#' @param code Character vector, each element is one line of code.
#' @param code_theme Theme see [code_theme_list()].
#' @param envir Environment to look up function calls for hyperlinks.
#'   If `NULL`, then the global search path is used.
#' @return Character vector, the highlighted code.
#'
#' @family syntax highlighting
#' @importFrom utils getSrcref getParseData
#' @export
#' @examples
#' code_highlight(deparse(ls))
#' cat(code_highlight(deparse(ls)), sep = "\n")

code_highlight <- function(code, code_theme = NULL, envir = NULL) {

  code_theme <- code_theme %||% code_theme_default()

  parsed <- tryCatch(
    parse(text = code, keep.source = TRUE),
    error = function(e) e
  )

  if (inherits(parsed, "error")) {
    cnd <- structure(
      list(message = conditionMessage(parsed), code = code),
      class = c("cli_parse_failure", "condition")
    )
    signalCondition(cnd)
    return(code)
  }

  theme <- code_theme_make(code_theme)
  data <- get_parse_data(parsed)

  hitext <- data$text

  cnv <- function(x) do.call(combine_ansi_styles, as.list(x))

  brackettheme <- lapply(theme$bracket, cnv)
  theme <- theme[names(theme) != "bracket"]
  theme <- structure(lapply(theme, cnv), names = names(theme))

  ## Reserved words if else repeat while function for in next break
  if (!is.null(theme$reserved)) {
    reserved <- data$token %in% reserved_words()
    hitext[reserved] <- theme$reserved(data$text[reserved])
  }

  ## Numeric constants, including NAs, NaN and Inf
  if (!is.null(theme$number)) {
    num_const <- data$token == "NUM_CONST"
    hitext[num_const] <- theme$number(data$text[num_const])
  }

  ## NULL
  if (!is.null(theme$null)) {
    null <- data$token == "NULL_CONST"
    hitext[null] <- theme$null(data$text[null])
  }

  ## Operators
  if (!is.null(theme$operator)) {
    operator <- data$token %in% operator_tokens()
    hitext[operator] <- theme$operator(data$text[operator])
  }

  ## Function calls
  fun_call <- data$token == "SYMBOL_FUNCTION_CALL"
  if (ansi_hyperlink_types()$help) {
    hitext[fun_call] <- pretty_fun_link(data, fun_call, envir)
  }
  if (!is.null(theme$call)) {
    hitext[fun_call] <- theme$call(hitext[fun_call])
  }

  ## Strings
  if (!is.null(theme$string)) {
    string <- data$token == "STR_CONST"
    reserved <- theme$reserved %||% function(x) x
    raw <- substr(data$text[string], 1, 1) == "r"
    hitext[string][raw] <- paste0(
      rep(reserved("r"), sum(raw)),
      theme$string(substr(data$text[string][raw], 2, nchar(data$text[string][raw])))
    )
    hitext[string][!raw] <- theme$string(data$text[string][!raw])
  }

  ## Comments
  if (!is.null(theme$comment)) {
    comment <- data$token == "COMMENT"
    hitext[comment] <- theme$comment(data$text[comment])
  }

  ## Brackets
  if (length(brackettheme)) {
    bracket <- data$token %in% bracket_tokens()
    hitext[bracket] <- color_brackets(data$text[bracket], brackettheme)
  }

  do_subst(code, data, hitext)
}

get_parse_data <- function(x) {
  # getParseData(x, includeText = NA) would trim long strings and symbols
  data <- getParseData(x, includeText = FALSE)
  data$text <- character(nrow(data))

  substr_with_tabs <- function (x, start, stop, tabsize = 8) {
    widths <- rep_len(1, nchar(x))
    tabs <- which(strsplit(x, "")[[1]] == "\t")
    for (i in tabs) {
      cols <- cumsum(widths)
      widths[i] <- tabsize - (cols[i] - 1) %% tabsize
    }
    cols <- cumsum(widths)
    start <- which(cols >= start)
    if (!length(start)) {
      return("")
    }
    start <- start[1]
    stop <- which(cols <= stop)
    if (length(stop)) {
      stop <- stop[length(stop)]
      substr(x, start, stop)
    } else {
      ""
    }
  }

  srcfile <- attr(data, "srcfile")
  terminal <- which(data$terminal)
  for (i in terminal) {
    lines <- getSrcLines(srcfile, data$line1[i], data$line2[i])
    n <- length(lines)
    lines[n] <- substr_with_tabs(lines[n], 1, data$col2[i])
    lines[1] <- substr_with_tabs(lines[1], data$col1[i], Inf)
    data$text[i] <- paste(lines, collapse = "\n")
  }

  data
}

do_subst <- function(code, pdata, hitext) {

  pdata$hitext <- hitext

  ## Need to do this line by line. TODO: multiline stuff might be broken
  vapply(seq_along(code), FUN.VALUE = character(1), function(no) {
    my <- pdata[pdata$line1 == no & pdata$line2 == no,, drop = FALSE]
    replace_in_place(code[no], my$col1, my$col2, my$hitext)
  })
}

open_brackets <- function() {
  c("(", "{", "[")
}

close_brackets <- function(){
  c(")", "}", "]")
}

bracket_tokens <- function() {
  s <- c(open_brackets(), close_brackets())
  c(paste0("'", s, "'"), "LBB")
}

apply_color <- function(x, lvl, l){
  k <- (lvl - 1) %% length(l) + 1
  l[[k]](x)
}

#' Colored brackets
#'
#' Add color to brackets. Brackets will be coloured consecutively with the
#' colors provided in \code{color_seq} by scope.
#'
#' @param x a character vector of brackets consisting of a valid sequence of any
#'   of the following: \code{'[[', '[', ']', '(', ')', '{', '}'}
#' @param color_seq a list of functions that take and return a character scalar. The
#' ordering defines the sequence of color functions to apply to a given scope level.
#' Color functions are recycled when the scope level exceeds the length of \code{color_seq}
#'
#' @details Meant for coloring brackets encountered within \code{highlight}.
#'   Note that occurrences of 'orphan' brackets are not taken into account
#'   mainly due to the fact that cases such as
#'
#'   \code{foo <- function(x){ `[[`(x, 1) }}
#'
#'   will either be converted to
#'
#'   \code{foo <- function(x){ x[[1]] }}
#'
#'   before the brackets are coloured if passed in as
#'   \code{highlight(deparse(foo))} or will be identified as a
#'   'SYMBOL_FUNCTION_CALL' token instead of 'LBB' if passed in as
#'
#'   \code{highlight("foo <- function(x){ `[[`(x, 1) }")}
#'
#'   Similarly, invalid code that would lead to orphaned brackets is not taken
#'   into account as this would be caught before hand in \code{highlight}.
#'
#' @noRd

color_brackets <- function(x, color_seq = list(col_yellow, col_blue, col_cyan)) {
  stopifnot(vapply(color_seq, is.function, logical(1)))
  open <- c(open_brackets(), "[[")
  o <- character()
  lvl <- 0
  i <- 1
  while (i <= length(x)) {

    if (x[i] %in% open) {
      o[length(o) + 1] <- x[i]
      lvl <- lvl + 1
      x[i] <- apply_color(x[i], lvl, color_seq)
      i <- i + 1
      next
    }

    j <- nchar(o[length(o)])
    x[i:(i + j - 1)] <-
      apply_color(x[i:(i + j - 1)], lvl, color_seq)
    i <- i + j
    lvl <- lvl - 1
    o <- o[-length(o)]
  }
  x
}

replace_in_place <- function(str, start, end, replacement) {

  stopifnot(
    length(str) == 1,
    length(start) == length(end),
    length(end) == length(replacement)
  )

  keep <- substring(str, c(1, end + 1), c(start - 1, nchar(str)))

  pieces <- character(length(replacement) * 2 + 1)

  even <- seq_along(replacement) * 2
  odd <- c(1, even + 1)
  pieces[even] <- replacement
  pieces[odd] <- keep

  paste0(pieces, collapse = "")
}

code_theme_default <- function() {
  opt <- code_theme_opt("cli.code_theme")
  if (!is.null(opt)) return(opt)

  rs <- rstudio_detect()
  if (rs$type %in% c("rstudio_console", "rstudio_console_starting")) {
    opt <- code_theme_opt("cli.code_theme_rstudio")
    if (!is.null(opt)) return(opt)
    if (requireNamespace("rstudioapi", quietly = TRUE)) {
      return(code_theme_default_rstudio())
    }
  }

  opt <- code_theme_opt("cli.code_theme_terminal")
  if (!is.null(opt)) return(opt)
  code_theme_default_term()
}

code_theme_opt <- function(option) {
  theme <- getOption(option)
  if (is.null(theme)) return(NULL)

  code_theme_make(theme)
}

code_theme_make <- function(theme) {
  if (is.list(theme)) return(theme)
  if (is_string(theme)) {
    if (theme %in% names(rstudio_themes)) return(rstudio_themes[[theme]])
    lcs <- gsub(" ", "_", tolower(names(rstudio_themes)), fixed = TRUE)
    if (theme %in% lcs) return(rstudio_themes[[ match(theme, lcs)[1] ]])
    warning("Unknown cli code theme: `", theme, "`.")
    return(NULL)
  }
  warning("Invalid cli code theme, see documentation")
  NULL
}

code_theme_default_rstudio <- function() {
  theme <- get_rstudio_theme()$editor
  if (! theme %in% names(rstudio_themes)) {
    if (!getOption("cli.ignore_unknown_rstudio_theme", FALSE)) {
      warning(
        "cli does not know this RStudio theme: '", theme, "'.",
        "\nSet `options(cli.ignore_unknown_rstudio_theme = TRUE)` ",
        "to suppress this warning"
      )
    }
    return(code_theme_default_term())
  }
  rstudio_themes[[theme]]
}

code_theme_default_term <- function() {
  "Solarized Dark"
}

#' Syntax highlighting themes
#'
#' @description
#' `code_theme_list()` lists the built-in code themes.
#'
#' # Code themes
#' A theme is a list of character vectors, except for `bracket`, see below.
#' Each character vector must contain RGB colors (e.g. `"#a9a9a9"`),
#' and cli styles, e.g. `"bold"`. Entries in the list:
#' * `reserved`: reserved words
#' * `number`: numeric literals
#' * `null`: the `NULL` constant
#' * `operator`: operators, including assignment
#' * `call`: function calls
#' * `string`: character literals
#' * `comment`: comments
#' * `bracket`: brackets: \code{(){}[]} This is a list of character vectors,
#'   to create "rainbow" brackets. It is recycled for deeply nested lists.
#'
#' # The default code theme
#'
#' In RStudio, it matches the current theme of the IDE.
#'
#' You can use three options to customize the code theme:
#' * If `cli.code_theme` is set, it is used.
#' * Otherwise if R is running in RStudio and `cli.code_theme_rstudio` is
#'   set, then it is used.
#' * Otherwise if T is not running in RStudio and `cli.code_theme_terminal`
#'   is set, then it is used.
#'
#' You can set these options to the name of a built-in theme, or to list
#' that specifies a custom theme. See [code_theme_list()] for the list
#' of the built-in themes.
#'
#' @return Character vector of the built-in code theme names.
#'
#' @family syntax highlighting
#' @export
#' @examples
#' code_theme_list()
#' code_highlight(deparse(get), code_theme = "Solarized Dark")

code_theme_list <- function() {
  names(rstudio_themes)
}

pretty_print_function <- function(x, useSource = TRUE, code_theme = NULL, ...) {
  if (num_ansi_colors() == 1L) return(base::print.function(x, useSource))

  srcref <- getSrcref(x)
  src <- if (useSource && ! is.null(srcref)) {
    as.character(srcref)
  } else {
    deparse(x)
  }

  err <- FALSE
  hisrc <- tryCatch(
    code_highlight(src, code_theme = code_theme, envir = environment(x)),
    error = function(e) err <<- TRUE)
  if (err) return(base::print.function(x, useSource))

  ## Environment of the function
  hisrc <- c(hisrc, utils::capture.output(print(environment(x))))

  cat(hisrc, sep = "\n")
  invisible(x)
}

#' Turn on pretty-printing functions at the R console
#'
#' Defines a print method for functions, in the current session, that supports
#' syntax highlighting.
#'
#' The new print method takes priority over the built-in one. Use
#' [base::suppressMessages()] to suppress the alert message.
#'
#' @export

pretty_print_code <- function() {
  registerS3method("print", "function", pretty_print_function, asNamespace("cli"))
  cli::cli_alert_success("Registered pretty printing function method")
}

pretty_fun_link <- function(data, fun_call, envir) {
  sprt <- ansi_hyperlink_types()$help
  wch <- which(fun_call)
  txt <- data$text[wch]
  if (! sprt || length(wch) == 0) return(txt)

  scheme <- if (identical(attr(sprt, "type"), "rstudio")) {
    "ide:help"
  } else {
    "x-r-help"
  }

  pkg <- vcapply(wch, function(idx) {
    prt <- data$parent[idx]
    sgs <- which(data$parent == prt)
    # not a pkg::fun call?
    if (length(sgs) != 3 || data$token[sgs[1]] != "SYMBOL_PACKAGE" ||
        data$token[sgs[2]] != "NS_GET") {
      # note: we do not process ::: which would be NS_GET_INT
      find_function_symbol(data$text[idx], envir %||% .GlobalEnv)
    } else {
      data$text[sgs[1]]
    }
  })

  wlnk <- which(!is.na(pkg))
  txt[wlnk] <- style_hyperlink(
    text = txt[wlnk],
    url = paste0(scheme, ":", pkg[wlnk], "::", txt[wlnk])
  )

  txt
}

find_function_symbol <- function(name, envir = .GlobalEnv) {
  empty <- emptyenv()
  while (!identical(envir, empty)) {
    if (exists(name, envir = envir, inherits = FALSE, mode = "function")) {
      env_name <- environmentName(envir)
      if (grepl("package:", env_name, fixed = TRUE)) {
        env_name <- sub("^package:", "", env_name)
      }
      if (grepl("imports:", env_name, fixed = TRUE)) {
        env_name <- environmentName(environment(get(name, envir)))
      }
      if (grepl("package:", env_name, fixed = TRUE)) {
        env_name <- sub("^package:", "", env_name)
      }
      if (env_name %in% c("", "R_GlobalEnv")) {
        env_name <- NA_character_
      }
      return(env_name)
    } else {
      envir <- parent.env(envir)
    }
  }
  NA_character_
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/print.R"

#' Create a format method for an object using cli tools
#'
#' This method can be typically used in `format()` S3 methods. Then the
#' `print()` method of the class can be easily defined in terms of such a
#' `format()` method. See examples below.
#'
#' @param expr Expression that calls `cli_*` methods, [base::cat()] or
#' [base::print()] to format an object's printout.
#' @param theme Theme to use for the formatting.
#' @return Character vector, one element for each line of the printout.
#'
#' @export
#' @examples
#'
#' # Let's create format and print methods for a new S3 class that
#' # represents the an installed R package: `r_package`
#'
#' # An `r_package` will contain the DESCRIPTION metadata of the package
#' # and also its installation path.
#' new_r_package <- function(pkg) {
#'   tryCatch(
#'     desc <- packageDescription(pkg),
#'     warning = function(e) stop("Cannot find R package `", pkg, "`")
#'   )
#'   file <- dirname(attr(desc, "file"))
#'   if (basename(file) != pkg) file <- dirname(file)
#'   structure(
#'     list(desc = unclass(desc), lib = dirname(file)),
#'     class = "r_package"
#'   )
#' }
#'
#' format.r_package <- function(x, ...) {
#'   cli_format_method({
#'     cli_h1("{.pkg {x$desc$Package}} {cli::symbol$line} {x$desc$Title}")
#'     cli_text("{x$desc$Description}")
#'     cli_ul(c(
#'       "Version: {x$desc$Version}",
#'       if (!is.null(x$desc$Maintainer)) "Maintainer: {x$desc$Maintainer}",
#'       "License: {x$desc$License}"
#'     ))
#'     if (!is.na(x$desc$URL)) cli_text("See more at {.url {x$desc$URL}}")
#'   })
#' }
#'
#' # Now the print method is easy:
#' print.r_package <- function(x, ...) {
#'   cat(format(x, ...), sep = "\n")
#' }
#'
#' # Try it out
#' new_r_package("cli")
#'
#' # The formatting of the output depends on the current theme:
#' opt <- options(cli.theme = simple_theme())
#' print(new_r_package("cli"))
#' options(opt)  # <- restore theme

cli_format_method <- function(expr, theme = getOption("cli.theme")) {

  # This is not needed for cli, but needed for sink() and crayon
  nc <- num_ansi_colors()
  opts <- options(
    cli.num_colors = nc,
    crayon.enabled = nc > 1,
    crayon.colors = nc
  )
  on.exit(options(opts), add = TRUE)

  # Redirect everything to the connection
  con <- textConnection(NULL, open = "w", local = TRUE, encoding = "bytes")
  sink(con)
  on.exit(sink(NULL), add = TRUE)
  on.exit(close(con), add = TRUE)
  start_app(theme = theme, output = con)

  # Run the code
  withCallingHandlers(
    expr,
    cli_message = function(msg) {
      withCallingHandlers(
        cli_server_default(msg),
        cliMessage = function(msg2) {
          cat(conditionMessage(msg2), file = con, sep = "")
          invokeRestart("muffleMessage")
        }
      )
      invokeRestart("cli_message_handled")
    }
  )

  # Collect the output
  textConnectionValue(con)
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/progress-along.R"

#' Add a progress bar to a mapping function or for loop
#'
#' @description
#' Note that this function is currently experimental!
#'
#' Use `cli_progress_along()` in a mapping function or in a for loop, to add a
#' progress bar. It uses [cli_progress_bar()] internally.
#'
#' @details
#'
#' ## `for` loop
#'
#' A `for` loop with `cli_progress_along()` looks like this:
#'
#' ```r
#' for (i in cli_progress_along(seq)) {
#'   ...
#' }
#' ```
#'
#' A complete example:
#'
#' ```{asciicast progress-along-1}
#' #| asciicast_at = "all",
#' #| asciicast_knitr_output = "svg",
#' #| asciciast_cursor = FALSE
#' clifun <- function() {
#'   for (i in cli_progress_along(1:100, "Downloading")) {
#'      Sys.sleep(4/100)
#'   }
#' }
#' clifun()
#' ```
#'
#' ## `lapply()` and other mapping functions
#'
#' They will look like this:
#'
#' ```r
#' lapply(cli_progress_along(X), function(i) ...)
#' ```
#'
#' A complete example:
#'
#' ```{asciicast progress-along-2}
#' #| asciicast_at = "all",
#' #| asciicast_knitr_output = "svg",
#' #| asciicast_cursor = FALSE
#' res <- lapply(cli_progress_along(1:100, "Downloading"), function(i) {
#'   Sys.sleep(4/100)
#' })
#' ```
#'
#' ## Custom format string
#'
#' ```{asciicast progress-along-3}
#' #| asciicast_at = "all",
#' #| asciicast_knitr_output = "svg",
#' #| asciicast_cursor = FALSE
#' clifun <- function() {
#'   for (i in cli_progress_along(1:100,
#'       format = "Downloading data file {cli::pb_current}")) {
#'      Sys.sleep(4/100)
#'   }
#' }
#' clifun()
#' ```
#'
#' ## Breaking out of loops
#'
#' Note that if you use `break` in the `for` loop, you probably want to
#' terminate the progress bar explicitly when breaking out of the loop,
#' or right after the loop:
#'
#' ```r
#' for (i in cli_progress_along(seq)) {
#'   ...
#'   if (cond) cli_progress_done() && break
#'   ...
#' }
#' ```
#'
#' @param x Sequence to add the progress bar to.
#' @param name Name of the progress bar, a label, passed to
#'   [cli_progress_bar()].
#' @param total Passed to [cli_progress_bar()].
#' @param ... Passed to [cli_progress_bar()].
#' @param .envir Passed to [cli_progress_bar()].
#'
#' @return An index vector from 1 to `length(x)` that triggers progress
#' updates as you iterate over it.
#'
#' @seealso This function supports [inline markup][inline-markup].
#' @seealso [cli_progress_bar()] and the traditional progress bar API.
#' @family progress bar functions
#' @family functions supporting inline markup
#' @export

cli_progress_along <- function(x,
                       name = NULL,
                       total = length(x),
                       ...,
                       .envir = parent.frame()) {

  name; total; .envir; list(...)

  if (getRversion() < "3.5.0") return(seq_along(x))
  id <- cli_progress_bar(name = name, total = total, ...,
                         .auto_close = FALSE, .envir = .envir)
  closeenv <- sys.frame(-1)
  if (format(closeenv) != clienv$globalenv) {
    defer(
      cli_progress_done(id = id, .envir = .envir, result = "auto"),
      envir = closeenv
    )
  }
  sax <- seq_along(x)
  clienv$progress[[id]]$caller <- .envir
  .Call(clic_progress_along, sax, clienv$progress[[id]])
}

progress_altrep_update <- function(pb) {
  tryCatch({
    cli_tick_reset()
    caller <- pb$caller
    pb$tick <- pb$tick + 1L

    if (is.null(pb$format)) {
      pb$format <- pb__default_format(pb$type, pb$total)
    }

    opt <- options(cli__pb = pb)
    on.exit(options(opt), add = TRUE)

    handlers <- cli_progress_select_handlers(pb, caller)
    if (is.null(pb$added)) {
      pb$added <- TRUE
      for (h in handlers) {
        if ("add" %in% names(h)) h$add(pb, .envir = caller)
      }
    } else {
      for (h in handlers) {
        if ("set" %in% names(h)) h$set(pb, .envir = caller)
      }
    }
  }, error = function(err) {
    if (!isTRUE(pb$warned)) {
      warning("cli progress bar update failed: ", conditionMessage(err),
              immediate. = TRUE)
    }
    pb$warned <- TRUE
  })

  NULL
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/progress-bar.R"

make_progress_bar <- function(percent, width = 30, style = list()) {
  complete_len <- round(width * percent)

  def <- default_progress_style()
  chr_complete <- style[["progress-complete"]] %||% def[["complete"]]
  chr_incomplete <- style[["progress-incomplete"]] %||% def[["incomplete"]]
  chr_current <- style[["progress-current"]] %||% def[["current"]]

  complete <- paste(rep(chr_complete, complete_len), collapse = "")
  current <- if (percent == 100) chr_complete else chr_current
  incomplete <- paste(rep(chr_incomplete, width - complete_len), collapse = "")
  paste0(complete, current, incomplete, " ")
}

default_progress_style <- function() {
  opt <- progress_style(getOption("cli.progress_bar_style"))
  if (is_utf8_output()) {
    opu <- progress_style(getOption("cli.progress_bar_style_unicode"))
    list(
      complete = opu$complete %||% opt$complete %||% "\u25A0",
      current = opu$current %||% opt$current %||% opu$complete %||%
        opt$complete %||% "\u25A0",
      incomplete = opu$incomplete %||% opt$incomplete %||% "\u00a0"
    )
  } else {
    opa <- progress_style(getOption("cli.progress_bar_style_ascii"))
    list(
      complete = opa$complete %||% opt$complete %||% "=",
      current = opa$current %||% opt$current %||% opa$complete %||%
        opt$complete %||% ">",
      incomplete = opa$incomplete %||% opt$incomplete %||% "-"
    )
  }
}

progress_style <- function(x) {
  if (is.null(x)) return(x)
  if (is_string(x)) return(cli_progress_styles()[[x]])
  x
}

#' List of built-in cli progress styles
#'
#' The following options are used to select a style:
#' * `cli_progress_bar_style`
#' * `cli_progress_bar_style_ascii`
#' * `cli_progress_bar_style_unicode`
#'
#' On Unicode terminals (if [is_utf8_output()] is `TRUE`), the
#' `cli_progress_bar_style_unicode` and `cli_progress_bar_style`
#' options are used.
#'
#' On ASCII terminals (if [is_utf8_output()] is `FALSE`), the
#' `cli_pgoress_bar_style_ascii` and `cli_progress_bar_style` options
#' are are used.
#'
#' ```{asciicast progress-style}
#' for (style in names(cli_progress_styles())) {
#'   options(cli.progress_bar_style = style)
#'   label <- ansi_align(paste0("Style '", style, "'"), 20)
#'   print(cli_progress_demo(label, live = FALSE, at = 66, total = 100))
#' }
#' options(cli.progress_var_style = NULL)
#' ```
#'
#' @return A named list with sublists containing elements
#' `complete`, `incomplete` and potentially `current`.
#'
#' @family progress bar functions
#' @export

cli_progress_styles <- function() {
  list(
    classic = list(
      complete = "#",
      incomplete = "\u00a0"
    ),
    squares = list(
      complete = "\u25a0",
      incomplete = "\u00a0"
    ),
    dot = list(
      complete = col_grey("\u2500"),
      incomplete = col_grey("\u2500"),
      current = col_red(symbol$record)
    ),
    fillsquares = list(
      complete = "\u25a0",
      incomplete = col_grey("\u25a1")
    ),
    bar = list(
      complete = "\u2588",
      incomplete = col_grey("\u2588")
    )
  )
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/progress-c.R"

progress_c_update <- function(pb, auto_done = TRUE) {
  cli_tick_reset()

  caller <- pb$caller %||% sys.frame(sys.nframe() - 1L)

  pb$tick <- pb$tick + 1L

  if (is.null(pb$format)) {
    pb$format <- pb__default_format(pb$type, pb$total)
  }

  if (pb$auto_terminate && auto_done && !is.na(pb$total) &&
      pb$current == pb$total) {
    progress_c_done(pb, caller = caller)
    return(NULL)
  }

  opt <- options(cli__pb = pb)
  on.exit(options(opt), add = TRUE)

  handlers <- cli_progress_select_handlers(pb, caller)
  if (is.null(pb$added)) {
    pb$added <- TRUE
    for (h in handlers) {
      if ("add" %in% names(h)) h$add(pb, .envir = caller)
    }
  }

  for (h in handlers) {
    if ("set" %in% names(h)) h$set(pb, .envir = caller)
  }

  NULL
}

progress_c_done <- function(pb, caller = NULL) {
  if (isTRUE(pb$done)) return()

  caller <- caller %||% pb$caller %||% sys.frame(sys.nframe() - 1L)

  opt <- options(cli__pb = pb)
  on.exit(options(opt), add = TRUE)

  handlers <- cli_progress_select_handlers()
  for (h in handlers) {
    if ("complete" %in% names(h)) {
      h$complete(pb, .envir = caller, result = "done")
    }
  }

  if (!is.null(pb$id)) clienv$progress[[pb$id]] <- NULL
  if (!is.null(pb$envkey)) clienv$progress_ids[[pb$envkey]] <- NULL

  pb$done <- TRUE

  NULL
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/progress-client.R"

#' cli progress bars
#'
#' @description
#' This is the reference manual of the three functions that create,
#' update and terminate progress bars. For a tutorial see the
#' [cli progress bars](https://cli.r-lib.org/articles/progress.html).
#'
#' `cli_progress_bar()` creates a new progress bar.
#'
#' @details
#'
#' ## Basic usage
#'
#' `cli_progress_bar()` creates a progress bar, `cli_progress_update()`
#' updates an existing progress bar, and `cli_progress_done()` terminates
#' it.
#'
#' It is good practice to always set the `name` argument, to make the
#' progress bar more informative.
#'
#' ```{asciicast progress-1}
#' #| asciicast_at = "all",
#' #| asciicast_knitr_output = "svg",
#' #| asciicast_cursor = FALSE
#' clean <- function() {
#'   cli_progress_bar("Cleaning data", total = 100)
#'   for (i in 1:100) {
#'     Sys.sleep(5/100)
#'     cli_progress_update()
#'   }
#'   cli_progress_done()
#' }
#' clean()
#' ```
#'
#' ## Progress bar types
#'
#' There are three builtin types of progress bars, and a custom type.
#'
#' ```{asciicast progress-tasks}
#' #| asciicast_at = "all",
#' #| asciicast_knitr_output = "svg",
#' #| asciicast_cursor = FALSE
#' tasks <- function() {
#'   cli_progress_bar("Tasks", total = 3, type = "tasks")
#'   for (i in 1:3) {
#'     Sys.sleep(1)
#'     cli_progress_update()
#'   }
#'   cli_progress_done()
#' }
#' tasks()
#' ```
#'
#' ## Unknown `total`
#'
#' If `total` is not known, then cli shows a different progress bar.
#' Note that you can also set `total` in `cli_progress_update()`, if it
#' not known when the progress bar is created, but you learn it later.
#'
#' ```{asciicast progress-natotal}
#' #| asciicast_at = "all",
#' #| asciicast_knitr_output = "svg",
#' #| asciicast_cursor = FALSE
#' nototal <- function() {
#'   cli_progress_bar("Parameter tuning")
#'   for (i in 1:100) {
#'     Sys.sleep(3/100)
#'     cli_progress_update()
#'   }
#'   cli_progress_done()
#' }
#' nototal()
#' ```
#'
#' ## Clearing the progress bar
#'
#' By default cli removes terminated progress bars from the screen, if
#' the terminal supports this. If you want to change this, use the
#' `clear` argument of `cli_progress_bar()`, or the `cli.progress_clear`
#' global option (see [cli-config]) to change this.
#'
#' (In the cli documentation we usually set `cli.progress_clear` to `FALSE`,
#' so users can see how finished progress bars look.)
#'
#' In this example the first progress bar is cleared, the second is not.
#'
#' ```{asciicast progress-clear}
#' #| asciicast_at = "all",
#' #| asciicast_knitr_output = "svg",
#' #| asciicast_cursor = FALSE
#' fun <- function() {
#'   cli_progress_bar("Data cleaning", total = 100, clear = TRUE)
#'   for (i in 1:100) {
#'     Sys.sleep(3/100)
#'     cli_progress_update()
#'   }
#'   cli_progress_bar("Parameter tuning", total = 100, clear = FALSE)
#'   for (i in 1:100) {
#'     Sys.sleep(3/100)
#'     cli_progress_update()
#'   }
#' }
#' fun()
#' ```
#'
#' ## Initial delay
#'
#' Updating a progress bar on the screen is costly, so cli tries to avoid
#' it for quick loops. By default a progress bar is only shown after two
#' seconds, or after half of that if less than 50% of the iterations are
#' complete. You can change the two second default with the
#' `cli.progress_show_after` global option (see [cli-config]).
#'
#' (In the cli documentation we usually set `cli.progress_show_after` to
#' `0` (zero seconds), so progress bars are shown immediately.)
#'
#' In this example we only show the progress bar after one second, because
#' more than 50% of the iterations remain after one second.
#'
#' ```{asciicast progress-after}
#' #| asciicast_at = "all",
#' #| asciicast_knitr_output = "svg",
#' #| asciicast_cursor = FALSE
#' fun <- function() {
#'   cli_alert("Starting now, at {Sys.time()}")
#'   cli_progress_bar(
#'     total = 100,
#'     format = "{cli::pb_bar} {pb_percent} @ {Sys.time()}"
#'   )
#'   for (i in 1:100) {
#'     Sys.sleep(4/100)
#'     cli_progress_update()
#'   }
#' }
#' options(cli.progress_show_after = 2)
#' fun()
#' ```
#'
#' ```{asciicast, include = FALSE, cache = FALSE}
#' # reset to our default
#' options(cli.progress_show_after = 0)
#' ```
#'
#' ## The _current_ progress bar
#'
#' By default cli sets the new progress bar as the _current_ progress bar
#' of the calling function. The current progress bar is the default one
#' in cli progress bar operations. E.g. if no progress bar id is supplied
#' in `cli_progress_update()`, then the current progress bar is updated.
#'
#' Every function can only have a single _current_ progress bar, and if a
#' new one is created, then the previous one (if any) is automatically
#' terminated. The current progress bar is also terminated when the function
#' that created it exits. Thanks to these rules, most often you don't need
#' to explicitly deal with progress bar ids, and you don't need to
#' explicitly call `cli_progress_done()`:
#'
#' ```{asciicast progress-current}
#' #| asciicast_at = "all",
#' #| asciicast_knitr_output = "svg",
#' #| asciicast_cursor = FALSE
#' fun <- function() {
#'   cli_progress_bar("First step ", total = 100)
#'   for (i in 1:100) {
#'     Sys.sleep(2/100)
#'     cli_progress_update()
#'   }
#'   cli_progress_bar("Second step", total = 100)
#'   for (i in 1:100) {
#'     Sys.sleep(2/100)
#'     cli_progress_update()
#'   }
#' }
#' fun()
#' ```
#'
#' ## cli output while the progress bar is active
#'
#' cli allows emitting regular cli output (alerts, headers, lists, etc.)
#' while a progress bar is active. On terminals that support this, cli
#' will remove the progress bar temporarily, emit the output, and then
#' restores the progress bar.
#'
#' ```{asciicast progress-output}
#' #| asciicast_at = "all",
#' #| asciicast_knitr_output = "svg",
#' #| asciicast_cursor = FALSE
#' fun <- function() {
#'   cli_alert_info("Before the progress bar")
#'   cli_progress_bar("Calculating", total = 100)
#'   for (i in 1:50) {
#'     Sys.sleep(4/100)
#'     cli_progress_update()
#'   }
#'   cli_alert_info("Already half way!")
#'   for (i in 1:50) {
#'     Sys.sleep(4/100)
#'     cli_progress_update()
#'   }
#'   cli_alert_info("All done")
#' }
#' fun()
#' ```
#'
#' See also [cli_progress_output()], which sends text for the current
#' progress handler. E.g. in a Shiny app it will send the output to the
#' Shiny progress bar, as opposed to the `cli_alert()` etc. cli functions
#' which will print the text to the console.
#'
#' ## Custom formats
#'
#' In addition to the builtin types, you can also specify a custom
#' format string. In this case [progress variables][progress-variables]
#' are probably useful to avoid calculating some progress bar quantities
#' like the elapsed time, of the ETA manually. You can also use your own
#' variables in the calling function:
#'
#' ```{asciicast progress-format}
#' #| asciicast_at = "all",
#' #| asciicast_knitr_output = "svg",
#' #| asciicast_cursor = FALSE
#' fun <- function(urls) {
#'   cli_progress_bar(
#'     format = paste0(
#'       "{pb_spin} Downloading {.path {basename(url)}} ",
#'       "[{pb_current}/{pb_total}]   ETA:{pb_eta}"
#'     ),
#'     format_done = paste0(
#'       "{col_green(symbol$tick)} Downloaded {pb_total} files ",
#'       "in {pb_elapsed}."
#'     ),,
#'     total = length(urls)
#'   )
#'   for (url in urls) {
#'     cli_progress_update()
#'     Sys.sleep(5/10)
#'   }
#' }
#' fun(paste0("https://acme.com/data-", 1:10, ".zip"))
#' ```
#'
#' @param name This is typically used as a label, and should be short,
#'   at most 20 characters.
#' @param status Initial status of the progress bar. If not empty, then
#'   it is typically shown after the label.
#' @param type Type of the progress bar. It is used to select a default
#'   display if `format` is not specified. Currently supported types:
#'   * `iterator`: e.g. a for loop or a mapping function,
#'   * `tasks`: a (typically small) number of tasks,
#'   * `download`: download of one file,
#'   * `custom`: custom type, `format` must not be `NULL` for this type.
#' @param total Total number of progress units, or `NA` if it is unknown.
#'   `cli_progress_update()` can update the total number of units. This is
#'   handy if you don't know the size of a download at the beginning, and
#'   also in some other cases. If `format` is set to `NULL`, `format` (plus
#'   `format_done` and `format_failed`) will be updated when you change
#'   `total` from `NA` to a number. I.e. default format strings will be
#'   updated, custom ones won't be.
#' @param format Format string. It has to be specified for custom progress
#'   bars, otherwise it is optional, and a default display is selected
#'   based on the progress bat type and whether the number of total units
#'   is known. Format strings may contain glue substitution, the support
#'   pluralization and cli styling. See [progress-variables] for special
#'   variables that you can use in the custom format.
#' @param format_done Format string for successful termination. By default
#'   the same as `format`.
#' @param format_failed Format string for unsuccessful termination. By
#'   default the same as `format`.
#' @param clear Whether to remove the progress bar from the screen after
#'   it has terminated. Defaults to the `cli.progress_clear` option, or
#'   `TRUE` if unset.
#' @param current Whether to use this progress bar as the current progress
#'   bar of the calling function. See more at 'The current progress bar'
#'   below.
#' @param auto_terminate Whether to terminate the progress bar if the
#'   number of current units reaches the number of total units.
#' @param extra Extra data to add to the progress bar. This can be
#'   used in custom format strings for example. It should be a named list.
#'   `cli_progress_update()` can update the extra data. Often you can get
#'   away with referring to local variables in the format string, and
#'   then you don't need to use this argument. Explicitly including these
#'   constants or variables in `extra` can result in cleaner code. In
#'   the rare cases when you need to refer to the same progress bar from
#'   multiple functions, and you can them to `extra`.
#' @param .auto_close Whether to terminate the progress bar when the
#'   calling function (or the one with execution environment in `.envir`
#'   exits. (Auto termination does not work for progress bars created
#'   from the global environment, e.g. from a script.)
#' @param .envir The environment to use for auto-termination and for glue
#'   substitution. It is also used to find and set the current progress bar.
#'
#' @return `cli_progress_bar()` returns the id of the new progress bar.
#' The id is a string constant.
#'
#' @seealso These functions support [inline markup][inline-markup].
#' @seealso [cli_progress_message()] and [cli_progress_step()] for simpler
#'   progress messages.
#' @family progress bar functions
#' @family functions supporting inline markup
#' @aliases __cli_update_due cli_tick_reset ccli_tick_reset ticking
#' @export

cli_progress_bar <- function(name = NULL,
                             status = NULL,
                             type = c("iterator", "tasks", "download",
                                      "custom"),
                             total = NA,
                             format = NULL,
                             format_done = NULL,
                             format_failed = NULL,
                             clear = getOption("cli.progress_clear", TRUE),
                             current = TRUE,
                             auto_terminate = type != "download",
                             extra = NULL,
                             .auto_close = TRUE,
                             .envir = parent.frame()) {

  start <- .Call(clic_get_time)
  id <- new_uuid()
  envkey <- format(.envir)
  type <- match.arg(type)
  if (type == "custom" && is.null(format)) {
    stop("Need to specify format if `type == \"custom\"")
  }

  ## If `total` is infinite, use behavior seen when `total` is NA
  if (is.infinite(total)) {
    total <- NA
  }

  ## If changes, synchronize with C API in progress.c
  bar <- new.env(parent = emptyenv())
  bar$id <- id
  bar$name <- name
  bar$status <- status
  bar$type <- match.arg(type)
  bar$total <- total
  bar$show_after <- start + getOption("cli.progress_show_after", 2)
  bar$show_50 <- start + getOption("cli.progress_show_after", 2) / 2
  bar$format_orig <- bar$format <- format
  bar$format_done_orig <- bar$format_done <- format_done %||% format
  bar$format_failed_orig <- bar$format_failed <- format_failed %||% format
  bar$clear <- clear
  bar$auto_terminate <- auto_terminate
  bar$envkey <- if (current) envkey else NULL
  bar$current <- 0L
  bar$start <- start
  bar$tick <- 0L
  bar$extra <- extra
  clienv$progress[[id]] <- bar
  if (current) {
    if (!is.null(clienv$progress_ids[[envkey]])) {
      cli_progress_done(clienv$progress_ids[[envkey]], .envir = .envir, result = "done")
    }
    clienv$progress_ids[[envkey]] <- id
  }

  if (.auto_close && envkey != clienv$globalenv) {
    defer(
      cli_progress_done(id = id, .envir = .envir, result = "auto"),
      envir = .envir
    )
  }

  opt <- options(cli__pb = bar)
  on.exit(options(opt), add = TRUE)

  bar$handlers <- cli_progress_select_handlers(bar, .envir)
  for (h in bar$handlers) {
    if ("create" %in% names(h)) h$create(bar, .envir = .envir)
  }

  invisible(id)
}

#' @description
#' `cli_progress_update()` updates the state of a progress bar, and
#' potentially the display as well.
#'
#' @param inc Increment in progress units. This is ignored if `set` is
#'   not `NULL`.
#' @param set Set the current number of progress units to this value.
#'   Ignored if `NULL`.
#' @param status New status string of the progress bar, if not `NULL`.
#' @param id Progress bar to update or terminate. If `NULL`, then the
#'   current progress bar of the calling function (or `.envir` if
#'   specified) is updated or terminated.
#' @param force Whether to force a display update, even if no update is
#'   due.
#'
#' @return `cli_progress_update()` returns the id of the progress bar,
#' invisibly.
#'
#' @name cli_progress_bar
#' @export

cli_progress_update <- function(inc = NULL, set = NULL, total = NULL,
                                status = NULL, extra = NULL,
                                id = NULL, force = FALSE,
                                .envir = parent.frame()) {

  id <- id %||% clienv$progress_ids[[format(.envir)]]
  if (is.null(id)) {
    envkey <- format(.envir)
    stop("Cannot find current progress bar for `", envkey, "`")
  }
  pb <- clienv$progress[[id]]
  if (is.null(pb)) stop("Cannot find progress bar `", id, "`")

  if (!is.null(status)) pb$status <- status

  if (!is.null(extra)) pb$extra <- utils::modifyList(pb$extra, extra)

  if (!is.null(set)) {
    pb$current <- set
  } else {
    inc <- inc %||% 1L
    pb$current <- pb$current + inc
  }

  if (!is.null(total)) {
    if (is.na(pb$total) != is.na(total) ||
        (!is.na(total) && pb$total != total)) {
      pb$total <- total
      if (!is.null(pb$format) && is.null(pb$format_orig)) {
        pb$format <- pb__default_format(pb$type, pb$total)
        pb$format_done <- pb$format_done_orig %||% pb$format
        pb$format_failed <- pb$format_failed_orig %||% pb$format
      }
    }
  }

  if (pb$auto_terminate && !is.na(pb$total) && pb$current == pb$total) {
    cli_progress_done(id, .envir = .envir, result = "done")
    return(invisible(id))
  }

  now <- .Call(clic_get_time)
  upd <- .Call(clic_update_due)
  if (force || (upd && now > pb$show_after) ||
      (!is.na(pb$total) && upd && now > pb$show_50 && pb$current <= pb$total / 2)) {
    if (upd) cli_tick_reset()
    pb$tick <- pb$tick + 1L

    if (is.null(pb$format)) {
      pb$format <- pb__default_format(pb$type, pb$total)
      pb$format_done <- pb$format_done_orig %||% pb$format
      pb$format_failed <- pb$format_failed_orig %||% pb$format
    }

    opt <- options(cli__pb = pb)
    on.exit(options(opt), add = TRUE)

    if (is.null(pb$added)) {
      pb$added <- TRUE
      for (h in pb$handlers) {
        if ("add" %in% names(h)) h$add(pb, .envir = .envir)
      }
    }

    for (h in pb$handlers) {
      if ("set" %in% names(h)) h$set(pb, .envir = .envir)
    }
  }

  # Return TRUE, to allow cli_progress_update() && break in loops
  invisible(id)
}

#' @description
#' `cli_progress_done()` terminates a progress bar.
#'
#' @param result String to select successful or unsuccessful termination.
#'   It is only used if the progress bar is not cleared from the screen.
#'   It can be one of `"done"`, `"failed"`, `"clear"`, and `"auto"`.
#'
#' @return `cli_progress_done()` returns `TRUE`, invisibly, always.
#'
#' @name cli_progress_bar
#' @export

cli_progress_done <- function(id = NULL, .envir = parent.frame(),
                              result = "done") {
  envkey <- format(.envir)
  id <- id %||% clienv$progress_ids[[envkey]]
  if (is.null(id)) return(invisible(TRUE))
  pb <- clienv$progress[[id]]
  if (is.null(pb)) return(invisible(TRUE))

  opt <- options(cli__pb = pb)
  on.exit(options(opt), add = TRUE)

  if (result == "auto") {
    r1 <- random_marker
    if (identical(returnValue(r1), r1)) {
      result <- "failed"
    } else {
      result <- "done"
    }
  }

  for (h in pb$handlers) {
    if ("complete" %in% names(h)) {
      h$complete(pb, .envir = .envir, result = result)
    }
  }

  clienv$progress[[id]] <- NULL
  if (!is.null(pb$envkey)) clienv$progress_ids[[pb$envkey]] <- NULL

  invisible(TRUE)
}

#' Add text output to a progress bar
#'
#' The text is calculated via [cli_text()], so all cli features can be
#' used here, including progress variables.
#'
#' The text is passed to the progress handler(s), that may or may not be
#' able to print it.
#'
#' ```{asciicast progress-output2}
#' #| asciicast_at = "all",
#' #| asciicast_knitr_output = "svg",
#' #| asciicast_cursor = FALSE
#' fun <- function() {
#'   cli_alert_info("Before the progress bar")
#'   cli_progress_bar("Calculating", total = 100)
#'   for (i in 1:50) {
#'     Sys.sleep(4/100)
#'     cli_progress_update()
#'   }
#'   cli_progress_output("Already half way!")
#'   for (i in 1:50) {
#'     Sys.sleep(4/100)
#'     cli_progress_update()
#'   }
#'   cli_alert_info("All done")
#' }
#' fun()
#' ```
#'
#' @param text Text to output. It is formatted via [cli_text()].
#' @param id Progress bar id. The default is the current progress bar.
#' @param .envir Environment to use for glue interpolation of `text`.
#' @return `TRUE`, always.
#'
#' @seealso This function supports [inline markup][inline-markup].
#' @family progress bar functions
#' @family functions supporting inline markup
#' @export

cli_progress_output <- function(text, id = NULL, .envir = parent.frame()) {
  envkey <- format(.envir)
  id <- id %||% clienv$progress_ids[[envkey]]
  if (is.null(id)) {
    stop("Cannot find current progress bar for `", envkey, "`")
  }
  pb <- clienv$progress[[id]]
  if (is.null(pb)) stop("Cannot find progress bar `", id, "`")

  txt <- cli_fmt(cli_text(text, .envir = .envir))
  for (h in pb$handlers) {
    if ("output" %in% names(h)) {
      h$output(pb, .envir = .envir, text = txt)
    }
  }

  invisible(TRUE)
}

# ------------------------------------------------------------------------

#' Simplified cli progress messages
#'
#' @description This is a simplified progress bar, a single (dynamic)
#' message, without progress units.
#'
#' @details `cli_progress_message()` always shows the message, even if no
#' update is due. When the progress message is terminated, it is removed
#' from the screen by default.
#'
#' Note that the message can be dynamic: if you update it with
#' [cli_progress_update()], then cli uses the current values in the string
#' substitutions.
#'
#' ```{asciicast progress-message}
#' #| echo = c(-2, -3),
#' #| asciicast_at = "all",
#' #| asciicast_knitr_output = "svg",
#' #| asciicast_cursor = FALSE
#' fun <- function() {
#'   opts <- options(cli.progress_clear = TRUE)
#'   on.exit(options(opts), add = TRUE)
#'   cli_progress_message("Task one is running...")
#'   Sys.sleep(2)
#'
#'   cli_progress_message("Task two is running...")
#'   Sys.sleep(2)
#'
#'   step <- 1L
#'   cli_progress_message("Task three is underway: step {step}")
#'   for (step in 1:5) {
#'     Sys.sleep(0.5)
#'     cli_progress_update()
#'   }
#' }
#' fun()
#' ```
#'
#' @param msg Message to show. It may contain glue substitution and cli
#'   styling. It can be updated via [cli_progress_update()], as usual.
#' @param current Passed to [cli_progress_bar()].
#' @param .auto_close Passed to [cli_progress_bar()].
#' @param .envir Passed to [cli_progress_bar()].
#' @param ... Passed to [cli_progress_bar()].
#'
#' @return The id of the new progress bar.
#'
#' @seealso This function supports [inline markup][inline-markup].
#' @seealso [cli_progress_bar()] for the complete progress bar API.
#'   [cli_progress_step()] for a similar display that is styled by default.
#' @family progress bar functions
#' @family functions supporting inline markup
#' @export

cli_progress_message <- function(msg,
                                 current = TRUE,
                                 .auto_close = TRUE,
                                 .envir = parent.frame(),
                                 ...) {

  id <- cli_progress_bar(
    type = "custom",
    format = msg,
    current = current,
    .auto_close = .auto_close,
    .envir = .envir,
    ...
  )

  cli_progress_update(id = id, force = TRUE, .envir = .envir)

  invisible(id)
}

# ------------------------------------------------------------------------

#' Simplified cli progress messages, with styling
#'
#' @description This is a simplified progress bar, a single (dynamic)
#' message, without progress units.
#'
#' @details `cli_progress_step()` always shows the progress message,
#' even if no update is due.
#'
#' ## Basic use
#'
#' ```{asciicast progress-step}
#' #| asciicast_at = "all",
#' #| asciicast_knitr_output = "svg",
#' #| asciicast_cursor = FALSE
#' f <- function() {
#'   cli_progress_step("Downloading data")
#'   Sys.sleep(2)
#'   cli_progress_step("Importing data")
#'   Sys.sleep(1)
#'   cli_progress_step("Cleaning data")
#'   Sys.sleep(2)
#'   cli_progress_step("Fitting model")
#'   Sys.sleep(3)
#' }
#' f()
#' ```
#'
#' ## Spinner
#'
#' You can add a spinner to some or all steps with `spinner = TRUE`,
#' but note that this will only work if you call [cli_progress_update()]
#' regularly.
#'
#' ```{asciicast progress-step-spin}
#' #| asciicast_at = "all",
#' #| asciicast_knitr_output = "svg",
#' #| asciicast_cursor = FALSE
#' f <- function() {
#'   cli_progress_step("Downloading data", spinner = TRUE)
#'   for (i in 1:100) { Sys.sleep(2/100); cli_progress_update() }
#'   cli_progress_step("Importing data")
#'   Sys.sleep(1)
#'   cli_progress_step("Cleaning data")
#'   Sys.sleep(2)
#'   cli_progress_step("Fitting model", spinner = TRUE)
#'   for (i in 1:100) { Sys.sleep(3/100); cli_progress_update() }
#' }
#' f()
#' ```
#'
#' ## Dynamic messages
#'
#' You can make the step messages dynamic, using glue templates.
#' Since `cli_progress_step()` show that message immediately, we need
#' to initialize `msg` first.
#'
#' ```{asciicast progress-step-dynamic}
#' #| asciicast_at = "all",
#' #| asciicast_knitr_output = "svg",
#' #| asciicast_cursor = FALSE
#' f <- function() {
#'   msg <- ""
#'   cli_progress_step("Downloading data{msg}", spinner = TRUE)
#'   for (i in 1:100) {
#'     Sys.sleep(2/100)
#'     msg <- glue::glue(", got file {i}/100")
#'     cli_progress_update()
#'   }
#'   cli_progress_step("Importing data")
#'   Sys.sleep(1)
#'   cli_progress_step("Cleaning data")
#'   Sys.sleep(2)
#'   cli_progress_step("Fitting model", spinner = TRUE)
#'   for (i in 1:100) { Sys.sleep(3/100); cli_progress_update() }
#' }
#' f()
#' ```
#'
#' ## Termination messages
#'
#' You can specify a different message for successful and/or
#' unsuccessful termination:
#'
#' ```{asciicast progress-step-msg}
#' #| error = FALSE,
#' #| asciicast_at = "all",
#' #| asciicast_knitr_output = "svg",
#' #| asciicast_cursor = FALSE
#' f <- function() {
#'   size <- 0L
#'   cli_progress_step(
#'     "Downloading data.",
#'     msg_done = "Downloaded {prettyunits::pretty_bytes(size)}.",
#'     spinner = TRUE
#'   )
#'   for (i in 1:100) {
#'     Sys.sleep(3/100)
#'     size <- size + 8192
#'     cli_progress_update()
#'   }
#' }
#' f()
#' ```
#'
#' @param msg Message to show. It may contain glue substitution and cli
#'   styling. It can be updated via [cli_progress_update()], as usual.
#'   It is style as a cli info alert (see [cli_alert_info()]).
#' @param msg_done Message to show on successful termination. By default
#'   this it is the same as `msg` and it is styled as a cli success alert
#'   (see [cli_alert_success()]).
#' @param msg_failed Message to show on unsuccessful termination. By
#'   default it is the same as `msg` and it is styled as a cli danger alert
#'   (see [cli_alert_danger()]).
#' @param spinner Whether to show a spinner at the beginning of the line.
#'   To make the spinner spin, you'll need to call `cli_progress_update()`
#'   regularly.
#' @param class cli class to add to the message. By default there is no
#'   class for steps with a spinner.
#' @param current Passed to [cli_progress_bar()].
#' @param .auto_close Passed to [cli_progress_bar()].
#' @param .envir Passed to [cli_progress_bar()].
#' @param ... Passed to [cli_progress_bar()].
#'
#' @seealso This function supports [inline markup][inline-markup].
#' @family progress bar functions
#' @family functions supporting inline markup
#' @export

cli_progress_step <- function(msg,
                              msg_done = msg,
                              msg_failed = msg,
                              spinner = FALSE,
                              class = if (!spinner) ".alert-info",
                              current = TRUE,
                              .auto_close = TRUE,
                              .envir = parent.frame(),
                              ...) {

  format <- paste0(
    if (!is.null(class)) paste0("{", class, " "),
    if (spinner) "{cli::pb_spin} ",
    msg,
    if (!is.null(class)) "}"
  )
  ts <- " {.timestamp {cli::pb_elapsed}}"
  format_done <- paste0("{.alert-success ", msg_done, ts, "}")
  format_failed <- paste0("{.alert-danger ", msg_failed, ts, "}")

  opt <- options(cli.progress_show_after = 0)
  on.exit(options(opt), add = TRUE)
  id <- cli_progress_bar(
    type = "custom",
    format = format,
    format_done = format_done,
    format_failed = format_failed,
    clear = FALSE,
    current = current,
    .auto_close = .auto_close,
    .envir = .envir,
    ...
  )

  cli_progress_update(id = id, force = TRUE, .envir = .envir)

  invisible(id)
}

# ------------------------------------------------------------------------

pb__default_format <- function(type, total) {
  if (type == "iterator") {
    if (!is.na(total)) {
      opt <- getOption("cli.progress_format_iterator")
      if (!is.null(opt)) return(opt)
      paste0(
        "{cli::pb_name}{cli::pb_bar} {cli::pb_percent} | {cli::pb_status}",
        "ETA: {cli::pb_eta}"
      )
    } else {
      opt <- getOption("cli.progress_format_iterator_nototal") %||%
        getOption("cli.progress_format_iterator")
      if (!is.null(opt)) return(opt)
      paste0(
        "{cli::pb_spin} {cli::pb_name}{cli::pb_status}",
        "{cli::pb_current} done ({cli::pb_rate}) | {cli::pb_elapsed}"
      )
    }

  } else if (type == "tasks") {
    if (!is.na(total)) {
      opt <- getOption("cli.progress_format_tasks")
      if (!is.null(opt)) return(opt)
      paste0(
        "{cli::pb_spin} {cli::pb_current}/{cli::pb_total} ",
        "ETA: {cli::pb_eta} | {cli::pb_name}{cli::pb_status}"
      )
    } else {
      opt <- getOption("cli.progress_format_tasks_nototal") %||%
        getOption("cli.progress_format_tasks")
      if (!is.null(opt)) return(opt)
      paste0(
        "{cli::pb_spin} {cli::pb_name}{cli::pb_status}",
        "{cli::pb_current} done ({cli::pb_rate}) | {cli::pb_elapsed}"
      )
    }

  } else if (type == "download") {
    if (!is.na(total)) {
      opt <- getOption("cli.progress_format_download")
      if (!is.null(opt)) return(opt)
      paste0(
        "{cli::pb_name}{cli::pb_status}{cli::pb_bar}| ",
        "{cli::pb_current_bytes}/{cli::pb_total_bytes} {cli::pb_eta_str}"
      )
    } else {
      opt <- getOption("cli.progress_format_download_nototal") %||%
        getOption("cli.progress_format_download")
      if (!is.null(opt)) return(opt)
      paste0(
        "{cli::pb_name}{cli::pb_status}{cli::pb_spin} ",
        "{cli::pb_current_bytes} ({cli::pb_rate_bytes}) | {cli::pb_elapsed}"
      )
    }
  }
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/progress-server.R"

# ------------------------------------------------------------------------

#' cli progress handlers
#'
#' The progress handler(s) to use can be selected with global options.
#'
#' There are three options that specify which handlers will be selected,
#' but most of the time you only need to use one of them. You can set these
#' options to a character vector, the names of the built-in cli handlers you
#' want to use:
#'
#' * If `cli.progress_handlers_only` is set, then these handlers are used,
#'   without considering others and without checking if they are able to
#'   handle a progress bar. This option is mainly intended for testing
#'   purposes.
#' * The handlers named in `cli.progress_handlers` are checked if they are
#'   able to handle the progress bar, and from the ones that are, the first
#'   one is selected. This is usually the option that the end use would want
#'   to set.
#' * The handlers named in `cli.progress_handlers_force` are always appended
#'   to the ones selected via `cli.progress_handlers`. This option is useful
#'   to add an additional handler, e.g. a logger that writes to a file.
#'
#' # The built-in progress handlers
#'
#' ### `cli`
#'
#' Use cli's internal status bar, the last line of the screen, to show the
#' progress bar. This handler is always able to handle all progress bars.
#'
#' ### `logger`
#'
#' Log progress updates to the screen, with one line for each update and with
#' time stamps. This handler is always able to handle all progress bars.
#'
#' ### `progressr`
#'
#' Use the progressr package to create
#' progress bars. This handler is always able to handle all progress bars.
#' (The progressr package needs to be installed.)
#'
#' ### `rstudio`
#'
#' Use [RStudio's job panel](https://posit.co/blog/rstudio-1-2-jobs/)
#' to show the progress bars. This handler is available at the RStudio console,
#' in recent versions of RStudio.
#'
#' ### `say`
#'
#' Use the macOS `say` command to announce progress events in speech (type
#' `man say` on a terminal for more info). Set the `cli.progress_say_frequency`
#' option to set the minimum delay between `say` invocations, the default is
#' three seconds. This handler is available on macOS, if the `say` command is
#' on the path.
#'
#' The external command and its arguments can be configured with options:
#'
#' * `cli_progress_say_args`: command line arguments, e.g. you can use this
#'   to select a voice on macOS,
#' * `cli_progress_say_command`: external command to run,
#' * `cli_progress_say_frequency`: wait at least this many seconds between
#'   calling the external command.
#'
#' ### `shiny`
#'
#' Use [shiny's progress bars](https://shiny.rstudio.com/articles/progress.html).
#' This handler is available if a shiny app is running.
#'
#' @return `cli_progress_builtin_handlers()` returns the names of the
#' currently supported progress handlers.
#'
#' @family progress bar functions
#' @export

# TODO: examples

cli_progress_builtin_handlers <- function() {
  names(builtin_handlers())
}

cli_progress_select_handlers <- function(bar, .envir) {
  hnd <- getOption("cli.progress_handlers", c("shiny", "cli"))
  frc <- getOption("cli.progress_handlers_force")
  onl <- getOption("cli.progress_handlers_only")

  bin <- builtin_handlers()
  if (!is.null(onl)) return(bin[onl])

  hnd_imp <- bin[hnd]
  hnd_able <- Filter(function(h) is.null(h$able) || h$able(bar, .envir), hnd_imp)
  if (length(hnd_able) > 1) hnd_able <- hnd_able[1]

  c(hnd_able, bin[frc])
}

# ------------------------------------------------------------------------

builtin_handler_cli <- list(
  add = function(bar, .envir) {
    bar$cli_statusbar <- cli_status(
      bar$format,
      msg_done = bar$format_done %||% bar$format,
      msg_failed = bar$format_failed %||% bar$format,
      .auto_close = FALSE,
      .envir = .envir,
      )
    bar$last_shown <- bar$current
    bar$justadded <- TRUE
  },

  set = function(bar, .envir) {
    if (isTRUE(bar$justadded)) {
      bar$justadded <- FALSE
      return()
    }
    bar$last_shown <- bar$current
    cli_status_update(id = bar$cli_statusbar, bar$format, .envir = .envir)
  },

  complete = function(bar, .envir, result) {
    if (isTRUE(bar$added)) {
      if (bar$clear) {
        # Show the full bar non-dynamic ttys
        if (!is_dynamic_tty() &&
            !identical(bar$last_shown, bar$current)) {
          cli_status_update(id = bar$cli_statusbar, bar$format, .envir = .envir)
        }
        cli_status_clear(bar$cli_statusbar, result = "clear", .envir = .envir)
      } else {
        if (result == "done" && !is.na(bar$total)) bar$current <- bar$total
        cli_status_clear(
          bar$cli_statusbar,
          result = result,
          msg_done = bar$format_done %||% bar$format,
          msg_failed = bar$format_failed %||% bar$format,
          .envir = .envir
        )
      }
    }
    bar$cli_statusbar <- TRUE
  },

  output = function(bar, .envir, text) {
    cli_verbatim(text)
  }
)

# ------------------------------------------------------------------------

builtin_handler_progressr <- list(
  add = function(bar, .envir) {
    steps <- if (is.na(bar$total)) 0 else bar$total
    bar$progressr_progressor <- asNamespace("progressr")$progressor(
      steps,
      auto_finish = FALSE,
      on_exit = TRUE,
      envir = .envir,
      label = bar$name %||% NA_character_
    )
  },

  set = function(bar, .envir) {
    if (!is.null(bar$progressr_progressor)) {
      bar$progressr_progressor(step = bar$current)
    }
  },

  complete = function(bar, .envir, result) {
    if (!is.null(bar$progressr_progressor)) {
      bar$progressr_progressor(step = bar$current, type = "finish")
    }
  },

  output = function(bar, .envir, text) {
    if (!is.null(bar$progressr_progressor)) {
      bar$progressr_progressor(message = text, class = "sticky", amount = 0)
    }
  }
)

# ------------------------------------------------------------------------

logger_out <- function(bar, event) {
  cat(sep = "", format_iso_8601(Sys.time()), " ", bar$id, " ",
      bar$current, "/", bar$total, " ", event, "\n")
}

builtin_handler_logger <- list(
  create = function(bar, .envir) {
    logger_out(bar, "created")
  },

  add = function(bar, .envir) {
    logger_out(bar, "added")
  },

  set = function(bar, .envir) {
    logger_out(bar, "updated")
  },

  complete = function(bar, .envir, result) {
    logger_out(bar, paste0("terminated (", result, ")"))
  },

  output = function(bar, .envir, text) {
    logger_out(bar, text)
  }
)

# ------------------------------------------------------------------------

say_out <- function(text) {
  say <- getOption("cli.progress_say_command", "say")
  args <- getOption("cli.progress_say_args", character())
  processx::process$new(say, c(args, text))
}

say_update <- function(bar) {
  now <- .Call(clic_get_time)
  freq <- getOption("cli.progress_say_frequency", 3.0)
  if (is.null(bar$say_last) || now - bar$say_last > freq) {
    txt <- if (is.na(bar$total)) bar$current else cli__pb_percent(bar)
    bar$say_proc <- say_out(txt)
    bar$say_last <- now
  }
}

builtin_handler_say <- list(
  able = function(bar, .envir) {
    if (!is.null(getOption("cli.progress_say_command"))) return(TRUE)
    Sys.info()[["sysname"]] == "Darwin" && Sys.which("say") != ""
  },

  add = function(bar, .envir) {
    ## Nothing to do here
  },

  set = function(bar, .envir) {
    say_update(bar)
  },

  complete = function(bar, .envir, result) {
    if (!is.null(bar$say_proc)) {
      bar$say_proc$kill()
      say_out("done")
    }
  }
)

# ------------------------------------------------------------------------

builtin_handler_rstudio <- list(
  able = function(bar, .envir) {
    tryCatch(
      .Platform$GUI == "Rstudio" && rstudioapi::isAvailable(),
      error = function(err) FALSE
    )
  },

  add = function(bar, .envir) {
    total <- if (is.na(bar$total)) 0L else as.integer(bar$total)
    bar$status <- bar$status %||% ""
    rstudio_id <- rstudioapi::jobAdd(
      name = bar$name %||% "",
      status = bar$status,
      progressUnits = total,
      running = TRUE,
      show = FALSE
    )
    # so the name is not duplicated in the format string as well
    if (is.na(bar$total)) bar$name <- NULL
    bar$rstudio_id <- rstudio_id
    bar$rstudio_status <- bar$status
  },

  set = function(bar, .envir) {
    if (!is.na(bar$total)) {
      rstudioapi::jobSetProgress(bar$rstudio_id, bar$current)
      if (bar$rstudio_status != bar$status) {
        rstudioapi::jobSetStatus(bar$rstudio_id, bar$status)
        bar$rstudio_status <- bar$status
      }
    } else {
      status <- cli_fmt(
        cli_text(bar$format, .envir = .envir),
        collapse = TRUE,
        strip_newline = TRUE
      )
      rstudioapi::jobSetStatus(bar$rstudio_id, status)
    }
  },

  complete = function(bar, .envir, results) {
    if (!is.null(bar$rstudio_id)) {
      rstudioapi::jobRemove(bar$rstudio_id)
    }
  },

  output = function(bar, .envir, text) {
    rstudioapi::jobAddOutput(bar$rstudio_id, text)
  }
)

# ------------------------------------------------------------------------

shiny_detail <- function(bar, .envir) {
  status <- if (is.null(bar$format_orig)) {
    bar$status %||% ""
  } else {
    cli_fmt(
      cli_text(bar$format, .envir = .envir),
      collapse = TRUE,
      strip_newline = TRUE
    )
  }
  output <- bar$shiny_output %||% ""
  paste0(
    status,
    if (status != "" && output != "") "\n",
    output
  )
}

last_lines <- function(txt, keep = 5) {
  txt <- sub("^\n*", "", txt)
  txt <- sub("\n*$", "", txt)
  lines <- strwrap(txt, width = 40)
  paste(utils::tail(lines, keep), collapse = "\n")
}

builtin_handler_shiny <- list(
  able = function(bar, .envir) {
    "shiny" %in% loadedNamespaces() && asNamespace("shiny")$isRunning()
  },

  add = function(bar, .envir) {
    bar$shiny_progress <- asNamespace("shiny")$Progress$new(
      asNamespace("shiny")$getDefaultReactiveDomain(),
      min = 0,
      max = bar$total
    )
    bar$shiny_progress$set(
      message = bar$name %||% "",
      detail = shiny_detail(bar, .envir)
    )
  },

  set = function(bar, .envir) {
    bar$shiny_progress$set(
      value = bar$current,
      detail = shiny_detail(bar, .envir)
    )
  },

  complete = function(bar, .envir, results) {
    if (!is.null(bar$shiny_progress)) {
      bar$shiny_progress$set(
        value = bar$current,
        detail = shiny_detail(bar, .envir)
      )
      bar$shiny_progress$close()
    }
    bar$shiny_progress <- NULL
  },

  output = function(bar, .envir, text) {
    bar$shiny_output <-
      last_lines(paste0(bar$shiny_output, " \u2022 ", text))
    bar$shiny_progress$set(
      value = bar$current,
      detail = shiny_detail(bar, .envir)
    )
  }
)

# ------------------------------------------------------------------------

builtin_handlers <- function() {
  list(
    cli = builtin_handler_cli,
    logger = builtin_handler_logger,
    progressr = builtin_handler_progressr,
    rstudio = builtin_handler_rstudio,
    say = builtin_handler_say,
    shiny = builtin_handler_shiny
  )
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/progress-ticking.R"

#' @export

ticking <- function(cond, name = NULL, ..., .envir = parent.frame()) {
  val <- force(cond)

  new <- is.null(clienv$progress_ids[[format(.envir)]])

  if (new && val) cli_progress_bar(name = name, ..., .envir = .envir)

  if (val) {
    cli_progress_update(.envir = .envir)
  } else {
    cli_progress_done(.envir = .envir)
  }

  val
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/progress-utils.R"

#' @title Progress bar utility functions.
#' @details `cli_progress_num()` returns the number of currently
#' active progress bars. (These do not currently include the progress
#' bars created in C/C++ code.)
#' @return `cli_progress_num()` returns an integer scalar.
#'
#' @rdname progress-utils
#' @family progress bar functions
#' @export

cli_progress_num <- function() {
  length(clienv$progress)
}

#' @details `cli_progress_cleanup()` terminates all active progress bars.
#' (It currently ignores progress bars created in the C/C++ code.)
#' @return `cli_progress_cleanup() does not return anything.
#'
#' @rdname progress-utils
#' @export

cli_progress_cleanup <- function() {
  while ((n <- cli_progress_num()) > 0) {
    cli_progress_done(clienv$progress[[n]]$id)
  }
  ansi_show_cursor()
  invisible()
}

should_run_progress_examples <- function() {
  if (is_rcmd_check()) return(FALSE)
  tolower(Sys.getenv("R_PROGRESS_NO_EXAMPLES")) != "true"
}

is_rcmd_check <- function() {
  if (identical(Sys.getenv("NOT_CRAN"), "true")) {
    FALSE
  } else {
    Sys.getenv("_R_CHECK_PACKAGE_NAME_", "") != ""
  }
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/progress-variables.R"

# ------------------------------------------------------------------------

#' @title Progress bar variables
#'
#' @details These variables can be used in cli progress bar format
#' strings. They are calculated on demand. To use a variable, e.g. `pb_bar`
#' in a package, you either need to to import `pb_bar` from cli, or use
#' the qualified form in the format string: `cli::pb_bar`.
#'
#' Similarly, in R scripts, you can use `pb_bar` after `library(cli)`,
#' or `cli::pb_bar` if you do not attach the cli package.
#'
#' @family progress bar functions
#' @name progress-variables
NULL

#' @name progress-variables
#' @export pb_bar
#' @usage NULL
#' @aliases pb_bar
#'
#' @details
#' ### `pb_bar`
#'
#' Creates a visual progress bar. If the number of total units
#' is unknown, then it will return an empty string.
#'
#' ```{asciicast progress-var-bar, echo = 2:5}
#' x <- invisible(quote(
#' cli_progress_bar(
#'   total = 100,
#'   format = "Fitting model {cli::pb_bar} {cli::pb_percent}"
#' )
#' ))
#' cli:::var_helper(x, current = 66)
#' ```

cli__pb_bar <- function(pb = getOption("cli__pb")) {
  if (is.null(pb)) return("")
  if (is.na(pb$total)) return("")
  structure(
    list(current = pb$current, total = pb$total),
    class = "cli-progress-bar"
  )
}

#' @name progress-variables
#' @export pb_current
#' @usage NULL
#' @aliases pb_current
#'
#' @details
#' ### `pb_current`
#'
#' The number of current progress units.
#'
#' ```{asciicast progress-var-current, echo = 2:5}
#' x <- invisible(quote(
#' cli_progress_bar(
#'   total = 100,
#'   format = "{cli::pb_spin} Reading file {cli::pb_current}/{cli::pb_total}"
#' )
#' ))
#' cli:::var_helper(x, current = 66)
#' ```

cli__pb_current <- function(pb = getOption("cli__pb")) {
  if (is.null(pb)) return("")
  pb$current
}

#' @name progress-variables
#' @export pb_current_bytes
#' @usage NULL
#' @aliases pb_current_bytes
#'
#' @details
#' ### `pb_current_bytes`
#'
#' The number of current progress units formatted as bytes.
#' The output has a constant width of six characters.
#'
#' ```{asciicast progress-var-current-bytes, echo = 2:4}
#' x <- invisible(quote(
#' cli_progress_bar(
#'   format = "Got {cli::pb_current_bytes} in {cli::pb_elapsed}"
#' )
#' ))
#' cli:::var_helper2(x, current = 1024 * 512, delay = 5)
#' ```

cli__pb_current_bytes <- function(pb = getOption("cli__pb")) {
  if (is.null(pb)) return("")
  format_bytes$pretty_bytes(pb$current, style = "6")
}

#' @name progress-variables
#' @export pb_elapsed
#' @usage NULL
#' @aliases pb_elapsed
#'
#' @details
#' ### `pb_elapsed`
#'
#' The elapsed time since the start of the progress bar. The time is
#' measured since the progress bar was created with [cli_progress_bar()]
#' or similar.
#'
#' ```{asciicast progress-var-elapsed, echo = 2:5}
#' x <- invisible(quote(
#' cli_progress_bar(
#'   total = 100,
#'   format = "{cli::pb_bar} {cli::pb_percent} [{cli::pb_elapsed}]"
#' )
#' ))
#' cli:::var_helper2(x, current = 65, delay = 5)
#' ```

cli__pb_elapsed <- function(pb = getOption("cli__pb")) {
  if (is.null(pb)) return("")
  secs <- (.Call(clic_get_time) - pb$start) * clienv$speed_time
  format_time$pretty_sec(secs)
}

#' @name progress-variables
#' @export pb_elapsed_clock
#' @usage NULL
#' @aliases pb_elapsed_clock
#'
#' @details
#' ### `pb_elapsed_clock`
#'
#' The elapsed time, in `hh::mm::ss` format.
#'
#' ```{asciicast progress-var-elapsed-clock, echo = 2:5}
#' x <- invisible(quote(
#' cli_progress_bar(
#'   total = 100,
#'   format = "{cli::pb_bar} {cli::pb_percent} [{cli::pb_elapsed_clock}]"
#' )
#' ))
#' cli:::var_helper2(x, current = 65, delay = 5)
#' ```

cli__pb_elapsed_clock <- function(pb = getOption("cli__pb")) {
  if (is.null(pb)) return("")
  s <- (.Call(clic_get_time) - pb$start) * clienv$speed_time
  hours <- floor(s / 3600)
  minutes <- floor((s / 60) %% 60)
  seconds <- round(s %% 60, 1)
  paste0(
    formatC(hours, width = 2, flag = "0"),
    ":",
    formatC(minutes, width = 2, flag = "0"),
    ":",
    formatC(seconds, width = 2, flag = "0")
  )
}

#' @name progress-variables
#' @export pb_elapsed_raw
#' @usage NULL
#' @aliases pb_elapsed_raw
#'
#' @details
#' ### `pb_elapsed_raw`
#'
#' The number of seconds since the start of the progress bar.
#'
#' ```{asciicast progress-var-elapsed-raw, echo = 2:5}
#' x <- invisible(quote(
#' cli_progress_bar(
#'   total = 100,
#'   format = "{cli::pb_bar} {cli::pb_percent} [{round(cli::pb_elapsed_raw)}s]"
#' )
#' ))
#' cli:::var_helper2(x, current = 65, delay = 5)
#' ```

cli__pb_elapsed_raw <- function(pb = getOption("cli__pb")) {
  if (is.null(pb)) return("")
  (.Call(clic_get_time) - pb$start) * clienv$speed_time
}

#' @name progress-variables
#' @export pb_eta
#' @usage NULL
#' @aliases pb_eta
#'
#' @details
#' ### `pb_eta`
#'
#' The estimated time until the end of the progress bar,
#' in human readable form.
#'
#' ```{asciicast progress-var-eta, echo = 2:5}
#' x <- invisible(quote(
#' cli_progress_bar(
#'   total = 100,
#'   format = "{cli::pb_bar} {cli::pb_percent} | ETA: {cli::pb_eta}"
#' )
#' ))
#' cli:::var_helper2(x, current = 65, delay = 5)
#' ```

cli__pb_eta <- function(pb = getOption("cli__pb")) {
  if (is.null(pb)) return("")
  eta <- cli__pb_eta_raw(pb)
  if (is.na(eta)) {
    "?"
  } else {
    format_time_ago$vague_dt(eta, format = "terse")
  }
}

#' @name progress-variables
#' @export pb_eta_raw
#' @usage NULL
#' @aliases pb_eta_raw
#'
#' @details
#' ### `pb_eta_raw`
#'
#' The estimated time until the end of the progress
#' bar, in seconds. This is useful if you want to adjust the default
#' `pb_eta` display.
#'
#' ```{asciicast progress-var-eta-raw, echo = 2:5}
#' x <- invisible(quote(
#' cli_progress_bar(
#'   total = 100,
#'   format = "{cli::pb_bar} {cli::pb_percent} | ETA: {round(cli::pb_eta_raw)}s"
#' )
#' ))
#' cli:::var_helper2(x, current = 65, delay = 5)
#' ```

cli__pb_eta_raw <- function(pb = getOption("cli__pb")) {
  if (is.null(pb)) return("")
  if (is.na(pb$total)) return(NA_real_)
  if (pb$current == pb$total) return(as.difftime(0, units = "secs"))
  if (pb$current == 0L) return(NA_real_)
  elapsed <- (.Call(clic_get_time) - pb$start) * clienv$speed_time
  as.difftime(elapsed * (pb$total / pb$current - 1.0), units = "secs")
}

#' @name progress-variables
#' @export pb_eta_str
#' @usage NULL
#' @aliases pb_eta_str
#'
#' @details
#' ### `pb_eta_str`
#'
#' The estimated time until the end of the progress bar.
#' It includes the `"ETA:"` prefix. It is only shown if the time can be
#' estimated, otherwise it is the empty string.
#'
#' ```{asciicast progress-var-eta-str, echo = 2:5}
#' x <- invisible(quote(
#' cli_progress_bar(
#'   total = 100,
#'   format = "{cli::pb_bar} {cli::pb_percent} | {cli::pb_eta_str}"
#' )
#' ))
#' cli:::var_helper2(x, current = 65, delay = 5)
#' ```

cli__pb_eta_str <- function(pb = getOption("cli__pb")) {
  if (is.null(pb)) return("")
  eta <- cli__pb_eta(pb)
  if (eta != "?") paste0("ETA: ", eta) else ""
}

#' @name progress-variables
#' @export pb_extra
#' @usage NULL
#' @aliases pb_extra
#'
#' @details
#' ### `pb_extra`
#'
#' `pb_extra` can be used to access extra data, see the `extra` argument
#' of `cli_progress_bar()` and `cli_progress_update()`.
#'
#' ```{asciicast progress-var-extra, echo = 2:6}
#' x <- invisible(quote(
#' cli_progress_bar(
#'   total = 100,
#'   extra = list(user = whoami::username()),
#'   format = "Cleaning cache for user '{cli::pb_extra$user}': {cli::pb_current_bytes}"
#' )
#' ))
#' cli:::var_helper(x, current = 1024 * 1024 * 154)
#' ```

cli__pb_extra <- function(pb = getOption("cli__pb")) {
  if (is.null(pb)) return("")
  pb$extra
}

#' @name progress-variables
#' @export pb_id
#' @usage NULL
#' @aliases pb_id
#'
#' @details
#' ### `pb_id`
#'
#' The id of the progress bar. The id has the format
#' `cli-<pid>-<counter>` where `<pid>` is the process id, and
#' `<counter>` is an integer counter that is incremented every time
#' cli needs a new unique id.
#'
#' This is useful for debugging progress bars.
#'
#' ```{asciicast progress-var-id, echo = 2:4}
#' x <- invisible(quote(
#' cli_progress_bar(
#'   format = "Progress bar '{cli::pb_id}' is at {cli::pb_current}"
#' )
#' ))
#' cli:::var_helper(x, current = 64)
#' ```

cli__pb_id <- function(pb = getOption("cli__pb")) {
  if (is.null(pb)) return("")
  pb$id
}

#' @name progress-variables
#' @export pb_name
#' @usage NULL
#' @aliases pb_name
#'
#' @details
#' ### `pb_name`
#'
#' The name of the progress bar. This is supplied by the
#' developer, and it is by default the empty string. A space character
#' is added to non-empty names.
#'
#' ```{asciicast progress-var-name, echo = 2:6}
#' x <- invisible(quote(
#' cli_progress_bar(
#'   name = "Loading training data",
#'   total = 100,
#'   format = "{cli::pb_name} {cli::pb_bar} {cli::pb_percent}"
#' )
#' ))
#' cli:::var_helper(x, current = 66)
#' ```
#'

cli__pb_name <- function(pb = getOption("cli__pb")) {
  if (is.null(pb)) return("")
  if (!is.null(pb$name)) {
    paste0(pb$name, " ")
  } else {
    ""
  }
}

#' @name progress-variables
#' @export pb_percent
#' @usage NULL
#' @aliases pb_percent
#'
#' @details
#' ### `pb_percent`
#'
#' The percentage of the progress bar, always formatted
#' in three characters plus the percentage sign. If the total number of
#' units is unknown, then it is `" NA%"`.
#'
#' ```{asciicast progress-var-percent, echo = 2:5}
#' x <- invisible(quote(
#' cli_progress_bar(
#'   total = 100,
#'   format = "{cli::pb_bar} {cli::pb_percent}"
#' )
#' ))
#' cli:::var_helper(x, current = 66)
#' ```

cli__pb_percent <- function(pb = getOption("cli__pb")) {
  if (is.null(pb)) return("")
  paste0(format(round(pb$current / pb$total * 100), width = 3), "%")
}

#' @name progress-variables
#' @export pb_pid
#' @usage NULL
#' @aliases pb_pid
#'
#' @details
#' ### `pb_pid`
#'
#' The integer process id of the progress bar. This is useful if you are
#' aggregating logging output or progress results from multiple processes.

cli__pb_pid <- function(pb = getOption("cli__pb")) {
  if (is.null(pb)) return("")
  pb$pid %||% Sys.getpid()
}

#' @name progress-variables
#' @export pb_rate
#' @usage NULL
#' @aliases pb_rate
#'
#' @details
#' ### `pb_rate`
#'
#' The progress rate, in number of units per second, formatted in a string.
#'
#' ```{asciicast progress-var-rate, echo = 2:5}
#' x <- invisible(quote(
#' cli_progress_bar(
#'   total = 156,
#'   format = "Reading input files {pb_current}/{pb_total} [{pb_rate}]"
#' )
#' ))
#' cli:::var_helper2(x, current = 67, delay = 5)
#' ```

cli__pb_rate <- function(pb = getOption("cli__pb")) {
  if (is.null(pb)) return("")
  rate <- cli__pb_rate_raw(pb)
  if (is.nan(rate) || is.na(rate) || is.infinite(rate)) return("?/s")
  paste0(format(rate, digits = 2), "/s")
}

#' @name progress-variables
#' @export pb_rate_raw
#' @usage NULL
#' @aliases pb_rate_raw
#'
#' @details
#' ### `pb_rate_raw`
#'
#' The raw progress rate, in number of units per second.
#'
#' ```{asciicast progress-var-rate-raw, echo = 2:5}
#' x <- invisible(quote(
#' cli_progress_bar(
#'   total = 156,
#'   format = "Reading input files {pb_current}/{pb_total} [{round(pb_rate_raw)}/s]"
#' )
#' ))
#' cli:::var_helper2(x, current = 67, delay = 5)
#' ```

cli__pb_rate_raw <- function(pb = getOption("cli__pb")) {
  if (is.null(pb)) return("")
  elapsed <- cli__pb_elapsed_raw(pb)
  pb$current / elapsed
}

#' @name progress-variables
#' @export pb_rate_bytes
#' @usage NULL
#' @aliases pb_rate_bytes
#'
#' @details
#' ### `pb_rate_bytes`
#'
#' The progress rate, formatted as bytes per second, in human readable form.
#'
#' ```{asciicast progress-var-rate-bytes, echo = 2:7}
#' x <- invisible(quote(
#' cli_progress_bar(
#'   total = 256 * 1024 * 1014,
#'   format = paste0(
#'     "Reading data {pb_current_bytes}/{pb_total_bytes} ",
#'     "[{ansi_trimws(pb_rate_bytes)}]"
#'   )
#' )
#' ))
#' cli:::var_helper2(x, current = 67 * 1024 * 1024, delay = 5)
#' ```

cli__pb_rate_bytes <- function(pb = getOption("cli__pb")) {
  if (is.null(pb)) return("")
  rate <- cli__pb_rate_raw(pb)
  paste0(
    format_bytes$pretty_bytes(rate, style = "6"),
    "/s"
  )
}

#' @name progress-variables
#' @export pb_spin
#' @usage NULL
#' @aliases pb_spin
#'
#' @details
#' ### `pb_spin`
#'
#' A spinner. The default spinner is selected via a [get_spinner()] call.
#'
#' ```{asciicast progress-var-current, echo = 2:5}
#' x <- invisible(quote(
#' cli_progress_bar(
#'   total = 100,
#'   format = "{cli::pb_spin} Reading file {cli::pb_current}/{cli::pb_total}"
#' )
#' ))
#' cli:::var_helper(x, current = 66)
#' ```

cli__pb_spin <- function(pb = getOption("cli__pb")) {
  if (is.null(pb)) return("")

  pb$spinner <- pb$spinner %||% get_spinner()
  nx <- pb$tick %% length(pb$spinner$frames) + 1L
  pb$spinner$frames[[nx]]
}

#' @name progress-variables
#' @export pb_status
#' @usage NULL
#' @aliases pb_status
#'
#' @details
#' ### `pb_status`
#'
#' The status string of the progress bar. By default this is an empty
#' string, but it is possible to set it in [cli_progress_bar()]
#' and `cli_progress_update()].
#'
#' ```{asciicast progress-var-status, echo = 2}
#' x <- invisible(quote(
#' cli_progress_bar(status = "Connecting...")
#' ))
#' cli:::var_helper(x, current = 0, delay = 1)
#' ```

cli__pb_status <- function(pb = getOption("cli__pb")) {
  if (is.null(pb)) return("")
  if (!is.null(pb$status)) {
    paste0(pb$status, " ")
  } else {
    ""
  }
}

#' @name progress-variables
#' @export pb_timestamp
#' @usage NULL
#' @aliases pb_timestamp
#'
#' @details
#' ### `pb_timestamp`
#'
#' A time stamp for the current time in ISO 8601 format.
#'
#' ```{asciicast progress-var-timestamp, echo = 2:4}
#' x <- invisible(quote(
#' cli_progress_bar(
#'   "Loading training data files",
#'   format = "{pb_timestamp} {pb_current} ({pb_rate})"
#' )
#' ))
#' cli:::var_helper(x, current = 125, delay = 5)
#' ```

cli__pb_timestamp <- function(pb = getOption("cli__pb")) {
  if (is.null(pb)) return("")
  st <- Sys.time()
  if (clienv$speed_time != 1.0) {
    st <- clienv$load_time + (st - clienv$load_time) * clienv$speed_time
  }
  format_iso_8601(st)
}

#' @name progress-variables
#' @export pb_total
#' @usage NULL
#' @aliases pb_total
#'
#' @details
#' ### `pb_total`
#'
#' The total number of progress units, or `NA` if the number of units is
#' unknown.
#'
#' ```{asciicast progress-var-current, echo = 2:5}
#' x <- invisible(quote(
#' cli_progress_bar(
#'   total = 100,
#'   format = "{cli::pb_spin} Reading file {cli::pb_current}/{cli::pb_total}"
#' )
#' ))
#' cli:::var_helper(x, current = 66)
#' ```

cli__pb_total <- function(pb = getOption("cli__pb")) {
  if (is.null(pb)) return("")
  pb$total
}

#' @name progress-variables
#' @export pb_total_bytes
#' @usage NULL
#' @aliases pb_total_bytes
#'
#' @details
#' ### `pb_total_bytes`
#'
#' The total number of progress units, formatted as
#' bytes, in a human readable format.
#'
#' ```{asciicast progress-var-rate-bytes, echo = 2:7}
#' x <- invisible(quote(
#' cli_progress_bar(
#'   total = 256 * 1024 * 1014,
#'   format = paste0(
#'     "Reading data {pb_current_bytes}/{pb_total_bytes} ",
#'     "[{ansi_trimws(pb_rate_bytes)}]"
#'   )
#' )
#' ))
#' cli:::var_helper2(x, current = 67 * 1024 * 1024, delay = 5)
#' ```

cli__pb_total_bytes <- function(pb = getOption("cli__pb")) {
  if (is.null(pb)) return("")
  format_bytes$pretty_bytes(pb$total, style = "6")
}

# ------------------------------------------------------------------------

var_helper <- function(expr, current = 66, delay = 1) {
  expr[[1]] <- quote(cli_progress_demo)
  expr$at <- current
  expr$start <- as.difftime(delay, units = "secs")
  eval(expr)
}

var_helper2 <- function(expr, clear = TRUE, delay = 0, ...) {
  expr$.envir <- environment()
  id <- eval(expr, envir = new.env())
  bar <- clienv$progress[[id]]
  bar$start <- bar$start - delay
  bar$clear <- clear
  args <- list(...)
  for (i in seq_along(args)) bar[[names(args)[i]]] <- args[[i]]
  cli_progress_update(force = TRUE, id = id)
  cat("\n")
  suppressMessages(cli_progress_done(id = id))
}

# ------------------------------------------------------------------------

#' cli progress bar demo
#'
#' Useful for experimenting with format strings and for documentation.
#' It creates a progress bar, iterates it until it terminates and saves the
#' progress updates.
#'
#' @param name Passed to [cli_progress_bar()].
#' @param status Passed to [cli_progress_bar()].
#' @param type Passed to [cli_progress_bar()].
#' @param total Passed to [cli_progress_bar()].
#' @param .envir Passed to [cli_progress_bar()].
#' @param ... Passed to [cli_progress_bar()].
#' @param at The number of progress units to show and capture the progress
#'   bar at. If `NULL`, then a sequence of states is generated to show the
#'   progress from beginning to end.
#' @param show_after Delay to show the progress bar. Overrides the
#'   `cli.progress_show_after` option.
#' @param live Whether to show the progress bat on the screen, or just
#'   return the recorded updates. Defaults to the value of the
#'   `cli.progress_demo_live` options. If unset, then it is `TRUE` in
#'   interactive sessions.
#' @param delay Delay between progress bar updates.
#' @param start Time to subtract from the start time, to simulate a
#'   progress bar that takes longer to run.
#'
#' @return List with class `cli_progress_demo`, which has a print and a
#' format method for pretty printing. The `lines` entry contains the
#' output lines, each corresponding to one update.
#'
#' @export

# TODO: examples

cli_progress_demo <- function(name = NULL, status = NULL,
                              type = c("iterator", "tasks",
                                       "download", "custom"),
                              total = NA,
                              .envir = parent.frame(),
                              ...,
                              at = if (is_interactive()) NULL else 50,
                              show_after = 0,
                              live = NULL,
                              delay = 0,
                              start = as.difftime(5, units = "secs")) {

  opt <- options(cli.progress_show_after = show_after)
  on.exit(options(opt), add = TRUE)

  live <- live %||%
    getOption("cli.progress_demo_live") %||%
    is_interactive()

  id <- cli_progress_bar(
    name = name,
    status = status,
    type = type,
    total = total,
    ...,
    .envir = .envir,
    current = FALSE
  )
  bar <- clienv$progress[[id]]
  bar$start <- bar$start - as.double(start, units = "secs")

  last <- is.null(at)
  if (is.null(at)) {
    if (is.na(total)) {
      at <- 1:5
    } else {
      at <- seq_len(total)
    }
  }

  output <- file(open = "w+b")
  on.exit(close(output), add = TRUE)
  size <- 0L

  withCallingHandlers({
    for (crnt in at) {
      cli_progress_update(set = crnt, id = id, force = TRUE, .envir = .envir)
      if (delay > 0) Sys.sleep(delay)
    }
    if (last) {
      cli_progress_done(id = id, .envir = .envir)
    } else {
      suppressMessages(cli_progress_done(id = id, .envir = .envir))
    }
  }, cliMessage = function(msg) {
    cat(file = output, msg$message)
    size <<- size + nchar(msg$message, type = "bytes")
    if (!live) invokeRestart("muffleMessage")
  })

  lines <- readChar(output, size, useBytes = TRUE)
  lines <- sub_("^\r\r*", "", lines, useBytes = TRUE)
  lines <- sub_("\r\r*$", "", lines, useBytes = TRUE)
  lines <- gsub_("\r\r*", "\r", lines, useBytes = TRUE)
  lines <- strsplit_(lines, "[\r\n]", useBytes = TRUE)[[1]]

  res <- structure(
    list(lines = lines),
    class = "cli_progress_demo"
  )

  if (live) invisible(res) else res
}

#' @export

format.cli_progress_demo <- function(x, ...) {
  x$lines
}

#' @export

print.cli_progress_demo <- function(x, ...) {
  cat(format(x, ...), sep = "\n")
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/rematch2.R"

re_match <- function(text, pattern, perl = TRUE, ...) {

  stopifnot(is.character(pattern), length(pattern) == 1, !is.na(pattern))
  text <- as.character(text)

  match <- regexpr(pattern, text, perl = perl, ...)

  start  <- as.vector(match)
  length <- attr(match, "match.length")
  end    <- start + length - 1L

  matchstr <- substring(text, start, end)
  matchstr[ start == -1 ] <- NA_character_

  empty <- data.frame(stringsAsFactors = FALSE, .text = text)[, numeric()]
  res <- list(match = !is.na(matchstr), groups = empty)

  if (!is.null(attr(match, "capture.start"))) {

    gstart  <- attr(match, "capture.start")
    glength <- attr(match, "capture.length")
    gend    <- gstart + glength - 1L

    groupstr <- substring(text, gstart, gend)
    groupstr[ gstart == -1 ] <- NA_character_
    dim(groupstr) <- dim(gstart)

    res$groups <- cbind(groupstr, res$groups, stringsAsFactors = FALSE)
    names(res$groups) <- attr(match, "capture.names")
  }

  res$groups
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/rlang.R"

#' Signal an error, warning or message with a cli formatted
#' message
#'
#' These functions let you create error, warning or diagnostic
#' messages with cli formatting, including inline styling,
#' pluralization and glue substitutions.
#'
#' @details
#'
#' ```{asciicast cli-abort}
#' n <- "boo"
#' cli_abort(c(
#'         "{.var n} must be a numeric vector",
#'   "x" = "You've supplied a {.cls {class(n)}} vector."
#' ))
#' ```
#'
#' ```{asciicast cli-abort-2}
#' len <- 26
#' idx <- 100
#' cli_abort(c(
#'         "Must index an existing element:",
#'   "i" = "There {?is/are} {len} element{?s}.",
#'   "x" = "You've tried to subset element {idx}."
#' ))
#' ```
#'
#' @param message It is formatted via a call to [cli_bullets()].
#' @param ... Passed to [rlang::abort()], [rlang::warn()] or
#'   [rlang::inform()].
#' @param .envir Environment to evaluate the glue expressions in.
#' @inheritParams rlang::abort
#'
#' @seealso These functions support [inline markup][inline-markup].
#' @family functions supporting inline markup
#' @export

cli_abort <- function(message,
                      ...,
                      call = .envir,
                      .envir = parent.frame(),
                      .frame = .envir) {
  message[] <- vcapply(message, format_inline, .envir = .envir)
  rlang::abort(
    message,
    ...,
    call = call,
    use_cli_format = TRUE,
    .frame = .frame
  )
}

#' @rdname cli_abort
#' @export

cli_warn <- function(message, ..., .envir = parent.frame()) {
  rlang::warn(
    format_warning(message, .envir = .envir),
    ...
  )
}

#' @rdname cli_abort
#' @export

cli_inform <- function(message, ..., .envir = parent.frame()) {
  rlang::inform(
    format_message(message, .envir = .envir),
    ...
  )
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/ruler.R"

#' Print the helpful ruler to the screen
#'
#' @export
#' @param width Ruler width.
#' @examples
#' ruler()

ruler <- function(width = console_width()) {
  x <- seq_len(width)
  y <- rep("-", length(x))

  y[x %% 5 == 0] <- "+"
  y[x %% 10 == 0] <- style_bold(as.character((x[x %% 10 == 0] %/% 10) %% 10))

  cat(y, "\n", sep = "")
  cat(x %% 10, "\n", sep = "")
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/rules.R"

make_line <- function(x, char = symbol$line, col = NULL) {

  ## Easiest to handle this specially
  if (x <= 0) return("")

  cw <- ansi_nchar(char, "width")

  ## We handle the simple case differently, to make it faster
  if (cw == 1) {
    line <- paste(rep(char, x), collapse = "")
  } else {
    line <- ansi_substr(paste(rep(char, ceiling(x / cw)), collapse = ""), 1, x)
  }

  unclass(apply_style(line, col))
}

#' Make a rule with one or two text labels
#'
#' @description
#' The rule can include either a centered text label, or labels on the
#' left and right side.
#'
#' To color the labels, use the functions `col_*`, `bg_*` and `style_*`
#' functions, see [ANSI styles][ansi-styles], and the examples below.
#' To color the line, either these functions directly, or the `line_col`
#' option.
#'
#'
#' @details
#' ## Simple rule
#'
#' ```{asciicast rule-simple}
#' rule()
#' ```
#'
#' ## Line styles
#' Some strings for the `line` argument are interpreted specially:
#'
#' * `"single"`: (same as `1`), a single line,
#' * `"double"`: (same as `2`), a double line,
#' * `"bar1"`, `"bar2"`, `"bar3"`, etc., `"bar8"` uses varying height bars.
#'
#' ### Double rule
#'
#' ```{asciicast rule-double}
#' rule(line = 2)
#' ```
#'
#' ### Bars
#'
#' ```{asciicast rule-bars}
#' rule(line = "bar2")
#' rule(line = "bar5")
#' ```
#'
#' ### Custom lines
#'
#' ```{asciicast rule-custom-line}
#' rule(center = "TITLE", line = "~")
#' ```
#'
#' ```{asciicast rule-custom-line-2}
#' rule(center = "TITLE", line = col_blue("~-"))
#' ```
#'
#' ```{asciicast rule-custom-line-3}
#' rule(center = bg_red(" ", symbol$star, "TITLE",
#'   symbol$star, " "),
#'   line = "\u2582",
#'   line_col = "orange")
#' ```
#'
#' ## Left label
#'
#' ```{asciicast rule-left-label}
#' rule(left = "Results")
#' ```
#'
#' ## Centered label
#'
#' ```{asciicast rule-center-label}
#' rule(center = " * RESULTS * ")
#' ```
#'
#' ## Colored labels
#'
#' ```{asciicast rule-colored-label}
#' rule(center = col_red(" * RESULTS * "))
#' ```
#'
#' ## Colored line
#'
#' ```{asciicast rule-colored-line}
#' rule(center = col_red(" * RESULTS * "), line_col = "red")
#' ```
#'
#' @param left Label to show on the left. It interferes with the `center`
#'   label, only at most one of them can be present.
#' @param center Label to show at the center. It interferes  with the
#'   `left` and `right` labels.
#' @param right Label to show on the right. It interferes with the `center`
#'   label, only at most one of them can be present.
#' @param line The character or string that is used to draw the line.
#'   It can also `1` or `2`, to request a single line (Unicode, if
#'   available), or a double line. Some strings are interpreted specially,
#'   see *Line styles* below.
#' @param col Color of text, and default line color. Either an ANSI style
#'   function (see [ANSI styles][ansi-styles]), or a color name that is
#'   passed to [make_ansi_style()].
#' @param line_col,background_col Either a color name (used in
#'   [make_ansi_style()]), or a style function (see
#'   [ANSI styles][ansi-styles]), to color the line and background.
#' @param width Width of the rule. Defaults to the `width` option, see
#'   [base::options()].
#' @return Character scalar, the rule.
#'
#' @export

rule <- function(left = "", center = "", right = "", line = 1,
                 col = NULL, line_col = col, background_col = NULL,
                 width = console_width()) {

  try_silently(left <- as.character(left))
  try_silently(center <- as.character(center))
  try_silently(right <- as.character(right))

  stopifnot(
    is_string(left),
    is_string(center),
    is_string(right),
    is_string(line) || line == 1 || line == 2,
    is_col(col),
    is_col(line_col),
    is_count(width)
  )

  left <- apply_style(left, col)
  center <- apply_style(center, col)
  right <- apply_style(right, col)

  options <- as.list(environment())
  options$line <- get_line_char(options$line)

  res <- if (ansi_nchar(center)) {
    if (ansi_nchar(left) || ansi_nchar(right)) {
      stop(sQuote("center"), " cannot be specified with ", sQuote("left"),
           " or ", sQuote("right"))
    }
    rule_center(options)

  } else if (ansi_nchar(left) && ansi_nchar(right)) {
    rule_left_right(options)

  } else if (ansi_nchar(left)) {
    rule_left(options)

  } else if (ansi_nchar(right)) {
    rule_right(options)

  } else {
    rule_line(options)
  }

  res <- ansi_substr(res, 1, width)
  res <- apply_style(res, background_col, bg = TRUE)

  class(res) <- unique(c("cli_rule", "rule", class(res), "character"))
  res
}

get_line_char <- function(line) {
  if (identical(line, 1) || identical(line, 1L) || identical(line, "single")) {
    symbol$line

  } else if (identical(line, 2) || identical(line, 2L) || identical(line, "double")) {
    symbol$double_line

  } else if (length(line) == 1 && line %in% paste0("bar", 1:8)) {
    bars <- structure(
      paste0("lower_block_", 1:8),
      names = paste0("bar", 1:8)
    )
    symbol[[ bars[[line]] ]]

  } else {
    paste(as.character(line), collapse = "")
  }
}

rule_line <- function(o) {
  make_line(o$width, o$line, o$line_col)
}

rule_center <- function(o) {

  o$center <- ansi_substring(o$center, 1, o$width - 4)
  o$center <- paste0(" ", o$center, " ")
  ncc <- ansi_nchar(o$center, "width")

  ndashes <- o$width - ncc

  paste0(
    make_line(ceiling(ndashes / 2), o$line, o$line_col),
    o$center,
    make_line(floor(ndashes / 2), o$line, o$line_col)
  )
}

rule_left <- function(o) {
  ncl <- ansi_nchar(o$left, "width")

  paste0(
    make_line(2, get_line_char(o$line), o$line_col),
    " ", o$left, " ",
    make_line(o$width - ncl - 4, o$line, o$line_col)
  )
}

rule_right <- function(o) {
  ncr <- ansi_nchar(o$right, "width")

  paste0(
    make_line(o$width - ncr - 4, o$line, o$line_col),
    " ", o$right, " ",
    make_line(2, o$line, o$line_col)
  )
}

rule_left_right <- function(o) {

  ncl <- ansi_nchar(o$left, "width")
  ncr <- ansi_nchar(o$right,  "width")

  ## -- (ncl) -- (ncr) --
  if (ncl + ncr + 10 > o$width) return(rule_left(o))

  paste0(
    make_line(2, o$line, o$line_col),
    " ", o$left, " ",
    make_line(o$width - ncl - ncr - 8, o$line, o$line_col),
    " ", o$right, " ",
    make_line(2, o$line, o$line_col)
  )
}

methods::setOldClass(c("cli_rule", "character"))

#' @export

print.cli_rule <- function(x, ..., sep = "\n") {
  cat(x, ..., sep = sep)
  invisible(x)
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/server.R"

cli_server_default <- function(msg) {
  cli_server_default_safe(msg)
}

cli_server_default_safe <- function(msg) {
  type <- as.character(msg$type)[1]
  app <- default_app() %||% start_app(.auto_close = FALSE)
  do.call(app[[type]], msg$args)
}

cli_server_callr_handler <- function(msg) {
  cli_server_default(msg)
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/simple-theme.R"

#' A simple CLI theme
#'
#' To use this theme, you can set it as the `cli.theme` option.
#' Note that this is in addition to the builtin theme, which is still in
#' effect.
#'
#' ```r
#' options(cli.theme = cli::simple_theme())
#' ```
#'
#' and then CLI apps started after this will use it as the default theme.
#' You can also use it temporarily, in a div element:
#'
#' ```r
#' cli_div(theme = cli::simple_theme())
#' ```
#'
#' # Showcase
#'
#' ```{asciicast simple-theme}
#' show <- cli_div(theme = cli::simple_theme())
#'
#' cli_h1("Heading 1")
#' cli_h2("Heading 2")
#' cli_h3("Heading 3")
#'
#' cli_par()
#' cli_alert_danger("Danger alert")
#' cli_alert_warning("Warning alert")
#' cli_alert_info("Info alert")
#' cli_alert_success("Success alert")
#' cli_alert("Alert for starting a process or computation",
#'   class = "alert-start")
#' cli_end()
#'
#' cli_text("Packages and versions: {.pkg cli} {.version 1.0.0}.")
#' cli_text("Time intervals: {.timestamp 3.4s}")
#'
#' cli_text("{.emph Emphasis} and  {.strong strong emphasis}")
#'
#' cli_text("This is a piece of code: {.code sum(x) / length(x)}")
#' cli_text("Function names: {.fn cli::simple_theme}")
#'
#' cli_text("Files: {.file /usr/bin/env}")
#' cli_text("URLs: {.url https://r-project.org}")
#'
#' cli_h2("Longer code chunk")
#' cli_par(class = "code R")
#' cli_verbatim(
#'   '# window functions are useful for grouped mutates',
#'   'mtcars %>%',
#'   '  group_by(cyl) %>%',
#'   '  mutate(rank = min_rank(desc(mpg)))')
#'
#' cli_end(show)
#' ```
#'
#' @param dark Whether the theme should be optimized for a dark
#'   background. If `"auto"`, then cli will try to detect this.
#'   Detection usually works in recent RStudio versions, and in iTerm
#'   on macOS, but not on other platforms.
#'
#' @seealso [themes], [builtin_theme()].
#' @export

simple_theme <- function(dark = getOption("cli.theme_dark", "auto")) {

  dark <- detect_dark_theme(dark)

  list(
    h1 = list(
      "margin-top" = 1,
      "margin-bottom" = 0,
      color = "cyan",
      fmt = function(x) cli::rule(x, line_col = "cyan")),

    h2 = list(
      "margin-top" = 1,
      "margin-bottom" = 0,
      color = "cyan",
      fmt = function(x) paste0(symbol$line, " ", x, " ", symbol$line, symbol$line)),

    h3 = list(
      "margin-top" = 1,
      "margin-bottom" = 0,
      color = "cyan"),

    par = list("margin-top" = 0, "margin-bottom" = 1),

    ".alert-danger" = list(
      "background-color" = "red",
      color = "white",
      before = function() paste0(symbol$cross, " ")
    ),

    ".alert-warning" = list(
      color = "orange",
      "font-weight" = "bold",
      before = paste0("!", " ")
    ),

    ".alert-success" = list(
      before = function() paste0(col_green(symbol$tick), " ")
    ),
    ".alert-info" = list(
      before = function() paste0(col_cyan(symbol$info), " ")
    ),

    ".alert-start" = list(
      before = function() paste0(symbol$arrow_right, " ")),

    span.pkg = list(
      color = "blue",
      "font-weight" = "bold"),
    span.version = list(color = "blue"),

    span.emph = simple_theme_emph(),
    span.strong = list("font-weight" = "bold", "font-style" = "italic"),

    span.fun = utils::modifyList(simple_theme_code(dark), list(after = "()")),
    span.fn = utils::modifyList(simple_theme_code(dark), list(after = "()")),
    span.arg = simple_theme_code(dark),
    span.kbd = utils::modifyList(simple_theme_code(dark),
                          list(before = "<", after = ">")),
    span.key = utils::modifyList(simple_theme_code(dark),
                          list(before = "<", after = ">")),
    span.file = simple_theme_file(),
    span.path = simple_theme_file(),
    span.email = simple_theme_url(),
    span.url = utils::modifyList(simple_theme_url(),
                          list(before = "<", after = ">")),
    span.var = simple_theme_code(dark),
    span.envvar = simple_theme_code(dark),

    span.timestamp = list(before = "[", after = "]", color = "grey")
  )
}

simple_theme_emph <- function() {
  list("font-style" = "italic")
}

simple_theme_url <- function() {
  list(color = "blue")
}

simple_theme_code <- function(dark) {
  if (dark) {
    list("background-color" = "#232323", color = "#f0f0f0")
  } else{
    list("background-color" = "#f8f8f8", color = "#202020")
  }
}

simple_theme_file <- function() {
  list(color = "blue")
}

simple_theme_r_code <- function(dark) {
  dark <- dark
  style <- if (dark) {
    make_ansi_style("#f0f0f0")
  } else {
    make_ansi_style("#202020")
  }
  function(x) {
    x <- ansi_strip(x)
    lines <- strsplit(x, "\n", fixed = TRUE)[[1]]
    fmd <- code_highlight(lines)
    style(fmd)
  }
}

is_iterm <- function() {
  isatty(stdout()) && Sys.getenv("TERM_PROGRAM", "") == "iTerm.app"
}

is_iterm_dark <- function() {
  if (is.null(clienv[["is_iterm_dark"]])) {
    clienv$is_iterm_dark <-
      tryCatch(
        error = function(x) FALSE, {
          osa <- '
            tell application "iTerm2"
              tell current session of current window
                get background color
              end tell
            end tell
          '
          out <- suppressWarnings(system2(
            "osascript",
            c("-e", shQuote(osa)),
            stdout = TRUE,
            stderr = TRUE
          ))
          nums <- scan(text = gsub(",", "", out, fixed = TRUE), quiet = TRUE)
          mean(nums) < 20000
        })
  }
  clienv[["is_iterm_dark"]]
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/sitrep.R"

#' cli situation report
#'
#' Contains currently:
#' * `cli_unicode_option`: whether the `cli.unicode` option is set and its
#'   value. See [is_utf8_output()].
#' * `symbol_charset`: the selected character set for [symbol], UTF-8,
#'   Windows, or ASCII.
#' * `console_utf8`: whether the console supports UTF-8. See
#'   [base::l10n_info()].
#' * `latex_active`: whether we are inside knitr, creating a LaTeX
#'   document.
#' * `num_colors`: number of ANSI colors. See [num_ansi_colors()].
#' * `console_with`: detected console width.
#'
#' @return Named list with entries listed above. It has a `cli_sitrep`
#' class, with a `print()` and `format()` method.
#'
#' @export
#' @examples
#' cli_sitrep()

cli_sitrep <- function() {
  structure(
    list(
      cli_unicode_option = getOption("cli.unicode", NULL),
      symbol_charset = get_active_symbol_set(),
      console_utf8 = l10n_info()$`UTF-8`,
      latex_active = is_latex_output(),
      num_colors = num_ansi_colors(),
      console_width = console_width()),
    class = "cli_sitrep")
}

#' @export

print.cli_sitrep <- function(x, ...) {
  cat(format(x, ...), sep = "\n")
  invisible(x)
}

get_active_symbol_set <- function() {
  if (identical(symbol, symbol_utf8)) {
    "UTF-8"
  } else {
    "ASCII (non UTF-8)"
  }
}

#' @export

format.cli_sitrep <- function(x, ...) {
  fmt_names <- format(names(x))
  fmt_vals  <- vapply(x, format, character(1))
  paste0("- ", fmt_names, " : ", fmt_vals)
}

#' @export

as.character.cli_sitrep <- function(x, ...) {
  "<cli sitrep>"
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/sizes.R"

format_bytes <- local({

  pretty_bytes <- function(bytes, style = c("default", "nopad", "6")) {

    style <- switch(
      match.arg(style),
      "default" = pretty_bytes_default,
      "nopad" = pretty_bytes_nopad,
      "6" = pretty_bytes_6
    )

    style(bytes)
  }

  compute_bytes <- function(bytes, smallest_unit = "B") {
    units0 <- c("B", "kB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB")

    stopifnot(
      is.numeric(bytes),
      is.character(smallest_unit),
      length(smallest_unit) == 1,
      !is.na(smallest_unit),
      smallest_unit %in% units0
    )

    limits <- c(1000, 999950 * 1000 ^ (seq_len(length(units0) - 2) - 1))
    low <- match(smallest_unit, units0)
    units <- units0[low:length(units0)]
    limits <- limits[low:length(limits)]

    neg <- bytes < 0 & !is.na(bytes)
    bytes <- abs(bytes)

    mat <- matrix(
      rep(bytes, each = length(limits)),
      nrow = length(limits),
      ncol = length(bytes)
    )
    mat2 <- matrix(mat < limits, nrow  = length(limits), ncol = length(bytes))
    exponent <- length(limits) - colSums(mat2) + low - 1L
    res <- bytes / 1000 ^ exponent
    unit <- units[exponent - low + 2L]

    ## Zero bytes
    res[bytes == 0] <- 0
    unit[bytes == 0] <- units[1]

    ## NA and NaN bytes
    res[is.na(bytes)] <- NA_real_
    res[is.nan(bytes)] <- NaN
    unit[is.na(bytes)] <- units0[low]     # Includes NaN as well

    data.frame(
      stringsAsFactors = FALSE,
      amount = res,
      unit = unit,
      negative = neg
    )
  }

  pretty_bytes_default <- function(bytes) {
    szs <- compute_bytes(bytes)
    amt <- szs$amount

    ## String. For fractions we always show two fraction digits
    res <- character(length(amt))
    int <- is.na(amt) | amt == as.integer(amt)
    res[int] <- format(
      ifelse(szs$negative[int], -1, 1) * amt[int],
      scientific = FALSE
    )
    res[!int] <- sprintf("%.2f", ifelse(szs$negative[!int], -1, 1) * amt[!int])

    format(paste(res, szs$unit), justify = "right")
  }

  pretty_bytes_nopad <- function(bytes) {
    sub("^\\s+", "", pretty_bytes_default(bytes))
  }

  pretty_bytes_6 <- function(bytes) {
    szs <- compute_bytes(bytes, smallest_unit = "kB")
    amt <- szs$amount

    na   <- is.na(amt)
    nan  <- is.nan(amt)
    neg  <- !na & !nan & szs$negative
    l10  <- !na & !nan & !neg & amt < 10
    l100 <- !na & !nan & !neg & amt >= 10 & amt < 100
    b100 <- !na & !nan & !neg & amt >= 100

    szs$unit[neg] <- "kB"

    famt <- character(length(amt))
    famt[na] <- " NA"
    famt[nan] <- "NaN"
    famt[neg] <- "< 0"
    famt[l10] <- sprintf("%.1f", amt[l10])
    famt[l100] <- sprintf(" %.0f", amt[l100])
    famt[b100] <- sprintf("%.0f", amt[b100])

    paste0(famt, " ", szs$unit)
  }

  structure(
    list(
      .internal     = environment(),
      pretty_bytes  = pretty_bytes,
      compute_bytes = compute_bytes
    ),
    class = c("standalone_bytes", "standalone")
  )
})
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/spark.R"

# from pillar

#' Draw a sparkline bar graph with unicode block characters
#'
#' @description
#' Rendered using [block elements](https://en.wikipedia.org/wiki/Block_Elements).
#' In most common fixed width fonts these are rendered wider than regular
#' characters which means they are not suitable if you need precise alignment.
#'
#' You might want to avoid sparklines on non-UTF-8 systems, because they
#' do not look good. You can use [is_utf8_output()] to test for support
#' for them.
#'
#' @details
#'
#' ```{asciicast spark-bar-1}
#' x <- seq(0, 1, length = 6)
#' spark_bar(x)
#' ```
#'
#' ```{asciicast spark-bar-2}
#' x <- seq(0, 1, length = 6)
#' spark_bar(sample(x))
#' ```
#'
#' ```{asciicast spark-bar-3}
#' spark_bar(seq(0, 1, length = 8))
#' ```
#'
#' `NA`s are left out:
#'
#' ```{asciicast spark-bar-na}
#' spark_bar(c(0, NA, 0.5, NA, 1))
#' ```
#'
#' @param x A numeric vector between 0 and 1
#' @export
#' @seealso [spark_line()]

spark_bar <- function(x) {
  stopifnot(is.numeric(x))

  chars <- spark_bar_chars(x)

  structure(
    paste0(chars, collapse = ""),
    class = c("cli_spark_bar", "cli_spark")
  )
}

#' @export

format.cli_spark <- function(x, ...) {
  unclass(x)
}

#' @export

print.cli_spark <- function(x, ...) {
  cat(format(x, ...), sep = "\n")
}

spark_bar_chars <- function(x, bars = NULL) {

  if (is.null(bars)) {
    if (is_utf8_output()) {
      bars <- vapply(0x2581:0x2588, intToUtf8, character(1))
    } else {
      bars <- c("_", ",", "*", "#")
    }
  }

  factor <- cut(
    x,
    breaks = seq(0, 1, length.out = length(bars) + 1),
    labels = bars,
    include.lowest = TRUE
  )
  chars <- as.character(factor)
  chars[is.na(chars)] <- " "

  chars
}

#' Draw a sparkline line graph with Braille characters.
#'
#' You might want to avoid sparklines on non-UTF-8 systems, because they
#' do not look good. You can use [is_utf8_output()] to test for support
#' for them.
#'
#' @details
#'
#' ```{asciicast spark-line}
#' x <- seq(0, 1, length = 10)
#' spark_line(x)
#' ```
#'
#' @inheritParams spark_bar
#' @export
#' @seealso [spark_bar()]

spark_line <- function(x) {
  stopifnot(is.numeric(x))

  if (length(x) %% 2 == 1) {
    x <- c(x, NA)
  }

  if (is_utf8_output()) {
    y <- findInterval(x, seq(0, 1, length.out = 5), all.inside = TRUE)
    ind <- matrix(y, ncol = 2, byrow = TRUE)
    ind[, 2] <- ind[, 2] + 4
    chars <- apply(ind, 1, braille)
  } else {
    ind <- matrix(x, ncol = 2, byrow = TRUE)
    bars <- c("_", ",", "-", "^")
    chars <- spark_bar_chars(apply(ind, 1, mean), bars)
  }

  structure(
    paste0(chars, collapse = ""),
    class = c("cli_spark_line", "cli_spark")
  )
}

# https://en.wikipedia.org/wiki/Braille_Patterns
braille <- function(x) {
  # remap to braille sequence
  x <- c(7L, 3L, 2L, 1L, 8L, 6L, 5L, 4L)[x]

  raised <- 1:8 %in% x
  binary <- raised * 2^(0:7)

  # offset in hex is 2800
  val <- 10240 + sum(raised * 2^(0:7))

  intToUtf8(val)
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/spinner.R"

## See tools/spinners.R for how the RDS file is created

#' Character vector to put a spinner on the screen
#'
#' `cli` contains many different spinners, you choose one according to your
#' taste.
#'
#' ```{asciicast get-spinner}
#' #| asciicast_at = "all",
#' #| asciicast_knitr_output = "svg",
#' #| asciicast_cursor = FALSE
#' options(cli.spinner = "hearts")
#' fun <- function() {
#'   cli_progress_bar("Spinning")
#'   for (i in 1:100) {
#'     Sys.sleep(4/100)
#'     cli_progress_update()
#'   }
#' }
#' fun()
#' options(cli.spinner = NULL)
#' ```
#'
#' @param which The name of the chosen spinner. If `NULL`, then the default
#'   is used, which can be customized via the `cli.spinner_unicode`,
#'   `cli.spinner_ascii` and `cli.spinner` options. (The latter applies to
#'   both Unicode and ASCII displays. These options can be set to the name
#'   of a built-in spinner, or to a list that has an entry called `frames`,
#'   a character vector of frames.
#' @return A list with entries: `name`, `interval`: the suggested update
#'   interval in milliseconds and `frames`: the character vector of the
#'   spinner's frames.
#'
#' @family spinners
#' @export

get_spinner <- function(which = NULL) {
  stopifnot(is.null(which) || is_string(which) || is.list(which))

  if (is.null(which)) {
    if (is_utf8_output()) {
      which <-
        getOption("cli.spinner_unicode") %||%
        getOption("cli.spinner") %||%
        "dots"
    } else {
      which <-
        getOption("cli.spinner_ascii") %||%
        getOption("cli.spinner") %||%
        "line"
    }
  }

  if (is.character(which)) {
    row <- match(which, spinners$name)
    which <- list(
      name = which,
      interval = spinners$interval[[row]],
      frames = spinners$frames[[row]])
  }

  if (!is.character(which$frames)) {
    stop("Spinner frames must be a character vector")
  }

  which$name <- which$name %||% NA_character_
  which$interval <- which$interval %||% 100L

  which
}

#' List all available spinners
#'
#' @return Character vector of all available spinner names.
#'
#' @family spinners
#' @export
#' @examples
#' list_spinners()
#' get_spinner(list_spinners()[1])

list_spinners <- function() {
  spinners$name
}

#' Create a spinner
#'
#' @param template A template string, that will contain the spinner. The
#'   spinner itself will be substituted for `{spin}`. See example below.
#' @param stream The stream to use for the spinner. Typically this is
#'   standard error, or maybe the standard output stream.
#'   It can also be a string, one of `"auto"`, `"message"`, `"stdout"`,
#'   `"stderr"`. `"auto"` will select `stdout()` if the session is
#'   interactive and there are no sinks, otherwise it will select
#'   `stderr()`.
#' @param static What to do if the terminal does not support dynamic
#'   displays:
#'   * `"dots"`: show a dot for each `$spin()` call.
#'   * `"print"`: just print the frames of the spinner, one after another.
#'   * `"print_line"`: print the frames of the spinner, each on its own line.
#'   * `"silent"` do not print anything, just the `template`.
#' @inheritParams get_spinner
#' @return A `cli_spinner` object, which is a list of functions. See
#'   its methods below.
#'
#' `cli_spinner` methods:
#' * `$spin()`: output the next frame of the spinner.
#' * `$finish()`: terminate the spinner. Depending on terminal capabilities
#'   this removes the spinner from the screen. Spinners can be reused,
#'   you can start calling the `$spin()` method again.
#'
#' All methods return the spinner object itself, invisibly.
#'
#' The spinner is automatically throttled to its ideal update frequency.
#'
#' @section Examples:
#'
#' ## Default spinner
#'

#' ```{asciicast make-spinner-default}
#' #| asciicast_at = "all",
#' #| asciicast_knitr_output = "svg",
#' #| asciicast_cursor = FALSE,
#' #| asciicast_end_wait = 0
#' sp1 <- make_spinner()
#' fun_with_spinner <- function() {
#'   lapply(1:100, function(x) { sp1$spin(); Sys.sleep(0.05) })
#'   sp1$finish()
#' }
#' ansi_with_hidden_cursor(fun_with_spinner())
#' ```
#'
#' ## Spinner with a template
#'
#' ```{asciicast make-spinner-template}
#' #| asciicast_at = "all",
#' #| asciicast_knitr_output = "svg",
#' #| asciicast_cursor = FALSE,
#' #| asciicast_end_wait = 0
#' sp2 <- make_spinner(template = "Computing {spin}")
#' fun_with_spinner2 <- function() {
#'   lapply(1:100, function(x) { sp2$spin(); Sys.sleep(0.05) })
#'   sp2$finish()
#' }
#' ansi_with_hidden_cursor(fun_with_spinner2())
#' ```
#'
#' ## Custom spinner
#'
#' ```{asciicast make-spinner-custom}
#' #| asciicast_at = "all",
#' #| asciicast_knitr_output = "svg",
#' #| asciicast_cursor = FALSE
#' sp3 <- make_spinner("simpleDotsScrolling", template = "Downloading {spin}")
#' fun_with_spinner3 <- function() {
#'   lapply(1:100, function(x) { sp3$spin(); Sys.sleep(0.05) })
#'   sp3$finish()
#' }
#' ansi_with_hidden_cursor(fun_with_spinner3())
#' ```
#'
#' @family spinners
#' @export

make_spinner <- function(which = NULL, stream = "auto", template = "{spin}",
                         static = c("dots", "print", "print_line",
                                    "silent")) {

  stopifnot(
    inherits(stream, "connection") || is_string(stream),
    is_string(template))

  c_stream <- get_real_output(stream)
  c_spinner <- get_spinner(which)
  c_template <- template
  c_static <- match.arg(static)
  c_state <- 1L
  c_first <- TRUE
  c_col <- 1L
  c_width <- 0L
  c_last <- Sys.time() - as.difftime(1, units = "secs")
  c_int <- as.difftime(c_spinner$interval / 1000, units = "secs")

  c_res <- list()

  throttle <- function() Sys.time() - c_last < c_int
  clear_line <- function() {
    str <- paste0(c("\r", rep(" ", c_width), "\r"), collapse = "")
    cat(str, file = c_stream)
  }
  inc <- function() {
    c_state <<- c_state + 1L
    c_first <<- FALSE
    if (c_state > length(c_spinner$frames)) c_state <<- 1L
    c_last <<- Sys.time()
    invisible(c_res)
  }

  c_res$finish <- function() {
    c_state <<- 1L
    c_first <<- TRUE
    c_col <<- 1L
    c_last <<- Sys.time()
    if (is_dynamic_tty(c_stream)) clear_line() else cat("\n", file = c_stream)
    invisible(c_res)
  }

  if (is_dynamic_tty(c_stream)) {
    c_res$spin <- function(template = NULL) {
      if (!is.null(template)) c_template <<- template
      if (throttle()) return()
      line <- sub("{spin}", c_spinner$frames[[c_state]], c_template,
                  fixed = TRUE)
      line_width <- ansi_nchar(line)
      if (is_ansi_tty(c_stream)) {
        cat("\r", line, ANSI_EL, sep = "", file = c_stream)
      } else {
        # extra padding in case the line width has changed
        # so that we don't get any garbage in the output
        padding <- if (line_width < c_width) {
          paste0(rep(" ", line_width), collapse = "")
        } else {
          ""
        }
        cat("\r", line, padding, sep = "", file = c_stream)
      }
      # save the new line width
      c_width <<- line_width
      inc()
    }

  } else {
    if (c_static == "dots") {
      c_res$spin <- function(template = NULL) {
        if (!is.null(template)) c_template <<- template
        if (c_first) cat(template, "\n", sep = "", file = c_stream)
        if (throttle()) return()
        cat(".", file = c_stream)
        c_col <<- c_col + 1L
        if (c_col == console_width()) {
          cat("\n", file = c_stream)
          c_col <<- 1L
        }
        inc()
      }
    } else if (c_static == "print") {
      c_res$spin <- function(template = NULL) {
        if (!is.null(template)) c_template <<- template
        if (throttle()) return()
        line <- sub("{spin}", c_spinner$frames[[c_state]], c_template,
                    fixed = TRUE)
        cat(line, file = c_stream)
        inc()
      }
    } else if (c_static == "print_line") {
      c_res$spin <- function(template = NULL) {
        if (!is.null(template)) c_template <<- template
        if (throttle()) return()
        line <- sub("{spin}", c_spinner$frames[[c_state]], c_template,
                    fixed = TRUE)
        cat(line, "\n", sep = "", file = c_stream)
        inc()
      }
    } else if (c_static == "silent") {
      c_res$spin <- function(template = NULL) {
        if (!is.null(template)) c_template <<- template
        if (throttle()) return()
        inc()
      }
    }
  }

  class(c_res) <- "cli_spinner"
  c_res
}

#' @export

print.cli_spinner <- function(x, ...) {
  cat("<cli_spinner>\n")
  invisible(x)
}

## nocov start

#' Show a demo of some (by default all) spinners
#'
#' Each spinner is shown for about 2-3 seconds.
#'
#' @details
#'
#' ```{asciicast demo-spinners}
#' #| asciicast_at = "all",
#' #| asciicast_knitr_output = "svg",
#' #| asciicast_cursor = FALSE,
#' #| asciicast_end_wait = 0
#' demo_spinners("clock")
#' ```
#'
#' @param which Character vector, which spinners to demo.
#'
#' @family spinners
#' @export

demo_spinners <- function(which = NULL) {
  stopifnot(is.null(which) || is.character(which))

  all <- list_spinners()
  which <- which %||% all

  if (length(bad <- setdiff(which, all))) {
    stop("Unknown spinners: ", paste(bad, collapse = ", "))
  }

  for (w in which) {
    sp <- get_spinner(w)
    interval <- sp$interval / 1000
    frames <- sp$frames
    cycles <- max(round(2.5 / ((length(frames) - 1) * interval)), 1)
    for (i in 1:(length(frames) * cycles) - 1) {
      fr <- unclass(frames[i %% length(frames) + 1])
      cat("\r", rpad(fr, width = 10), w, sep = "")
      Sys.sleep(interval)
    }
    cat("\n")
  }
}

demo_spinners_terminal <- function(ticks = 100 * 3000) {
  up <- function(n) cat(paste0("\u001B[", n, "A"))
  show <- function() cat("\u001b[?25h")
  hide <- function() cat("\u001b[?25l")

  on.exit(show(), add = TRUE)

  names <- unlist(spinners$name)
  frames <- spinners$frames
  intervals <- unlist(spinners$interval)
  num_frames <- viapply(frames, length)
  spin_width <- viapply(frames, function(x) max(nchar(x, type = "width")))
  name_width <- nchar(names, type = "width")
  col_width <- spin_width + max(name_width) + 3
  col1_width <- max(col_width[1:(length(col_width)/2)])

  frames <- mapply(
    frames,
    names,
    FUN = function(f, n) {
      rpad(paste(lpad(n, max(name_width) + 2), f), col1_width)
    }
  )

  hide()

  for (tick in 0:ticks) {
    tic <- Sys.time()
    wframe <- trunc(tick / intervals) %% num_frames + 1
    sp <- mapply(frames, wframe, FUN = "[")

    sp2 <- paste(
      sep = "  ",
      sp[1:(length(sp) / 2)],
      sp[(length(sp) / 2 + 1):length(sp)]
    )

    cat(sp2, sep = "\n")
    up(length(sp2))
    took <- Sys.time() - tic
    togo <- as.difftime(1/1000, units = "secs") - took
    if (togo > 0) Sys.sleep(togo)
  }

}

## nocov end
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/status-bar.R"

#' Update the status bar (superseded)
#'
#' @description
#' **The `cli_status_*()` functions are superseded by
#' the [cli_progress_message()] and [cli_progress_step()] functions,
#' because they have a better default behavior.**
#'
#' The status bar is the last line of the terminal. cli apps can use this
#' to show status information, progress bars, etc. The status bar is kept
#' intact by all semantic cli output.
#'
#' @details
#' Use [cli_status_clear()] to clear the status bar.
#'
#' Often status messages are associated with processes. E.g. the app starts
#' downloading a large file, so it sets the status bar accordingly. Once the
#' download is done (or has failed), the app typically updates the status bar
#' again. cli automates much of this, via the `msg_done`, `msg_failed`, and
#' `.auto_result` arguments. See examples below.
#'
#' @param msg The text to show, a character vector. It will be
#'   collapsed into a single string, and the first line is kept and cut to
#'   [console_width()]. The message is often associated with the start of
#'   a calculation.
#' @param msg_done The message to use when the message is cleared, when
#'   the calculation finishes successfully. If `.auto_close` is `TRUE`
#'   and `.auto_result` is `"done"`, then this is printed automatically
#'   when the calling function (or `.envir`) finishes.
#' @param msg_failed The message to use when the message is cleared, when
#'   the calculation finishes unsuccessfully. If `.auto_close` is `TRUE`
#'   and `.auto_result` is `"failed"`, then this is printed automatically
#'   when the calling function (or `.envir`) finishes.
#' @param .keep What to do when this status bar is cleared. If `TRUE` then
#'   the content of this status bar is kept, as regular cli output (the
#'   screen is scrolled up if needed). If `FALSE`, then this status bar
#'   is deleted.
#' @param .auto_close Whether to clear the status bar when the calling
#'   function finishes (or `.envir` is removed from the stack, if
#'   specified).
#' @param .envir Environment to evaluate the glue expressions in. It is
#'   also used to auto-clear the status bar if `.auto_close` is `TRUE`.
#' @param .auto_result What to do when auto-closing the status bar.
#' @return The id of the new status bar container element, invisibly.
#'
#' @seealso Status bars support [inline markup][inline-markup].
#' @seealso The [cli_progress_message()] and [cli_progress_step()]
#'   functions, for a superior API.
#' @family status bar
#' @family functions supporting inline markup
#' @export

cli_status <- function(msg, msg_done = paste(msg, "... done"),
                       msg_failed = paste(msg, "... failed"),
                       .keep = FALSE, .auto_close = TRUE,
                       .envir = parent.frame(),
                       .auto_result = c("clear", "done", "failed", "auto")) {

  id <- new_uuid()
  cli__message(
    "status",
    list(
      id = id,
      msg = glue_cmd(msg, .envir = .envir),
      msg_done = glue_cmd(msg_done, .envir = .envir),
      msg_failed = glue_cmd(msg_failed, .envir = .envir),
      keep = .keep,
      auto_result = match.arg(.auto_result),
      globalenv = identical(.envir, .GlobalEnv)
    ),
    .auto_close = .auto_close,
    .envir = .envir
  )

  invisible(id)
}

#' Clear the status bar (superseded)
#'
#' @description
#' **The `cli_status_*()` functions are superseded by
#' the [cli_progress_message()] and [cli_progress_step()] functions,
#' because they have a better default behavior.**
#'
#' Clear the status bar
#'
#' @param id Id of the status bar container to clear. If `id` is not the id
#'   of the current status bar (because it was overwritten by another
#'   status bar container), then the status bar is not cleared. If `NULL`
#'   (the default) then the status bar is always cleared.
#' @param result Whether to show a message for success or failure or just
#'   clear the status bar.
#' @param msg_done If not `NULL`, then the message to use for successful
#'   process termination. This overrides the message given when the status
#'   bar was created.
#' @param msg_failed If not `NULL`, then the message to use for failed
#'   process termination. This overrides the message give when the status
#'   bar was created.
#' @inheritParams cli_status
#'
#' @family status bar
#' @seealso The [cli_progress_message()] and [cli_progress_step()]
#'   functions, for a superior API.
#' @export

cli_status_clear <- function(id = NULL, result = c("clear", "done", "failed"),
                             msg_done = NULL, msg_failed = NULL,
                             .envir = parent.frame()) {

  cli__message(
    "status_clear",
    list(
      id = id %||% NA_character_,
      result = match.arg(result[1], c("clear", "done", "failed", "auto")),
      msg_done = if (!is.null(msg_done)) glue_cmd(msg_done, .envir = .envir),
      msg_failed = if (!is.null(msg_failed)) glue_cmd(msg_failed, .envir = .envir)
    )
  )
}

#' Update the status bar (superseded)
#'
#' @description
#' **The `cli_status_*()` functions are superseded by
#' the [cli_progress_message()] and [cli_progress_step()] functions,
#' because they have a better default behavior.**
#'
#' Update the status bar
#'
#' @param msg Text to update the status bar with. `NULL` if you don't want
#'   to change it.
#' @param msg_done Updated "done" message. `NULL` if you don't want to
#'   change it.
#' @param msg_failed Updated "failed" message. `NULL` if you don't want to
#'   change it.
#' @param id Id of the status bar to update. Defaults to the current
#'   status bar container.
#' @param .envir Environment to evaluate the glue expressions in.
#' @return Id of the status bar container.
#'
#' @seealso This function supports [inline markup][inline-markup].
#' @seealso The [cli_progress_message()] and [cli_progress_step()]
#'   functions, for a superior API.
#' @family status bar
#' @family functions supporting inline markup
#' @export

cli_status_update <- function(id = NULL, msg = NULL, msg_done = NULL,
                              msg_failed = NULL, .envir = parent.frame()) {
  cli__message(
    "status_update",
    list(
      msg = if (!is.null(msg)) glue_cmd(msg, .envir = .envir),
      msg_done = if (!is.null(msg_done)) glue_cmd(msg_done, .envir = .envir),
      msg_failed = if (!is.null(msg_failed)) glue_cmd(msg_failed, .envir = .envir),
      id = id %||% NA_character_
    )
  )
}

#' Indicate the start and termination of some computation in the status bar
#' (superseded)
#'
#' @description
#' **The `cli_process_*()` functions are superseded by
#' the [cli_progress_message()] and [cli_progress_step()] functions,
#' because they have a better default behavior.**
#'
#' Typically you call `cli_process_start()` to start the process, and then
#' `cli_process_done()` when it is done. If an error happens before
#' `cli_process_done()` is called, then cli automatically shows the message
#' for unsuccessful termination.
#'
#' @details
#' If you handle the errors of the process or computation, then you can do
#' the opposite: call `cli_process_start()` with `on_exit = "done"`, and
#' in the error handler call `cli_process_failed()`. cli will automatically
#' call `cli_process_done()` on successful termination, when the calling
#' function finishes.
#'
#' See examples below.
#'
#' @param msg The message to show to indicate the start of the process or
#'   computation. It will be collapsed into a single string, and the first
#'   line is kept and cut to [console_width()].
#' @param msg_done The message to use for successful termination.
#' @param msg_failed The message to use for unsuccessful termination.
#' @param on_exit Whether this process should fail or terminate
#'   successfully when the calling function (or the environment in `.envir`)
#'   exits.
#' @param msg_class The style class to add to the message. Use an empty
#'   string to suppress styling.
#' @param done_class The style class to add to the successful termination
#'   message. Use an empty string to suppress styling.a
#' @param failed_class The style class to add to the unsuccessful
#'   termination message. Use an empty string to suppress styling.a
#' @inheritParams cli_status
#' @return Id of the status bar container.
#'
#' @seealso This function supports [inline markup][inline-markup].
#' @seealso The [cli_progress_message()] and [cli_progress_step()]
#'   functions, for a superior API.
#' @family status bar
#' @family functions supporting inline markup
#' @export
#' @examples
#'
#' ## Failure by default
#' fun <- function() {
#'   cli_process_start("Calculating")
#'   if (interactive()) Sys.sleep(1)
#'   if (runif(1) < 0.5) stop("Failed")
#'   cli_process_done()
#' }
#' tryCatch(fun(), error = function(err) err)
#'
#' ## Success by default
#' fun2 <- function() {
#'   cli_process_start("Calculating", on_exit = "done")
#'   tryCatch({
#'     if (interactive()) Sys.sleep(1)
#'     if (runif(1) < 0.5) stop("Failed")
#'   }, error = function(err) cli_process_failed())
#' }
#' fun2()

cli_process_start <- function(msg, msg_done = paste(msg, "... done"),
                              msg_failed = paste(msg, "... failed"),
                              on_exit = c("auto", "failed", "done"),
                              msg_class = "alert-info",
                              done_class = "alert-success",
                              failed_class = "alert-danger",
                              .auto_close = TRUE, .envir = parent.frame()) {

  # Force the defaults, because we might modify msg
  msg_done
  msg_failed

  if (length(msg_class) > 0 && msg_class != "") {
    msg <- paste0("{.", msg_class, " ", msg, "}")
  }
  if (length(done_class) > 0 && done_class != "") {
    msg_done <- paste0("{.", done_class, " ", msg_done, "}")
  }
  if (length(failed_class) > 0 && failed_class != "") {
    msg_failed <- paste0("{.", failed_class, " ", msg_failed, "}")
  }

  cli_status(msg, msg_done, msg_failed, .auto_close = .auto_close,
             .envir = .envir, .auto_result = match.arg(on_exit))
}

#' @param id Id of the status bar container to clear. If `id` is not the id
#'   of the current status bar (because it was overwritten by another
#'   status bar container), then the status bar is not cleared. If `NULL`
#'   (the default) then the status bar is always cleared.
#'
#' @rdname cli_process_start
#' @export

cli_process_done <- function(id = NULL, msg_done = NULL,
                             .envir = parent.frame(),
                             done_class = "alert-success") {

  if (!is.null(msg_done) && length(done_class) > 0 && done_class != "") {
    msg_done <- paste0("{.", done_class, " ", msg_done, "}")
  }
  cli_status_clear(id, result = "done", msg_done = msg_done, .envir = .envir)
}

#' @rdname cli_process_start
#' @export

cli_process_failed <- function(id = NULL, msg = NULL, msg_failed = NULL,
                               .envir = parent.frame(),
                               failed_class = "alert-danger") {
  if (!is.null(msg_failed) && length(failed_class) > 0 &&
      failed_class != "") {
    msg_failed <- paste0("{.", failed_class, " ", msg_failed, "}")
  }
  cli_status_clear(
    id,
    result = "failed",
    msg_failed = msg_failed,
    .envir = .envir
  )
}

# -----------------------------------------------------------------------

clii_status <- function(app, id, msg, msg_done, msg_failed, keep,
                        auto_result, globalenv) {

  app$status_bar[[id]] <- list(
    content = "",
    msg_done = msg_done,
    msg_failed = msg_failed,
    keep = keep,
    auto_result = auto_result
  )
  if (isTRUE(getOption("cli.hide_cursor", TRUE)) && !isTRUE(globalenv)) {
    ansi_hide_cursor(app$output)
  }
  clii_status_update(app, id, msg, msg_done = NULL, msg_failed = NULL)
}

clii_status_clear <- function(app, id, result, msg_done, msg_failed) {
  ## If NA then the most recent one
  if (is.na(id)) id <- names(app$status_bar)[1]

  ## If no active status bar, then ignore
  if (is.null(id) || is.na(id)) return(invisible())
  if (! id %in% names(app$status_bar)) return(invisible())

  if (result == "auto") {
    r1 <- random_marker
    if (identical(returnValue(r1), r1)) {
      result <- "failed"
    } else {
      result <- "done"
    }
  }

  if (result == "done") {
    msg <- msg_done %||% app$status_bar[[id]]$msg_done
    clii_status_update(app, id, msg, NULL, NULL)
    app$status_bar[[id]]$keep <- TRUE
  } else if (result == "failed") {
    msg <- msg_failed %||% app$status_bar[[id]]$msg_failed
    clii_status_update(app, id, msg, NULL, NULL)
    app$status_bar[[id]]$keep <- TRUE
  }

  if (names(app$status_bar)[1] == id) {
    ## This is the active one
    if (app$status_bar[[id]]$keep) {
      ## Keep? Just emit it
      app$cat("\n")

    } else {
      ## Not keep? Remove it
      clii__clear_status_bar(app)
    }
    if (isTRUE(getOption("cli.hide_cursor", TRUE))) {
      ansi_show_cursor(app$output)
    }

  } else {
    if (app$status_bar[[id]]$keep) {
      ## Keep?
      clii__clear_status_bar(app)
      app$cat(paste0(app$status_bar[[id]]$content, "\n"))
      app$cat(paste0(app$status_bar[[1]]$content, "\r"))

    } else {
      ## Not keep? Nothing to output
    }
  }

  ## Remove
  app$status_bar[[id]] <- NULL

  ## Switch to the previous one
  if (length(app$status_bar)) {
    app$cat(paste0(app$status_bar[[1]]$content, "\r"))
  }
}

clii_status_update <- function(app, id, msg, msg_done, msg_failed) {
  ## If NA then the most recent one
  if (is.na(id)) id <- names(app$status_bar)[1]

  ## If no active status bar, then ignore
  if (is.na(id)) return(invisible())

  ## Update messages
  if (!is.null(msg_done)) app$status_bar[[id]]$msg_done <- msg_done
  if (!is.null(msg_failed)) app$status_bar[[id]]$msg_failed <- msg_failed

  ## Do we have a new message?
  if (is.null(msg)) return(invisible())

  ## Do we need to clear the current content?
  current <- paste0("", app$status_bar[[1]]$content)

  ## Format the line
  content <- ""
  fmsg <- app$inline(msg)
  cfmsg <- ansi_strtrim(fmsg, width = app$get_width())
  content <- strsplit(cfmsg, "\r?\n")[[1]][1]
  if (is.na(content)) content <- ""

  ## Update status bar, put it in front
  app$status_bar[[id]]$content <- content
  app$status_bar <- c(
    app$status_bar[id],
    app$status_bar[setdiff(names(app$status_bar), id)])

  ## New content, if it is an ANSI terminal we'll overwrite and clear
  ## until the end of the line. Otherwise we add some space characters
  ## to the content to make sure we clear up residual content.
  output <- get_real_output(app$output)
  if (is_ansi_tty(output)) {
    app$cat(paste0("\r", content, ANSI_EL, "\r"))
  } else if (is_dynamic_tty(output)) {
    nsp <- max(ansi_nchar(current) - ansi_nchar(content), 0)
    app$cat(paste0("\r", content, strrep(" ", nsp), "\r"))
  } else {
    app$cat(paste0(content, "\n"))
  }

  ## Reset timer
  .Call(clic_tick_reset)

  invisible()
}

clii__clear_status_bar <- function(app) {
  output <- get_real_output(app$output)
  if (is_ansi_tty(output)) {
    app$cat(paste0("\r", ANSI_EL))
  } else if (is_dynamic_tty(output)) {
    text <- app$status_bar[[1]]$content
    len <- ansi_nchar(text, type = "width")
    app$cat(paste0("\r", strrep(" ", len + rstudio_r_fix), "\r"))
  }
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/symbol.R"
#' Various handy symbols to use in a command line UI
#'
#' @usage
#' symbol
#'
#' @format A named list, see \code{names(symbol)} for all sign names.
#'
#' @details
#'
#' On Windows they have a fallback to less fancy symbols.
#'
#' `list_symbols()` prints a table with all symbols to the screen.
#'
#' @name symbol
#' @aliases symbol
#' @export symbol
#'
#' @examples
#' cat(symbol$tick, " SUCCESS\n", symbol$cross, " FAILURE\n", sep = "")
#'
#' ## All symbols
#' cat(paste(format(names(symbol), width = 20),
#'   unlist(symbol)), sep = "\n")
NULL

symbol_utf8 <- list(
  "tick" = '\u2714',
  "cross" = '\u2716',
  "star" = '\u2605',
  "square" = '\u2587',
  "square_small" = '\u25FB',
  "square_small_filled" = '\u25FC',
  "circle" = '\u25EF',
  "circle_filled" = '\u25C9',
  "circle_dotted" = '\u25CC',
  "circle_double" = '\u25CE',
  "circle_circle" = '\u24DE',
  "circle_cross" = '\u24E7',
  "circle_pipe" = '\u24be',
  "circle_question_mark" = '?\u20DD',
  "bullet" = '\u2022',
  "dot" = '\u2024',
  "line" = '\u2500',
  "double_line" = "\u2550",
  "ellipsis" = '\u2026',
  "continue" = '\u2026',
  "pointer" = '\u276F',
  "info" = '\u2139',
  "warning" = '\u26A0',
  "menu" = '\u2630',
  "smiley" = '\u263A',
  "mustache" = '\u0DF4',
  "heart" = '\u2665',
  "arrow_up" = '\u2191',
  "arrow_down" = '\u2193',
  "arrow_left" = '\u2190',
  "arrow_right" = '\u2192',
  "radio_on" = '\u25C9',
  "radio_off" = '\u25EF',
  "checkbox_on" = '\u2612',
  "checkbox_off" = '\u2610',
  "checkbox_circle_on" = '\u24E7',
  "checkbox_circle_off" = '\u24BE',
  "fancy_question_mark" = '\u2753',
  "neq" = "\u2260",
  "geq" = "\u2265",
  "leq" = "\u2264",
  "times" = "\u00d7",

  "upper_block_1" = "\u2594",
  "upper_block_4" = "\u2580",

  "lower_block_1" = "\u2581",
  "lower_block_2" = "\u2582",
  "lower_block_3" = "\u2583",
  "lower_block_4" = "\u2584",
  "lower_block_5" = "\u2585",
  "lower_block_6" = "\u2586",
  "lower_block_7" = "\u2587",
  "lower_block_8" = "\u2588",

  "full_block" = "\u2588",

  "sup_0" = "\u2070",
  "sup_1" = "\u00b9",
  "sup_2" = "\u00b2",
  "sup_3" = "\u00b3",
  "sup_4" = "\u2074",
  "sup_5" = "\u2075",
  "sup_6" = "\u2076",
  "sup_7" = "\u2077",
  "sup_8" = "\u2078",
  "sup_9" = "\u2079",

  "sup_minus" = "\u207b",
  "sup_plus" = "\u207a",

  "play" = "\u25b6",
  "stop" = "\u25a0",
  "record" = "\u25cf",

  "figure_dash" = "\u2012",
  "en_dash" = "\u2013",
  "em_dash" = "\u2014",

  "dquote_left" = "\u201c",
  "dquote_right" = "\u201d",
  "squote_left" = "\u2018",
  "squote_right" = "\u2019"
)

symbol_ascii <- list(
  "tick" = 'v',
  "cross" = 'x',
  "star" = '*',
  "square" = '[ ]',
  "square_small" = '[ ]',
  "square_small_filled" = '[x]',
  "circle" = '( )',
  "circle_filled" = '(*)',
  "circle_dotted" = '( )',
  "circle_double" = '(o)',
  "circle_circle" = '(o)',
  "circle_cross" = '(x)',
  "circle_pipe" = '(|)',
  "circle_question_mark" = '(?)',
  "bullet" = '*',
  "dot" = '.',
  "line" = '-',
  "double_line" = "=",
  "ellipsis" = '...',
  "continue" = '~',
  "pointer" = '>',
  "info" = 'i',
  "warning" = '!',
  "menu" = '=',
  "smiley" = ':)',
  "mustache" = '/\\/',
  "heart" = '<3',
  "arrow_up" = '^',
  "arrow_down" = 'v',
  "arrow_left" = '<',
  "arrow_right" = '>',
  "radio_on" = '(*)',
  "radio_off" = '( )',
  "checkbox_on" = '[x]',
  "checkbox_off" = '[ ]',
  "checkbox_circle_on" = '(x)',
  "checkbox_circle_off" = '( )',
  "fancy_question_mark" = "(?)",
  "neq" = "!=",
  "geq" = ">=",
  "leq" = "<=",
  "times" = "x",

  "upper_block_1" = "^",
  "upper_block_4" = "^",

  "lower_block_1" = ".",
  "lower_block_2" = "_",
  "lower_block_3" = "_",
  "lower_block_4" = "=",
  "lower_block_5" = "=",
  "lower_block_6" = "*",
  "lower_block_7" = "#",
  "lower_block_8" = "#",

  "full_block" = "#",

  "sup_0" = "0",
  "sup_1" = "1",
  "sup_2" = "2",
  "sup_3" = "3",
  "sup_4" = "4",
  "sup_5" = "5",
  "sup_6" = "6",
  "sup_7" = "7",
  "sup_8" = "8",
  "sup_9" = "9",

  "sup_minus" = "-",
  "sup_plus" = "+",

  "play" = ">",
  "stop" = "#",
  "record" = "o",

  "figure_dash" = "-",
  "en_dash" = "--",
  "em_dash" = "---",

  "dquote_left" = "\"",
  "dquote_right" = "\"",
  "squote_left" = "'",
  "squote_right" = "'"
)

#' @export
#' @rdname symbol

list_symbols <- function() {
  rpad <- function(x, width) {
    w <- nchar(x, type = "width")
    paste0(x, strrep(" ", width - w))
  }
  chars <- rpad(paste0(symbol, "\t", names(symbol)), 25)
  if (length(chars) %% 2) chars <- c(chars, "")
  chars <- paste(
  sep = "   ",
  chars[1:(length(chars)/2)],
  chars[(length(chars)/2 + 1):length(chars)])
  cat(chars, sep = "\n")
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/test.R"

#' Test cli output with testthat
#'
#' Use this function in your testthat test files, to test cli output.
#' It requires testthat edition 3, and works best with snapshot tests.
#'
#' `test_that_cli()` calls [testthat::test_that()] multiple times, with
#' different cli configurations. This makes it simple to test cli output
#' with and without ANSI colors, with and without Unicode characters.
#'
#' Currently available configurations:
#' * `plain`: no ANSI colors, ASCII characters only.
#' * `ansi`: ANSI colors, ASCII characters only.
#' * `unicode`: no ANSI colors, Unicode characters.
#' * `fancy`; ANSI colors, Unicode characters.
#'
#' See examples below and in cli's own tests, e.g. in
#' <https://github.com/r-lib/cli/tree/main/tests/testthat>
#' and the corresponding snapshots at
#' <https://github.com/r-lib/cli/tree/main/tests/testthat/_snaps>
#'
#' ## Important note regarding Windows
#'
#' Because of base R's limitation to record Unicode characters on Windows,
#' we suggest that you record your snapshots on Unix, or you restrict
#' your tests to ASCII configurations.
#'
#' Unicode tests on Windows are automatically skipped by testthat
#' currently.
#'
#' @param desc Test description, passed to [testthat::test_that()], after
#' appending the name of the cli configuration to it.
#' @param code Test code, it is modified to set up the cli config, and
#' then passed to [testthat::test_that()]
#' @param configs cli configurations to test `code` with. The default is
#' `NULL`, which includes all possible configurations. It can also be a
#' character vector, to restrict the tests to some configurations only.
#' See available configurations below.
#' @param links Whether to run the code with various hyperlinks allowed.
#' If `NULL` then hyperlinks are turned off. Otherwise it can be a character
#' vector with possible hyperlink configurations:
#'   * `"all"`: turn on all hyperlinks,
#'   * `"none"`: turn off all hyperlinks.
#'
#' @export
#' @examples
#' # testthat cannot record or compare snapshots when you run these
#' # examples interactively, so you might want to copy them into a test
#' # file
#'
#' # Default configurations
#' cli::test_that_cli("success", {
#'   testthat::local_edition(3)
#'   testthat::expect_snapshot({
#'     cli::cli_alert_success("wow")
#'   })
#' })
#'
#' # Only use two configurations, because this output does not have colors
#' cli::test_that_cli(configs = c("plain", "unicode"), "cat_bullet", {
#'   testthat::local_edition(3)
#'   testthat::expect_snapshot({
#'     cli::cat_bullet(letters[1:5])
#'   })
#' })
#'
#' # You often need to evaluate all cli calls of a test case in the same
#' # environment. Use `local()` to do that:
#' cli::test_that_cli("theming", {
#'   testthat::local_edition(3)
#'   testthat::expect_snapshot(local({
#'     cli::cli_div(theme = list(".alert" = list(before = "!!! ")))
#'     cli::cli_alert("wow")
#'   }))
#' })

test_that_cli <- function(desc, code,
                          configs = c("plain", "ansi", "unicode", "fancy"),
                          links = NULL) {
  code <- substitute(code)

  configs <- apply(expand.grid(configs, links %||% ""), 1, paste, collapse = "-")
  configs <- sub("-$", "", configs)

  doconfigs <- list(
    list(id = "plain",   unicode = FALSE, num_colors =   1, links = FALSE),
    list(id = "ansi",    unicode = FALSE, num_colors = 256, links = FALSE),
    list(id = "unicode", unicode = TRUE,  num_colors =   1, links = FALSE),
    list(id = "fancy",   unicode = TRUE,  num_colors = 256, links = FALSE),

    list(id = "plain-none",   unicode = FALSE, num_colors =   1, links = FALSE),
    list(id = "ansi-none",    unicode = FALSE, num_colors = 256, links = FALSE),
    list(id = "unicode-none", unicode = TRUE,  num_colors =   1, links = FALSE),
    list(id = "fancy-none",   unicode = TRUE,  num_colors = 256, links = FALSE),

    list(id = "plain-all",   unicode = FALSE, num_colors =   1, links = TRUE),
    list(id = "ansi-all",    unicode = FALSE, num_colors = 256, links = TRUE),
    list(id = "unicode-all", unicode = TRUE,  num_colors =   1, links = TRUE),
    list(id = "fancy-all",   unicode = TRUE,  num_colors = 256, links = TRUE)
  )

  parent <- parent.frame()
  lapply(doconfigs, function(conf) {
    if (!is.null(configs) && ! conf$id %in% configs) return()
    code2 <- substitute({
      testthat::local_reproducible_output(
        crayon = num_colors > 1,
        unicode = unicode
      )
      withr::local_options(
        cli.hyperlink = links,
        cli.hyperlink_help = links,
        cli.hyperlink_run = links,
        cli.hyperlink_vignette = links,
        cli.hyperlink_file_url_format = NULL,
        cli.hyperlink_run_url_format = NULL,
        cli.hyperlink_help_url_format = NULL,
        cli.hyperlink_vignette_url_format = NULL
      )
      withr::local_envvar(
        R_CLI_HYPERLINK_FILE_URL_FORMAT = NA_character_,
        R_CLI_HYPERLINK_RUN_URL_FORMAT = NA_character_,
        R_CLI_HYPERLINK_HELP_URL_FORMAT = NA_character_,
        R_CLI_HYPERLINK_VIGNETTE_URL_FORMAT = NA_character_
      )
      code_
    }, c(conf, list(code_ = code)))
    desc2 <- paste0(desc, " [", conf$id, "]")
    test <- substitute(
      testthat::test_that(desc, code),
      list(desc = desc2, code = code2)
    )
    eval(test, envir = parent)
  })
}

local_clean_cli_context <- function(.local_envir = parent.frame()) {
  withr::local_options(
    .local_envir = .local_envir,
    cli.hyperlink = NULL,
    cli.hyperlink_run = NULL,
    cli.hyperlink_help = NULL,
    cli.hyperlink_vignette = NULL,
    cli.hyperlink_file_url_format = NULL,
    cli.hyperlink_run_url_format = NULL,
    cli.hyperlink_help_url_format = NULL,
    cli.hyperlink_vignette_url_format = NULL,
    cli.num_colors = NULL,
    cli.palette = NULL,
    crayon.enabled = NULL
  )
  withr::local_envvar(
    .local_envir = .local_envir,
    R_CLI_HYPERLINKS = NA_character_,
    R_CLI_HYPERLINK_RUN = NA_character_,
    R_CLI_HYPERLINK_HELP = NA_character_,
    R_CLI_HYPERLINK_VIGNETTE = NA_character_,
    R_CLI_HYPERLINK_FILE_URL_FORMAT = NA_character_,
    R_CLI_HYPERLINK_RUN_URL_FORMAT = NA_character_,
    R_CLI_HYPERLINK_HELP_URL_FORMAT = NA_character_,
    R_CLI_HYPERLINK_VIGNETTE_URL_FORMAT = NA_character_,
    RSTUDIO_CLI_HYPERLINKS = NA_character_,
    R_CLI_NUM_COLORS = NA_character_,
    NO_COLOR = NA_character_,
    WT_SESSION = NA_character_,
    CI = NA_character_,
    TEAMCITY_VERSION = NA_character_,
    TERM_PROGRAM = NA_character_,
    TERM_PROGRAM_VERSION = NA_character_,
    VTE_VERSION = NA_character_
  )
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/themes.R"

#' List the currently active themes
#'
#' If there is no active app, then it calls [start_app()].
#'
#' @return A list of data frames with the active themes.
#' Each data frame row is a style that applies to selected CLI tree nodes.
#' Each data frame has columns:
#' * `selector`: The original CSS-like selector string. See [themes].
#' * `parsed`: The parsed selector, as used by cli for matching to nodes.
#' * `style`: The original style.
#' * `cnt`: The id of the container the style is currently applied to, or
#'   `NA` if the style is not used.
#'
#' @export
#' @seealso [themes]

cli_list_themes <- function() {
  app <- default_app() %||% start_app()
  app$list_themes()
}

clii_list_themes <- function(app) {
  app$themes
}

clii_add_theme <- function(app, theme) {
  id <- new_uuid()
  app$themes <-
    c(app$themes, structure(list(theme_create(theme)), names = id))
  id
}

clii_remove_theme <- function(app, id) {
  if (! id %in% names(app$themes)) return(invisible(FALSE))
  app$themes[[id]] <- NULL
  invisible(TRUE)
}

#' The built-in CLI theme
#'
#' This theme is always active, and it is at the bottom of the theme
#' stack. See [themes].
#'
#' # Showcase
#'
#' ```{asciicast builtin-theme}
#' cli_h1("Heading 1")
#' cli_h2("Heading 2")
#' cli_h3("Heading 3")
#'
#' cli_par()
#' cli_alert_danger("Danger alert")
#' cli_alert_warning("Warning alert")
#' cli_alert_info("Info alert")
#' cli_alert_success("Success alert")
#' cli_alert("Alert for starting a process or computation",
#'   class = "alert-start")
#' cli_end()
#'
#' cli_text("Packages and versions: {.pkg cli} {.version 1.0.0}.")
#' cli_text("Time intervals: {.timestamp 3.4s}")
#'
#' cli_text("{.emph Emphasis} and  {.strong strong emphasis}")
#'
#' cli_text("This is a piece of code: {.code sum(x) / length(x)}")
#' cli_text("Function names: {.fn cli::simple_theme}")
#'
#' cli_text("Files: {.file /usr/bin/env}")
#' cli_text("URLs: {.url https://r-project.org}")
#'
#' cli_h2("Longer code chunk")
#' cli_par(class = "code R")
#' cli_verbatim(
#'   '# window functions are useful for grouped mutates',
#'   'mtcars %>%',
#'   '  group_by(cyl) %>%',
#'   '  mutate(rank = min_rank(desc(mpg)))')
#' ```
#'
#' @seealso [themes], [simple_theme()].
#' @return A named list, a CLI theme.
#'
#' @param dark Whether to use a dark theme. The `cli.theme_dark` option
#'   can be used to request a dark theme explicitly. If this is not set,
#'   or set to `"auto"`, then cli tries to detect a dark theme, this
#'   works in recent RStudio versions and in iTerm on macOS.
#' @export

builtin_theme <- function(dark = getOption("cli.theme_dark", "auto")) {

  dark <- detect_dark_theme(dark)

  list(
    body = list(
      "class-map" = list(
        fs_path = "file",
        "cli-progress-bar" = "progress-bar"
      )
    ),

    h1 = list(
      "font-weight" = "bold",
      "margin-top" = 1,
      "margin-bottom" = 0,
      fmt = function(x) cli::rule(x, line_col = "cyan")),
    h2 = list(
      "font-weight" = "bold",
      "margin-top" = 1,
      "margin-bottom" = 1,
      fmt = function(x) paste0(symbol$line, symbol$line, " ", x, " ",
                               symbol$line, symbol$line)),
    h3 = list(
      "margin-top" = 1,
      fmt = function(x) paste0(symbol$line, symbol$line, " ", x, " ")),

    ".alert" = list(
      before = function() paste0(symbol$arrow_right, " ")
    ),
    ".alert-success" = list(
      before = function() paste0(col_green(symbol$tick), " ")
    ),
    ".alert-danger" = list(
      before = function() paste0(col_red(symbol$cross), " ")
    ),
    ".alert-warning" = list(
      before = function() paste0(col_yellow("!"), " ")
    ),
    ".alert-info" = list(
      before = function() paste0(col_cyan(symbol$info), " ")
    ),

    ".bullets .bullet-empty" = list(),
    ".bullets .bullet-space" = list("margin-left" = 2),
    ".bullets .bullet-v" = list(
      "text-exdent" = 2,
      before = function(x) paste0(col_green(symbol$tick), " ")
    ),
    ".bullets .bullet-x" = list(
      "text-exdent" = 2,
      before = function(x) paste0(col_red(symbol$cross), " ")
    ),
    ".bullets .bullet-!" = list(
      "text-exdent" = 2,
      before = function(x) paste0(col_yellow("!"), " ")
    ),
    ".bullets .bullet-i" = list(
      "text-exdent" = 2,
      before = function(x) paste0(col_cyan(symbol$info), " ")
    ),
    ".bullets .bullet-*" = list(
      "text-exdent" = 2,
      before = function(x) paste0(col_cyan(symbol$bullet), " ")
    ),
    ".bullets .bullet->" = list(
      "text-exdent" = 2,
      before = function(x) paste0(symbol$arrow_right, " ")
    ),
    ".bullets .bullet-1" = list(
    ),

    par = list("margin-top" = 0, "margin-bottom" = 1),
    ul = list(
      "list-style-type" = function() symbol$bullet
    ),

    # these are tags in HTML, but in cli they are inline
    span.dt = list(postfix = ": "),
    span.dd = list(),

    # This means that list elements have a margin, if they are nested
    "ul ul li" = list("margin-left" = 2),
    "ul ol li" = list("margin-left" = 2),
    "ul dl li" = list("margin-left" = 2),
    "ol ul li" = list("margin-left" = 2),
    "ol ol li" = list("margin-left" = 2),
    "ol dl li" = list("margin-left" = 2),
    "ol ul li" = list("margin-left" = 2),
    "ol ol li" = list("margin-left" = 2),
    "ol dl li" = list("margin-left" = 2),

    blockquote = list("padding-left" = 4L, "padding-right" = 10L,
                      "font-style" = "italic", "margin-top" = 1L,
                      "margin-bottom" = 1L,
                      before = function() symbol$dquote_left,
                      after = function() symbol$dquote_right),
    "blockquote cite" = list(
      before = function() paste0(symbol$em_dash, " "),
      "font-style" = "italic",
      "font-weight" = "bold"
    ),

    .code = list(fmt = format_code(dark)),
    .code.R = list(fmt = format_r_code(dark)),

    span.emph = list("font-style" = "italic"),
    span.strong = list("font-weight" = "bold"),
    span.code = theme_code_tick(dark),

    span.q   = list(fmt = quote_weird_name2),
    span.pkg = list(color = "blue"),
    span.fn = theme_function(dark),
    span.fun = theme_function(dark),
    span.arg = theme_code_tick(dark),
    span.kbd = list(before = "[", after = "]", color = "blue"),
    span.key = list(before = "[", after = "]", color = "blue"),
    span.file = theme_file(),
    span.path = theme_file(),
    span.email = list(
      color = "blue",
      transform = function(x) make_link(x, type = "email"),
      fmt = quote_weird_name
    ),
    span.url = list(
      before = "<", after = ">",
      color = "blue", "font-style" = "italic",
      transform = function(x) make_link(x, type = "url")
    ),
    span.href = list(
      transform = function(x) make_link(x, type = "href")
    ),
    span.help = list(
      transform = function(x) make_link(x, type = "help")
    ),
    span.topic = list(
      transform = function(x) make_link(x, type = "topic")
    ),
    span.vignette = list(
      transform = function(x) make_link(x, type = "vignette")
    ),
    span.run = list(
      transform = function(x) make_link(x, type = "run")
    ),
    span.var = theme_code_tick(dark),
    span.col = theme_code_tick(dark),
    span.str = list(fmt = encode_string),
    span.envvar = theme_code_tick(dark),
    span.val = list(
      transform = function(x, ...) cli_format(x, ...),
      color = "blue"
    ),
    span.field = list(color = "green"),
    span.cls = list(collapse = "/", color = "blue", before = "<", after = ">"),
    "span.progress-bar" = list(
      transform = theme_progress_bar,
      color = "green"
    ),
    span.obj_type_friendly = list(
      transform = function(x) format_inline(typename(x))
    ),
    span.type = list(
      transform = function(x) format_inline(typename(x))
    ),
    span.or = list("vec-sep2" = " or ", "vec-last" = ", or "),
    span.timestamp = list(before = "[", after = "]", color = "grey")
  )
}

encode_string <- function(x) {
  encodeString(x, quote = "\"")
}

quote_weird_name0 <- function(x) {
  x <- gsub(" ", "\u00a0", x, fixed = TRUE)
  x2 <- ansi_strip(x)

  fc <- first_character(x2)
  sc <- second_character(x2)
  lc <- last_character(x2)

  wfst <- !is_alnum(fc, ok = "~") || (fc == "~" && !is_alnum(sc))
  wlst <- !is_alnum(lc)

  if (wfst || wlst) {
    lsp <- leading_space(x2)
    tsp <- trailing_space(x2)
    if (nzchar(lsp)) {
      x <- paste0(
        bg_blue(lsp),
        ansi_substr(x, nchar(lsp) + 1, ansi_nchar(x))
      )
    }
    if (nzchar(tsp)) {
      x <- paste0(
        ansi_substr(x, 1, ansi_nchar(x) - nchar(tsp)),
        bg_blue(tsp)
      )
    }
  }

  list(x, wfst || wlst)
}

quote_weird_name <- function(x) {
  x2 <- quote_weird_name0(x)
  if (x2[[2]] || num_ansi_colors() == 1) {
    x2[[1]] <- paste0("'", x2[[1]], "'")
  }
  x2[[1]]
}

quote_weird_name2 <- function(x) {
  x2 <- quote_weird_name0(x)
  paste0("\"", x2[[1]], "\"")
}

theme_progress_bar <- function(x, app, style) {
  make_progress_bar(x$current / x$total, style = style)
}

detect_dark_theme <- function(dark) {
  tryCatch({
    if (dark == "auto") {
      dark <- if (Sys.getenv("RSTUDIO", "0") == "1") {
        get_rstudio_theme()$dark
      } else if (is_iterm()) {
        is_iterm_dark()
      } else if (is_emacs()) {
        Sys.getenv("ESS_BACKGROUND_MODE", "light") == "dark"
      } else {
        FALSE
      }
    }
  }, error = function(e) FALSE)

  isTRUE(dark)
}

theme_code <- function(dark) {
  list()
}

tick_formatter <- function(x) {
  tt <- grepl("`", x, fixed = TRUE) + 1L
  t1 <- c("`", "`` ")[tt]
  t2 <- c("`", " ``")[tt]
  paste0(t1, x, t2)
}

tick_formatter_fun <- function(x) {
  tt <- grepl("`", x, fixed = TRUE) + 1L
  t1 <- c("`", "`` ")[tt]
  t2 <- c("()`", " ()``")[tt]
  paste0(t1, x, t2)
}

theme_code_tick <- function(dark) {
  utils::modifyList(
    theme_code(dark),
    list(transform = tick_formatter)
  )
}

theme_function <- function(dark) {
  utils::modifyList(
    theme_code(dark),
    list(transform = function(x) tick_formatter_fun(make_link(x, type = "fun")))
  )
}

theme_file <- function() {
  list(
    color = "blue",
    transform = function(x) make_link(x, type = "file"),
    fmt = quote_weird_name
  )
}

format_r_code <- function(dark) {
  function(x) {
    x <- ansi_strip(x)
    lines <- unlist(strsplit(x, "\n", fixed = TRUE))
    code_highlight(lines)
  }
}

format_code <- function(dark) {
  function(x) {
    unlist(strsplit(x, "\n", fixed = TRUE))
  }
}

theme_create <- function(theme) {
  mtheme <- theme
  mtheme[] <- lapply(mtheme, create_formatter)
  selectors <- names(theme)
  res <- data.frame(
    stringsAsFactors = FALSE,
    selector = as.character(selectors),
    parsed = I(lapply(selectors, parse_selector) %||% list()),
    style = I(mtheme %||% list()),
    cnt = rep(NA_character_, length(selectors))
  )

  rownames(res) <- NULL
  res
}

create_formatter <- function(x) {
  is_bold <- identical(x[["font-weight"]], "bold")
  is_italic <- identical(x[["font-style"]], "italic")
  is_underline <- identical(x[["text-decoration"]], "underline")
  is_color <- "color" %in% names(x)
  is_bg_color <- "background-color" %in% names(x)

  if (!is_bold && !is_italic && !is_underline && !is_color
      && !is_bg_color) return(x)

  if (is_color && is.null(x[["color"]])) {
    x[["color"]] <- "none"
  }
  if (is_bg_color && is.null(x[["background-color"]])) {
    x[["background-color"]] <- "none"
  }

  fmt <- c(
    if (is_bold) list(style_bold),
    if (is_italic) list(style_italic),
    if (is_underline) list(style_underline),
    if (is_color) make_ansi_style(x[["color"]]),
    if (is_bg_color) make_ansi_style(x[["background-color"]], bg = TRUE)
  )

  new_fmt <- do.call(combine_ansi_styles, fmt)

  if (is.null(x[["fmt"]])) {
    x[["fmt"]] <- new_fmt
  } else {
    orig_fmt <- x[["fmt"]]
    x[["fmt"]] <- function(x) orig_fmt(new_fmt(x))
  }

  x
}

merge_embedded_styles <- function(old, new) {
  # before and after is not inherited, fmt is not inherited, either
  # side margins are additive, class mappings are merged
  # rest is updated, counter is reset, prefix and postfix are merged
  old$before <- old$after <- old$fmt <- NULL
  old$transform <- NULL

  # these will be applied on the container, so we don't need them inside
  old$color <- old$`background-color` <- NULL

  top <- new$`margin-top` %||% 0L
  bottom <- new$`margin-bottom` %||% 0L
  left <- (old$`margin-left` %||% 0L) + (new$`margin-left` %||% 0L)
  right <- (old$`margin-right` %||% 0L) + (new$`margin-right` %||% 0L)

  prefix <- paste0(old$prefix, new$prefix)
  postfix <- paste0(new$postfix, old$postfix)

  map <- utils::modifyList(old$`class-map` %||% list(), new$`class-map` %||% list())

  start <- new$start %||% 1L

  mrg <- utils::modifyList(old, new)
  mrg[c("margin-top", "margin-bottom", "margin-left", "margin-right",
        "start", "class-map", "prefix", "postfix")] <-
    list(top, bottom, left, right, start, map, prefix, postfix)

  ## Formatter needs to be re-generated
  create_formatter(mrg)
}

#' Parse a CSS3-like selector
#'
#' This is the rather small subset of CSS3 that is supported:
#'
#' Selectors:
#'
#' * Type selectors, e.g. `input` selects all `<input>` elements.
#' * Class selectors, e.g. `.index` selects any element that has a class
#'   of "index".
#' * ID selector. `#toc` will match the element that has the ID `"toc"`.
#'
#' Combinators:
#'
#' * Descendant combinator, i.e. the space, that combinator selects nodes
#'   that are descendants of the first element. E.g. `div span` will match
#'   all `<span>` elements that are inside a `<div>` element.
#'
#' @param x CSS3-like selector string.
#'
#' @keywords internal

parse_selector <- function(x) {
  lapply(strsplit(x, " ", fixed = TRUE)[[1]], parse_selector_node)
}

parse_selector_node <- function(x) {

  parse_ids <- function(y) {
    r <- strsplit(y, "#", fixed = TRUE)[[1]]
    if (length(r) > 1) r[-1] <- paste0("#", r[-1])
    r
  }

  parts <- strsplit(x, ".", fixed = TRUE)[[1]]
  if (length(parts) > 1) parts[-1] <- paste0(".", parts[-1])
  parts <- unlist(lapply(parts, parse_ids))
  parts <- parts[parts != ""]

  m_cls <- grepl("^\\.", parts)
  m_ids <- grepl("^#", parts)

  list(tag = as.character(unique(parts[!m_cls & !m_ids])),
       class = str_tail(unique(parts[m_cls])),
       id = str_tail(unique(parts[m_ids])))
}

#' Match a selector node to a container
#'
#' @param node Selector node, as parsed by `parse_selector_node()`.
#' @param cnt Container node, has elements `tag`, `id`, `class`.
#'
#' The selector node matches the container, if all these hold:
#'
#' * The id of the selector is missing or unique.
#' * The tag of the selector is missing or unique.
#' * The id of the container is missing or unique.
#' * The tag of the container is unique.
#' * If the selector specifies an id, it matches the id of the container.
#' * If the selector specifies a tag, it matches the tag of the container.
#' * If the selector specifies class names, the container has all these
#'   classes.
#'
#' @keywords internal

match_selector_node <- function(node, cnt) {
  if (length(node$id) > 1 || length(cnt$id) > 1) return(FALSE)
  if (length(node$tag) > 1 || length(cnt$tag) > 1) return(FALSE)
  all(node$id %in% cnt$id) &&
    all(node$tag %in% cnt$tag) &&
    all(node$class %in% cnt$class)
}

#' Match a selector to a container stack
#'
#' @param sels A list of selector nodes.
#' @param cnts A list of container nodes.
#'
#' The last selector in the list must match the last container, so we
#' do the matching from the back. This is because we use this function
#' to calculate the style of newly encountered containers.
#'
#' @keywords internal

match_selector <- function(sels, cnts) {
  sptr <- length(sels)
  cptr <- length(cnts)

  # Last selector must match the last container
  if (sptr == 0 || sptr > cptr) return(FALSE)
  match <- match_selector_node(sels[[sptr]], cnts[[cptr]])
  if (!match) return (FALSE)

  # Plus the rest should match somehow
  sptr <- sptr - 1L
  cptr <- cptr - 1L
  while (sptr != 0L && sptr <= cptr) {
    match <- match_selector_node(sels[[sptr]], cnts[[cptr]])
    if (match) {
      sptr <- sptr - 1L
      cptr <- cptr - 1L
    } else {
      cptr <- cptr - 1L
    }
  }

  sptr == 0
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/time-ago.R"

format_time_ago <- local({

  e <- expression

  `%s%` <- function(lhs, rhs) {
    assert_string(lhs)
    do.call(
      sprintf,
      c(list(lhs), as.list(rhs))
    )
  }

  assert_string <- function(x) {
    stopifnot(is.character(x), length(x) == 1L)
  }

  assert_diff_time <- function(x) {
    stopifnot(inherits(x, "difftime"))
  }

  vague_dt_default <- list(
    list(c = e(seconds < 10), s = "moments ago"),
    list(c = e(seconds < 45), s = "less than a minute ago"),
    list(c = e(seconds < 90), s = "about a minute ago"),
    list(c = e(minutes < 45), s = e("%d minutes ago" %s% round(minutes))),
    list(c = e(minutes < 90), s = "about an hour ago"),
    list(c = e(hours < 24),   s = e("%d hours ago" %s% round(hours))),
    list(c = e(hours < 42),   s = "a day ago"),
    list(c = e(days < 30),    s = e("%d days ago" %s% round(days))),
    list(c = e(days < 45),    s = "about a month ago"),
    list(c = e(days < 335),   s = e("%d months ago" %s% round(days / 30))),
    list(c = e(years < 1.5),  s = "about a year ago"),
    list(c = TRUE,            s = e("%d years ago" %s% round(years)))
  )

  vague_dt_short <- list(
    list(c = e(seconds < 50), s = "<1 min"),
    list(c = e(minutes < 50), s = e("%d min" %s% round(minutes))),
    list(c = e(hours < 1.5),  s = "1 hour"),
    list(c = e(hours < 18),   s = e("%d hours" %s% round(hours))),
    list(c = e(hours < 42),   s = "1 day"),
    list(c = e(days < 30),    s = e("%d day" %s% round(days))),
    list(c = e(days < 45),    s = "1 mon"),
    list(c = e(days < 335),   s = e("%d mon" %s% round(days / 30))),
    list(c = e(years < 1.5),  s = "1 year"),
    list(c = TRUE,            s = e("%d years" %s% round(years)))
  )

  vague_dt_terse <- list(
    list(c = e(seconds < 50), s = e("%2ds" %s% round(seconds))),
    list(c = e(minutes < 50), s = e("%2dm" %s% round(minutes))),
    list(c = e(hours < 18),   s = e("%2dh" %s% round(hours))),
    list(c = e(days < 30),    s = e("%2dd" %s% round(days))),
    list(c = e(days < 335),   s = e("%2dM" %s% round(days / 30))),
    list(c = TRUE,            s = e("%2dy" %s% round(years)))
  )

  vague_dt_formats <- list(
    "default" = vague_dt_default,
    "short" = vague_dt_short,
    "terse" = vague_dt_terse
  )

  time_ago <- function(date, format = c("default", "short", "terse")) {

    date <- as.POSIXct(date)

    if (length(date) > 1) return(sapply(date, time_ago, format = format))

    seconds <- difftime(Sys.time(), date, units = "secs")

    vague_dt(seconds, format = format)
  }

  vague_dt <- function(dt, format = c("default", "short", "terse")) {

    assert_diff_time(dt)

    units(dt) <- "secs"
    seconds <- as.vector(dt)

    ## Simplest to quit here for empty input
    if (!length(seconds)) return(character())

    pieces <- list(
      minutes = seconds / 60,
      hours = seconds / 60 / 60,
      days = seconds / 60 / 60 / 24,
      years = seconds / 60 / 60 / 24 / 365.25
    )

    format <- match.arg(format)

    for (p in vague_dt_formats[[format]]) {
      if (eval(p$c, pieces)) return(eval(p$s, pieces))
    }
  }

  structure(
    list(
      .internal = environment(),
      time_ago = time_ago,
      vague_dt = vague_dt
    ),
    class = c("standalone_time_ago", "standalone")
  )
})
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/time.R"

format_time <- local({

  parse_ms <- function(ms) {
    stopifnot(is.numeric(ms))

    data.frame(
      days = floor(ms / 86400000),
      hours = floor((ms / 3600000) %% 24),
      minutes = floor((ms / 60000) %% 60),
      seconds = round((ms / 1000) %% 60, 1)
    )
  }

  first_positive <- function(x) which(x > 0)[1]

  trim <- function (x) gsub("^\\s+|\\s+$", "", x)

  pretty_ms <- function(ms, compact = FALSE) {

    stopifnot(is.numeric(ms))

    parsed <- t(parse_ms(ms))

    if (compact) {
      units <- c("d", "h", "m", "s")
      parsed2 <- parsed
      parsed2[] <- paste0(parsed, units)
      idx <- cbind(
        apply(parsed, 2, first_positive),
        seq_len(length(ms))
      )
      tmp <- paste0("~", parsed2[idx])

      # handle NAs
      tmp[is.na(parsed2[idx])] <- NA_character_
      tmp

    } else {

      ## Exact for small ones
      exact            <- paste0(ceiling(ms), "ms")
      exact[is.na(ms)] <- NA_character_

      ## Approximate for others, in seconds
      merge_pieces <- function(pieces) {
        ## handle NAs
        if (all(is.na(pieces))) {
          return(NA_character_)
        }

        ## handle non-NAs
        paste0(
          if (pieces[1]) paste0(pieces[1], "d "),
          if (pieces[2]) paste0(pieces[2], "h "),
          if (pieces[3]) paste0(pieces[3], "m "),
          if (pieces[4]) paste0(pieces[4], "s ")
        )
      }
      approx <- trim(apply(parsed, 2, merge_pieces))

      ifelse(ms < 1000, exact, approx)
    }
  }

  pretty_sec <- function(sec, compact = FALSE) {
    pretty_ms(sec * 1000, compact = compact)
  }

  pretty_dt <- function(dt, compact = FALSE) {

    assert_diff_time(dt)

    units(dt) <- "secs"

    pretty_sec(as.vector(dt), compact = compact)
  }

  structure(
    list(
      .internal = environment(),
      pretty_ms = pretty_ms,
      pretty_sec = pretty_sec,
      pretty_dt = pretty_dt
    ),
    class = c("standalone_time", "standalone")
  )
})
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/timer.R"

#' @export
`__cli_update_due` <- FALSE

#' @export

cli_tick_reset <- function() {
  .Call(clic_tick_reset)
}

#' @export

ccli_tick_reset <- NULL

cli_tick_set <- function(tick_time = NULL, speed_time = NULL) {
  tick_time <- tick_time %||% clienv$tick_time
  speed_time <- speed_time %||% clienv$speed_time

  clienv$speed_time <- as.double(speed_time)
  clienv$tick_time <- as.integer(tick_time)
  .Call(clic_tick_set, clienv$tick_time, clienv$speed_time)
  invisible()
}

cli_tick_pause <- function(state = TRUE) {
  .Call(clic_tick_pause, state)
}

cli_tick_resume <- function(state = TRUE) {
  .Call(clic_tick_resume, state)
}

cli_with_ticks <- function(expr) {
  on.exit(cli_tick_resume(TRUE), add = TRUE)
  opts <- options(cli.progress_show_after = 0)
  on.exit(options(opts), add = TRUE)
  cli_tick_pause(TRUE)
  expr
}

cli_without_ticks <- function(expr) {
  on.exit(cli_tick_resume(TRUE), add = TRUE)
  opts <- options(cli.progress_show_after = 0)
  on.exit(options(opts), add = TRUE)
  cli_tick_pause(FALSE)
  expr
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/tree.R"

#' Draw a tree
#'
#' Draw a tree using box drawing characters. Unicode characters are
#' used if available. (Set the `cli.unicode` option if auto-detection
#' fails.)
#'
#' A node might appear multiple times in the tree, or might not appear
#' at all.
#'
#' @details
#'
#' ```{asciicast, tree}
#' data <- data.frame(
#'   stringsAsFactors = FALSE,
#'   package = c("processx", "backports", "assertthat", "Matrix",
#'     "magrittr", "rprojroot", "clisymbols", "prettyunits", "withr",
#'     "desc", "igraph", "R6", "crayon", "debugme", "digest", "irlba",
#'     "rcmdcheck", "callr", "pkgconfig", "lattice"),
#'   dependencies = I(list(
#'     c("assertthat", "crayon", "debugme", "R6"), character(0),
#'     character(0), "lattice", character(0), "backports", character(0),
#'     c("magrittr", "assertthat"), character(0),
#'     c("assertthat", "R6", "crayon", "rprojroot"),
#'     c("irlba", "magrittr", "Matrix", "pkgconfig"), character(0),
#'     character(0), "crayon", character(0), "Matrix",
#'     c("callr", "clisymbols", "crayon", "desc", "digest", "prettyunits",
#'       "R6", "rprojroot", "withr"),
#'     c("processx", "R6"), character(0), character(0)
#'   ))
#' )
#' tree(data)
#' ```
#'
#' ```{asciicast, tree-root}
#' tree(data, root = "rcmdcheck")
#' ```
#'
#' ## Colored nodes
#'
#' ```{asciicast tree-colored}
#' data$label <- paste(data$package,
#'   style_dim(paste0("(", c("2.0.0.1", "1.1.1", "0.2.0", "1.2-11",
#'     "1.5", "1.2", "1.2.0", "1.0.2", "2.0.0", "1.1.1.9000", "1.1.2",
#'     "2.2.2", "1.3.4", "1.0.2", "0.6.12", "2.2.1", "1.2.1.9002",
#'     "1.0.0.9000", "2.0.1", "0.20-35"), ")"))
#'   )
#' roots <- ! data$package %in% unlist(data$dependencies)
#' data$label[roots] <- col_cyan(style_italic(data$label[roots]))
#' tree(data, root = "rcmdcheck")
#' ```
#'
#' ## Trimming
#'
#' ```{asciicast tree-trimming}
#' pkgdeps <- list(
#'   "dplyr@0.8.3" = c("assertthat@0.2.1", "glue@1.3.1", "magrittr@1.5",
#'     "R6@2.4.0", "Rcpp@1.0.2", "rlang@0.4.0", "tibble@2.1.3",
#'     "tidyselect@0.2.5"),
#'   "assertthat@0.2.1" = character(),
#'   "glue@1.3.1" = character(),
#'   "magrittr@1.5" = character(),
#'   "pkgconfig@2.0.3" = character(),
#'   "R6@2.4.0" = character(),
#'   "Rcpp@1.0.2" = character(),
#'   "rlang@0.4.0" = character(),
#'   "tibble@2.1.3" = c("cli@1.1.0", "crayon@1.3.4", "fansi@0.4.0",
#'      "pillar@1.4.2", "pkgconfig@2.0.3", "rlang@0.4.0"),
#'   "cli@1.1.0" = c("assertthat@0.2.1", "crayon@1.3.4"),
#'   "crayon@1.3.4" = character(),
#'   "fansi@0.4.0" = character(),
#'   "pillar@1.4.2" = c("cli@1.1.0", "crayon@1.3.4", "fansi@0.4.0",
#'      "rlang@0.4.0", "utf8@1.1.4", "vctrs@0.2.0"),
#'   "utf8@1.1.4" = character(),
#'   "vctrs@0.2.0" = c("backports@1.1.5", "ellipsis@0.3.0",
#'      "digest@0.6.21", "glue@1.3.1", "rlang@0.4.0", "zeallot@0.1.0"),
#'   "backports@1.1.5" = character(),
#'   "ellipsis@0.3.0" = c("rlang@0.4.0"),
#'   "digest@0.6.21" = character(),
#'   "glue@1.3.1" = character(),
#'   "zeallot@0.1.0" = character(),
#'   "tidyselect@0.2.5" = c("glue@1.3.1", "purrr@1.3.1", "rlang@0.4.0",
#'      "Rcpp@1.0.2"),
#'   "purrr@0.3.3" = c("magrittr@1.5", "rlang@0.4.0")
#' )
#'
#' pkgs <- data.frame(
#'   stringsAsFactors = FALSE,
#'   name = names(pkgdeps),
#'   deps = I(unname(pkgdeps))
#' )
#'
#' tree(pkgs, trim = TRUE)
#' ```
#'
#' ```{asciicast tree-trim-mark}
#' # Mark the trimmed nodes
#' pkgs$label <- pkgs$name
#' pkgs$trimmed <- paste(pkgs$name, " (trimmed)")
#' tree(pkgs, trim = TRUE)
#' ```
#'
#' @param data Data frame that contains the tree structure.
#'   The first column is an id, and the second column is a list column,
#'   that contains the ids of the child nodes. The optional third column
#'   may contain the text to print to annotate the node.
#' @param root The name of the root node.
#' @param style Optional box style list.
#' @param width Maximum width of the output. Defaults to the `width`
#'   option, see [base::options()].
#' @param trim Whether to avoid traversing the same nodes multiple times.
#'   If `TRUE` and `data` has a `trimmed` column, then that is used for
#'   printing repeated nodes.
#' @return Character vector, the lines of the tree drawing.
#'
#' @export


tree <- function(data, root = data[[1]][[1]], style = NULL,
                 width = console_width(), trim = FALSE) {
  stopifnot(
    is.data.frame(data), ncol(data) >= 2,
    is_string(root),
    is.null(style) || (is_tree_style(style)),
    is_count(width)
  )

  style <- style %||% box_chars()

  labels <- if (ncol(data) >= 3) data[[3]] else data[[1]]
  trimlabs <- data[["trimmed"]] %||% labels

  seen <- character()
  res <- character()

  pt <- function(root, n = integer(), mx = integer(), used = character()) {

    num_root <- match(root, data[[1]])
    if (is.na(num_root)) return()

    level <- length(n) - 1
    prefix <- vcapply(seq_along(n), function(i) {
      if (n[i] < mx[i]) {
        if (i == length(n)) {
          paste0(style$j, style$h)
        } else {
          paste0(style$v, " ")
        }
      } else if (n[i] == mx[i] && i == length(n)) {
        paste0(style$l, style$h)
      } else {
        "  "
      }
    })

    root_seen <- root %in% seen
    root_lab <- if (trim && root_seen) trimlabs[[num_root]] else labels[[num_root]]
    res <<- c(res, paste0(paste(prefix, collapse = ""), root_lab))

    # Detect infinite loops
    if (!trim && root %in% used) {
      warning(call. = FALSE,
              "Endless loop found in tree: ",
              paste0(c(used, root), collapse = " -> "))
    } else if (! trim || ! root_seen) {
      seen <<- c(seen, root)
      children <- data[[2]][[num_root]]
      for (d in seq_along(children)) {
        pt(children[[d]], c(n, d), c(mx, length(children)), c(used, root))
      }
    }
  }

  if (nrow(data)) pt(root)

  res <- ansi_substr(res, 1, width)

  class(res) <- unique(c("cli_tree", "tree", class(res), "character"))
  res
}

box_chars <- function() {
  if (is_utf8_output()) {
    list(
      "h" = "\u2500",                   # horizontal
      "v" = "\u2502",                   # vertical
      "l" = "\u2514",                   # leaf
      "j" = "\u251C"                    # junction
    )
  } else {
    list(
      "h" = "-",                        # horizontal
      "v" = "|",                        # vertical
      "l" = "\\",                       # leaf
      "j" = "+"                         # junction
    )
  }
}

methods::setOldClass(c("cli_tree", "character"))

#' @export

print.cli_tree <- function(x, ..., sep = "\n") {
  cat(x, ..., sep = sep)
  invisible(x)
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/tty.R"

is_interactive <- function() {
  opt <- getOption("rlib_interactive")
  if (isTRUE(opt)) {
    TRUE
  } else if (identical(opt, FALSE)) {
    FALSE
  } else if (tolower(getOption("knitr.in.progress", "false")) == "true") {
    FALSE
  } else if (tolower(getOption("rstudio.notebook.executing", "false")) == "true") {
    FALSE
  } else if (identical(Sys.getenv("TESTTHAT"), "true")) {
    FALSE
  } else {
    interactive()
  }
}

#' The connection option that cli would use
#'
#' Note that this only refers to the current R process. If the output
#' is produced in another process, then it is not relevant.
#'
#' In interactive sessions the standard output is chosen, otherwise the
#' standard error is used. This is to avoid painting output messages red
#' in the R GUIs.
#'
#' @return Connection object.
#'
#' @export

cli_output_connection <- function() {
  if ((is_interactive() || rstudio_stdout()) && no_sink()) stdout() else stderr()
}

no_sink <- function() {
  sink.number() == 0 && sink.number("message") == 2
}

rstudio_stdout <- function() {
  rstudio <- rstudio_detect()
  rstudio$type %in% c(
    "rstudio_console",
    "rstudio_console_starting",
    "rstudio_build_pane",
    "rstudio_job",
    "rstudio_render_pane"
  )
}

is_stdout <- function(stream) {
  identical(stream, stdout()) && sink.number() == 0
}

is_stderr <- function(stream) {
  identical(stream, stderr()) && sink.number("message") == 2
}

is_stdx <- function(stream){
  is_stdout(stream) || is_stderr(stream)
}

is_rstudio_dynamic_tty <- function(stream) {
  rstudio$detect()[["dynamic_tty"]] &&
    (is_stdout(stream) || is_stderr(stream))
}

is_rapp <- function() {
  Sys.getenv("R_GUI_APP_VERSION") != ""
}

is_rapp_stdx <- function(stream) {
  interactive() &&
    is_rapp() &&
    (is_stdout(stream) || is_stderr(stream))
}

is_emacs <- function() {
  Sys.getenv("EMACS") != "" || Sys.getenv("INSIDE_EMACS") != ""
}

is_rkward <- function() {
  "rkward" %in% (.packages())
}

is_rkward_stdx <- function(stream) {
  interactive() &&
    is_rkward() &&
    (is_stdout(stream) || is_stderr(stream))
}

#' Detect whether a stream supports `\\r` (Carriage return)
#'
#' In a terminal, `\\r` moves the cursor to the first position of the
#' same line. It is also supported by most R IDEs. `\\r` is typically
#' used to achieve a more dynamic, less cluttered user interface, e.g.
#' to create progress bars.
#'
#' If the output is directed to a file, then `\\r` characters are typically
#' unwanted. This function detects if `\\r` can be used for the given
#' stream or not.
#'
#' The detection mechanism is as follows:
#' 1. If the `cli.dynamic` option is set to `TRUE`, `TRUE` is returned.
#' 2. If the `cli.dynamic` option is set to anything else, `FALSE` is
#'    returned.
#' 3. If the `R_CLI_DYNAMIC` environment variable is not empty and set to
#'    the string `"true"`, `"TRUE"` or `"True"`, `TRUE` is returned.
#' 4. If `R_CLI_DYNAMIC` is not empty and set to anything else, `FALSE` is
#'    returned.
#' 5. If the stream is a terminal, then `TRUE` is returned.
#' 6. If the stream is the standard output or error within RStudio,
#'    the macOS R app, or RKWard IDE, `TRUE` is returned.
#' 7. Otherwise `FALSE` is returned.
#'
#' @param stream The stream to inspect or manipulate, an R connection
#' object. It can also be a string, one of `"auto"`, `"message"`,
#' `"stdout"`, `"stderr"`. `"auto"` will select `stdout()` if the session is
#' interactive and there are no sinks, otherwise it will select `stderr()`.
#'
#' @family terminal capabilities
#' @export
#' @examples
#' is_dynamic_tty()
#' is_dynamic_tty(stdout())

is_dynamic_tty <- function(stream = "auto") {

  stream <- get_real_output(stream)

  ## Option?
  if (!is.null(x <- getOption("cli.dynamic"))) {
    return(isTRUE(x))
  }

  ## Env var?
  if ((x <- Sys.getenv("R_CLI_DYNAMIC", "")) != "") {
    return(isTRUE(as.logical(x)))
  }

  ## Autodetect...
  ## RGui has isatty(stdout()) and isatty(stderr()), so we don't need
  ## to check that explicitly
  isatty(stream) ||
    is_rstudio_dynamic_tty(stream) ||
    is_rapp_stdx(stream) ||
    is_rkward_stdx(stream)
}

ANSI_ESC <- "\u001B["
ANSI_HIDE_CURSOR <- paste0(ANSI_ESC, "?25l")
ANSI_SHOW_CURSOR <- paste0(ANSI_ESC, "?25h")
ANSI_EL <- paste0(ANSI_ESC, "K")

#' Detect if a stream support ANSI escape characters
#'
#' We check that all of the following hold:
#' * The stream is a terminal.
#' * The platform is Unix.
#' * R is not running inside R.app (the macOS GUI).
#' * R is not running inside RStudio.
#' * R is not running inside Emacs.
#' * The terminal is not "dumb".
#' * `stream` is either the standard output or the standard error stream.
#'
#' @inheritParams is_dynamic_tty
#' @return `TRUE` or `FALSE`.
#'
#' @family terminal capabilities
#' @export
#' @examples
#' is_ansi_tty()

is_ansi_tty <- function(stream = "auto") {

  stream <- get_real_output(stream)

  # Option takes precedence
  opt <- getOption("cli.ansi")
  if (isTRUE(opt)) {
    return(TRUE)
  } else if (identical(opt, FALSE)) {
    return(FALSE)
  }

  # RStudio is handled separately
  if (rstudio$detect()[["ansi_tty"]] && is_stdx(stream)) return(TRUE)

  isatty(stream) &&
    .Platform$OS.type == "unix" &&
    !is_rapp() &&
    !is_emacs() &&
    Sys.getenv("TERM", "") != "dumb" &&
    is_stdx(stream)
}

#' Hide/show cursor in a terminal
#'
#' This only works in terminal emulators. In other environments, it
#' does nothing.
#'
#' `ansi_hide_cursor()` hides the cursor.
#'
#' `ansi_show_cursor()` shows the cursor.
#'
#' `ansi_with_hidden_cursor()` temporarily hides the cursor for
#' evaluating an expression.
#'
#' @inheritParams is_dynamic_tty
#' @param expr R expression to evaluate.
#'
#' @family terminal capabilities
#' @family low level ANSI functions
#' @export

ansi_hide_cursor <- function(stream = "auto") {
  if (Sys.getenv("R_CLI_HIDE_CURSOR") == "false") return()
  stream <- get_real_output(stream)
  if (is_ansi_tty(stream)) cat(ANSI_HIDE_CURSOR, file = stream)
}

#' @export
#' @name ansi_hide_cursor

ansi_show_cursor <- function(stream = "auto") {
  if (Sys.getenv("R_CLI_HIDE_CURSOR") == "false") return()
  stream <- get_real_output(stream)
  if (is_ansi_tty(stream)) cat(ANSI_SHOW_CURSOR, file = stream)
}

#' @export
#' @name ansi_hide_cursor

ansi_with_hidden_cursor <- function(expr, stream = "auto") {
  stream <- get_real_output(stream)
  ansi_hide_cursor(stream)
  on.exit(ansi_show_cursor(), add = TRUE)
  expr
}

get_embedded_utf8 <- function() {
  .Call(clic_get_embedded_utf8)
}

set_embedded_utf8 <- function(value = TRUE) {
  .Call(clic_set_embedded_utf8, value)
}

r_utf8 <- function(func,
                   args = list(),
                   package = FALSE,
                   timeout = 5000L) {
  out <- tempfile()
  on.exit(unlink(out), add = TRUE)
  opts <- callr::r_process_options(
    func = func,
    args = args,
    package = package,
    stdout = out,
    stderr = out
  )
  if (.Platform$OS.type == "windows") {
    opts$load_hook <- c(
      opts$load_hook,
      "invisible(cli:::set_embedded_utf8())"
    )
  }
  rp <- callr::r_process$new(opts)
  rp$wait(timeout)
  if (rp$is_alive()) {
    rp$kill()
    throw(cli_error("R subprocess timeout"))
  }
  list(
    status = rp$get_exit_status(),
    stdout = fix_r_utf8_output(readBin(out, "raw", file.size(out)))
  )
}

fix_r_utf8_output <- function(x) {
  beg <- grepRaw(as.raw(c(2, 255, 254)), x, fixed = TRUE, all = TRUE)
  end <- grepRaw(as.raw(c(3, 255, 254)), x, fixed = TRUE, all = TRUE)

  # In case the output is incomplete, and an UTF-8 tag is left open
  if (length(end) < length(beg)) end <- c(end, length(x) + 1L)

  if (length(beg) != length(end)) {
    throw(cli_error(
      "Invalid output from UTF-8 R",
      "i" = "Found {length(beg)} UTF-8 begin marker{?s} and {length(end)} end marker{?s}."
    ))
  }

  # Easier to handle corner cases with this
  beg <- c(beg, length(x) + 1L)
  end <- c(end, length(x) + 1L)

  out <- file(open = "w+b")
  size <- 0L
  on.exit(close(out), add = TRUE)

  doutf8 <- function(from, to) {
    if (from > to) return()
    writeBin(x[from:to], out)
    size <<- size + (to - from + 1L)
  }
  donati <- function(from, to) {
    if (from > to) return()
    xx <- iconv(list(x[from:to]), "", "UTF-8", toRaw = TRUE)[[1]]
    writeBin(xx, out)
    size <<- size + length(xx)
  }

  # Initial native part
  if (beg[1] > 1) donati(1, beg[1] - 1L)

  # UTF-8 chunk, and native part after them
  for (i in seq_along(beg)) {
    doutf8(beg[i] + 3L, end[i] - 1L)
    if (i < length(beg)) {
      donati(end[i] + 3L, beg[i + 1L] - 1L)
    }
  }

  chr <- readChar(out, size)
  Encoding(chr) <- "UTF-8"
  chr
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/unicode.R"

#' Working around the bad Unicode character widths
#'
#' R 3.6.2 and also the coming 3.6.3 and 4.0.0 versions use the Unicode 8
#' standard to calculate the display width of Unicode characters.
#' Unfortunately the widths of most emojis are incorrect in this standard,
#' and width 1 is reported instead of the correct 2 value.
#'
#' cli implements a workaround for this. The package contains a table that
#' contains all Unicode ranges that have wide characters (display width 2).
#'
#' On first use of one of the workaround wrappers (in `ansi_nchar()`, etc.)
#' we check what the current version of R thinks about the width of these
#' characters, and then create a regex that matches the ones that R
#' is wrong about (`re_bad_char_width`).
#'
#' Then we use this regex to duplicate all of the problematic characters
#' in the input string to the wrapper function, before calling the real
#' string manipulation function (`nchar()`, `strwrap()`) etc. At end we
#' undo the duplication before we return the result.
#'
#' This workaround is fine for `nchar()` and `strwrap()`, and consequently
#' `ansi_align()` and `ansi_strtrim()` as well.
#'
#' The rest of the `ansi_*()` functions work on characters, and do not
#' deal with character width.
#'
#' @keywords internal
#' @name unicode-width-workaround
NULL

setup_unicode_width_fix <- function() {
  bad <- base::nchar(wide_chars$test, type = "width") == 1
  re <- paste0(wide_chars$regex[bad], collapse = "")
  clienv$re_bad_char_width <- paste0("([", re, "])")
  clienv$re_bad_char_width_fix <- paste0("([", re, "])\\1")
}

unicode_pre <- function(x) {
  if (is.null(clienv$re_bad_char_width)) setup_unicode_width_fix()
  if (clienv$re_bad_char_width != "([])") {
    x <- gsub(clienv$re_bad_char_width, "\\1\\1", x, perl = TRUE)
  }
  x
}

unicode_post <- function(x) {
  if (is.null(clienv$re_bad_char_width)) setup_unicode_width_fix()
  if (clienv$re_bad_char_width != "([])") {
    x <- gsub(clienv$re_bad_char_width_fix, "\\1", x, perl = TRUE)
  }
  x
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/utf8.R"

#' Whether cli is emitting UTF-8 characters
#'
#' UTF-8 cli characters can be turned on by setting the `cli.unicode`
#' option to `TRUE`. They can be turned off by setting if to `FALSE`.
#' If this option is not set, then [base::l10n_info()] is used to detect
#' UTF-8 support.
#'
#' @return Flag, whether cli uses UTF-8 characters.
#'
#' @export

is_utf8_output <- function() {
  opt <- getOption("cli.unicode", NULL)
  if (! is.null(opt)) {
    isTRUE(opt)
  } else {
    l10n_info()$`UTF-8` && !is_latex_output()
  }
}

#' Count the number of characters in a character vector
#'
#' By default it counts Unicode grapheme clusters, instead of code points.
#'
#' @param x Character vector, it is converted to UTF-8.
#' @param type Whether to count graphemes (characters), code points,
#'   bytes, or calculate the display width of the string.
#' @return Numeric vector, the length of the strings in the character
#'   vector.
#'
#' @family UTF-8 string manipulation
#' @export
#' @examples
#' # Grapheme example, emoji with combining characters. This is a single
#' # grapheme, consisting of five Unicode code points:
#' # * `\U0001f477` is the construction worker emoji
#' # * `\U0001f3fb` is emoji modifier that changes the skin color
#' # * `\u200d` is the zero width joiner
#' # * `\u2640` is the female sign
#' # * `\ufe0f` is variation selector 16, requesting an emoji style glyph
#' emo <- "\U0001f477\U0001f3fb\u200d\u2640\ufe0f"
#' cat(emo)
#'
#' utf8_nchar(emo, "chars") # = graphemes
#' utf8_nchar(emo, "bytes")
#' utf8_nchar(emo, "width")
#' utf8_nchar(emo, "codepoints")
#'
#' # For comparision, the output for width depends on the R version used:
#' nchar(emo, "chars")
#' nchar(emo, "bytes")
#' nchar(emo, "width")

utf8_nchar <- function(x, type = c("chars", "bytes", "width", "graphemes",
                                   "codepoints")) {

  type <- match.arg(type)
  if (type == "chars") type <- "graphemes"

  x <- enc2utf8(x)

  if (type == "width") {
    .Call(clic_utf8_display_width, x)

  } else if (type == "graphemes") {
    .Call(clic_utf8_nchar_graphemes, x)

  } else if (type == "codepoints") {
    base::nchar(x, allowNA = FALSE, keepNA = TRUE, type = "chars")

  } else { # bytes
    base::nchar(x, allowNA = FALSE, keepNA = TRUE, type = "bytes")
  }
}

#' Substring of an UTF-8 string
#'
#' This function uses grapheme clusters instead of Unicode code points in
#' UTF-8 strings.
#'
#' @param x Character vector.
#' @param start Starting index or indices, recycled to match the length
#'   of `x`.
#' @param stop Ending index or indices, recycled to match the length of
#'   `x`.
#' @return Character vector of the same length as `x`, containing
#'   the requested substrings.
#'
#' @family UTF-8 string manipulation
#' @export
#' @examples
#' # Five grapheme clusters, select the middle three
#' str <- paste0(
#'   "\U0001f477\U0001f3ff\u200d\u2640\ufe0f",
#'   "\U0001f477\U0001f3ff",
#'   "\U0001f477\u200d\u2640\ufe0f",
#'   "\U0001f477\U0001f3fb",
#'   "\U0001f477\U0001f3ff")
#' cat(str)
#' str24 <- utf8_substr(str, 2, 4)
#' cat(str24)

utf8_substr <- function(x, start, stop) {
  if (!is.character(x)) x <- as.character(x)
  if (!is.numeric(start) || !is.numeric(stop)) {
    throw(cli_error(
      "{.arg start} and {.arg stop} must be numeric vectors",
      "i" = if (!is.numeric(start)) "{.arg start} is {.typeof {start}}",
      "i" = if (!is.numeric(stop))  "{.arg stop}  is {.typeof {stop}}"
    ))
  }
  start2 <- suppressWarnings(as.integer(start))
  stop2 <- suppressWarnings(as.integer(stop))
  if (!length(start2) || !length(stop2)) {
    throw(cli_error(
      "{.arg start} and {.arg stop} must have at least length 1",
      "i" = if (!length(start2)) "{.arg start} has length 0",
      "i" = if (!length(stop2))  "{.arg stop}  has length 0"
    ))
  }
  x <- enc2utf8(x)

  # TODO: better recycling
  start2 <- rep_len(start2, length(x))
  stop2 <- rep_len(stop2, length(x))
  .Call(clic_utf8_substr, x, start2, stop2)
}

#' Break an UTF-8 character vector into grapheme clusters
#'
#' @param x Character vector.
#' @return List of characters vectors, the grapheme clusters of the input
#'   string.
#'
#' @family UTF-8 string manipulation
#' @export
#' @examples
#' # Five grapheme clusters
#' str <- paste0(
#'   "\U0001f477\U0001f3ff\u200d\u2640\ufe0f",
#'   "\U0001f477\U0001f3ff",
#'   "\U0001f477\u200d\u2640\ufe0f",
#'   "\U0001f477\U0001f3fb",
#'   "\U0001f477\U0001f3ff")
#' cat(str, "\n")
#' chrs <- utf8_graphemes(str)

utf8_graphemes <- function(x) {
  if (!is.character(x)) x <- as.character(x)
  x <- enc2utf8(x)
  .Call(clic_utf8_graphemes, x)
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/utils.R"

is_yes <- function(x) {
  tolower(x) %in% c("true", "yes", "y", "t", "1")
}

format_iso_8601 <- function(p) {
  format(p, "%Y-%m-%dT%H:%M:%S+00:00")
}

has_packages <- function(pkgs) {
  all(vapply(pkgs, requireNamespace, logical(1), quietly = TRUE))
}

cli_escape <- function(x) {
  x <- gsub("{", "{{", x, fixed = TRUE)
  x <- gsub("}", "}}", x, fixed = TRUE)
  x
}

# missing from older R

isFALSE <- function (x) {
  is.logical(x) && length(x) == 1L && !is.na(x) && !x
}

get_ppid <- function() {
  .Call(clic_getppid)
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/vt.R"

#' Simulate (a subset of) a VT-5xx ANSI terminal
#'
#' This is utility function that calculates the state of a VT-5xx screen
#' after a certain set of output.
#'
#' Currently it supports:
#'
#' - configurable terminal width and height
#' - ASCII printable characters.
#' - `\n`, `\r`.
#' - ANSI SGR colors, 8 color mode, 256 color mode and true color mode.
#' - Other ANSI SGR features: bold, italic, underline, strikethrough,
#'   blink, inverse.
#'
#' It does _not_ currently supports other features, mode notably:
#'
#' - Other ANSI control sequences and features. Other control sequences
#'   are silently ignored.
#' - Wide Unicode characters. Their width is not taken into account
#'   correctly.
#' - Unicode graphemes.
#'
#' @param output Character vector or raw vector. Character vectors are
#' collapsed (without a separater), and converted to a raw vector using
#' [base::charToRaw()].
#' @param width Terminal width.
#' @param height Terminal height.
#' @return Data frame with columns `lineno`, `segmentno`, `segment`,
#' `attributes`.
#'
#' @note
#' This function is experimental, and the virtual temrinal API will
#' likely change in future versions of cli.
#'
#' @export

vt_output <- function(output, width = 80L, height = 25L) {
  if (is.character(output)) {
    output <- charToRaw(paste(output, collapse = ""))
  }

  res <- .Call(
    clic_vt_output,
    output,
    as.integer(width),
    as.integer(height)
  )

  linksx <- vapply(res$links, intToUtf8, character(1))
  links <- sub("^[^;]*;", "", linksx)
  links_params <- sub(";[^;]*$", "", linksx)

  df <- data.frame(
    stringsAsFactors = FALSE,
    lineno = integer(),
    segmentno = integer(),
    segment = character(),
    attributes = character()
  )

  segments <- lapply(seq_along(res$lines), function(i) {
    line <- intToUtf8(res$lines[[i]])
    attr <- res$attrs[[i]]
    lgs <- rle(attr)
    clgs <- cumsum(c(0, lgs$lengths))
    segs <- mapply(clgs[-length(clgs)], clgs[-1], FUN = function(s, e) {
      utf8_substr(line, s + 1, e)
    })

    fg <- re_match(lgs$values, "fg:([0-9]+|#[0-9a-f]+);")[,1]
    bg <- re_match(lgs$values, "bg:([0-9]+|#[0-9a-f]+);")[,1]
    linkno <- as.integer(re_match(lgs$values, "link:([0-9]+);")[,1])
    link <- links[linkno]
    link_params <- links_params[linkno]

    data.frame(
      stringsAsFactors = FALSE,
      lineno = i,
      segmentno = seq_along(segments),
      segment = segs,
      bold = grepl("bold;", lgs$values, fixed = TRUE),
      italic = grepl("italic;", lgs$values, fixed = TRUE),
      underline = grepl("underline;", lgs$values, fixed = TRUE),
      strikethrough = grepl("strikethrough;", lgs$values, fixed = TRUE),
      blink = grepl("blink;", lgs$values, fixed = TRUE),
      inverse = grepl("inverse;", lgs$values, fixed = TRUE),
      color = fg,
      background_color = bg,
      link = link,
      link_params = link_params
    )
  })

  do.call(rbind, c(list(df), segments))
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/width.R"

#' Determine the width of the console
#'
#' It uses the `cli.width` option, if set. Otherwise it tries to
#' determine the size of the terminal or console window.
#'
#' These are the exact rules:
#' * If the `cli.width` option is set to a positive integer, it is used.
#' * If the `cli.width` option is set, but it is not a positive integer,
#'   and error is thrown.
#'
#' Then we try to determine the size of the terminal or console window:
#' * If we are not in RStudio, or we are in an RStudio terminal,
#'   then we try to use the `tty_size()` function to query the
#'   terminal size. This might fail if R is not running in a terminal,
#'   but failures are ignored.
#' * If we are in the RStudio build pane, then the `RSTUDIO_CONSOLE_WIDTH`
#'   environment variable is used. If the build pane is resized, then this
#'   environment variable is not accurate any more, and the output might
#'   get garbled.
#' * We are _not_ using the `RSTUDIO_CONSOLE_WIDTH` environment variable
#'   if we are in the RStudio console.
#'
#' If we cannot determine the size of the terminal or console window, then
#' we use the `width` option. If the `width` option is not set, then
#' we return 80L.
#'
#' @return Integer scalar, the console with, in number of characters.
#'
#' @export
#' @examples
#' console_width()

console_width <- function() {
  # cli.width option always takes priotity
  cwopt <- getOption("cli.width")
  if (!is.null(cwopt)) {
    if (!is.numeric(cwopt) || length(cwopt) != 1) {
      opt <- options(cli.width = 60)
      on.exit(options(opt), add = TRUE)
      throw(cli_error(
        "{.code options(\"cli.width\")} must be an integer scalar.",
        "i" = "{.code options(\"cli.width\")} is {.type {cwopt}}."
      ))
    }
    if (is.na(cwopt)) {
      opt <- options(cli.width = 60)
      on.exit(options(opt), add = TRUE)
      throw(cli_error("{.code options(\"cli.width\")} cannot be {.code NA}."))
    }
    if (cwopt == Inf) {
      cwopti <- .Machine$integer.max
    } else {
      cwopti <- as.integer(cwopt)
    }
    if (cwopti <= 0) {
      opt <- options(cli.width = 60)
      on.exit(options(opt), add = TRUE)
      throw(cli_error(
        "{.code options(\"cli.width\")} must be a positive integer and not {.val {cwopti}}."
      ))
    }
    return(cwopti)
  }

  # detect if in RStudio
  rs <- rstudio$detect()
  if (rs$type == "not_rstudio") {
    # maybe a terminal?
    width <- terminal_width()

  } else if (rs$type == "rstudio_console_starting") {
    # there isn't much we can do here, options and env vars are not set
    width <- NULL

  } else if (rs$type == "rstudio_console") {
    # will just use getOption("width"), in case the user changed it,
    # and ignore the RSTUDIO_CONSOLE_WIDTH env var
    width <- NULL

  } else if (rs$type == "rstudio_build_pane") {
    # RStudio explicitly sets this for build pane processes
    # It is only good when the build starts, but we cannot do better
    width <- rs_console_width()

  } else if (rs$type == "rstudio_terminal") {
    # Can also be a subprocess of the terminal, with a pty,
    # but that's fine, the pty should have a width set up.
    # We do not fall back to the RSTUDIO_CONSOLE_WIDTH env var,
    # because the user might have changed options("width") and the env
    # var is only good when the terminal starts, anyway.
    width <- terminal_width()

  } else { # rstudio_subprocess
    width <- NULL
  }

  # If not set, then use the option
  width <- width %||% getOption("width") %||% 80L

  width
}

tty_size <- function() {
  ret <- .Call(clic_tty_size)
  c(width = ret[1], height = ret[2])
}

terminal_width <- function() {
  if (isTRUE(clienv$notaconsole)) return(NULL)
  w <- tryCatch(
    tty_size()[["width"]],
    error = function(e) {
      clienv$notaconsole <- TRUE
      NULL
    }
  )

  # this is probably a pty that does not set the width, use st sensible
  if (!is.null(w) && w == 0) w <- 80L
  w
}

rs_console_width <- function() {
  ev <- as.integer(Sys.getenv("RSTUDIO_CONSOLE_WIDTH", ""))[1]
  if (!is.na(ev)) ev else NULL
}
#line 1 "/tmp/Rtmp7OqwrA/R.INSTALLa0d364f70ad/cli/R/zzz.R"

#' ANSI colored text
#'
#' cli has a number of functions to color and style text at the command
#' line. They provide a more modern interface than the crayon package.
#'
#' The `col_*` functions change the (foreground) color to the text.
#' These are the eight original ANSI colors. Note that in some terminals,
#' they might actually look differently, as terminals have their own
#' settings for how to show them. `col_none()` is the default color, this
#' is useful in a substring of a colored string.
#'
#' The `col_br_*` functions are bright versions of the eight ANSI colors.
#' Note that on some terminal configurations and themes they might be the
#' same as the non-bright colors.
#'
#' The `bg_*` functions change the background color of the text.
#' These are the eight original ANSI background colors. These, too, can
#' vary in appearance, depending on terminal settings. `bg_none()` the
#' the default background color, this is useful in a substring of a
#' background-colored string.
#'
#' The `bg_br_*` functions are the bright versions of the eight ANSI
#' background colors. Note that on some terminal configurations and themes
#' they might be the same as the non-bright colors.
#'
#' The `style_*` functions apply other styling to the text. The currently
#' supported styling functions are:
#' * `style_reset()` to remove any style, including color,
#' * `style_bold()` for boldface / strong text, although some terminals
#'   show a bright, high intensity text instead,
#' * `style_dim()` (or `style_blurred()` reduced intensity text.
#' * `style_italic()` (not widely supported).
#' * `style_underline()`,
#' * `style_inverse()`,
#' * `style_hidden()`,
#' * `style_strikethrough()` (not widely supported).
#'
#' The style functions take any number of character vectors as arguments,
#' and they concatenate them using `paste0()` before adding the style.
#'
#' Styles can also be nested, and then inner style takes precedence, see
#' examples below.
#'
#' Sometimes you want to revert back to the default text color, in the
#' middle of colored text, or you want to have a normal font in the middle
#' of italic text. You can use the `style_no_*` functions for this. Every
#' `style_*()` function has a `style_no_*()` pair, which defends its
#' argument from taking on the style. See examples below.
#'
#' @param ... Character strings, they will be pasted together with
#'   `paste0()`, before applying the style function.
#' @return An ANSI string (class `cli_ansi_string`), that contains ANSI
#'   sequences, if the current platform supports them. You can simply
#'   use `cat()` to print them to the terminal.
#'
#' @family ANSI styling
#' @name ansi-styles
#' @examples
#' col_blue("Hello ", "world!")
#' cat(col_blue("Hello ", "world!"))
#'
#' cat("... to highlight the", col_red("search term"),
#'     "in a block of text\n")
#'
#' ## Style stack properly
#' cat(col_green(
#'  "I am a green line ",
#'  col_blue(style_underline(style_bold("with a blue substring"))),
#'  " that becomes green again!"
#' ))
#'
#' error <- combine_ansi_styles("red", "bold")
#' warn <- combine_ansi_styles("magenta", "underline")
#' note <- col_cyan
#' cat(error("Error: subscript out of bounds!\n"))
#' cat(warn("Warning: shorter argument was recycled.\n"))
#' cat(note("Note: no such directory.\n"))
#'
#' # style_no_* functions, note that the color is not removed
#' style_italic(col_green(paste0(
#'   "italic before, ",
#'   style_no_italic("normal here, "),
#'   "italic after"
#' )))
#'
#' # avoiding  color for substring
#' style_italic(col_red(paste(
#'   "red before",
#'   col_none("not red between"),
#'   "red after"
#' )))
NULL

#' @export
#' @name ansi-styles
bg_black    <- create_ansi_style("bg_black")
#' @export
#' @name ansi-styles
bg_blue     <- create_ansi_style("bg_blue")
#' @export
#' @name ansi-styles
bg_cyan     <- create_ansi_style("bg_cyan")
#' @export
#' @name ansi-styles
bg_green    <- create_ansi_style("bg_green")
#' @export
#' @name ansi-styles
bg_magenta  <- create_ansi_style("bg_magenta")
#' @export
#' @name ansi-styles
bg_red      <- create_ansi_style("bg_red")
#' @export
#' @name ansi-styles
bg_white    <- create_ansi_style("bg_white")
#' @export
#' @name ansi-styles
bg_yellow   <- create_ansi_style("bg_yellow")
#' @export
#' @name ansi-styles
bg_none <- create_ansi_style("no_bg_color")

#' @export
#' @name ansi-styles
bg_br_black    <- create_ansi_style("bg_br_black")
#' @export
#' @name ansi-styles
bg_br_blue     <- create_ansi_style("bg_br_blue")
#' @export
#' @name ansi-styles
bg_br_cyan     <- create_ansi_style("bg_br_cyan")
#' @export
#' @name ansi-styles
bg_br_green    <- create_ansi_style("bg_br_green")
#' @export
#' @name ansi-styles
bg_br_magenta  <- create_ansi_style("bg_br_magenta")
#' @export
#' @name ansi-styles
bg_br_red      <- create_ansi_style("bg_br_red")
#' @export
#' @name ansi-styles
bg_br_white    <- create_ansi_style("bg_br_white")
#' @export
#' @name ansi-styles
bg_br_yellow   <- create_ansi_style("bg_br_yellow")

#' @export
#' @name ansi-styles
col_black   <- create_ansi_style("black")
#' @export
#' @name ansi-styles
col_blue    <- create_ansi_style("blue")
#' @export
#' @name ansi-styles
col_cyan    <- create_ansi_style("cyan")
#' @export
#' @name ansi-styles
col_green   <- create_ansi_style("green")
#' @export
#' @name ansi-styles
col_magenta <- create_ansi_style("magenta")
#' @export
#' @name ansi-styles
col_red     <- create_ansi_style("red")
#' @export
#' @name ansi-styles
col_white   <- create_ansi_style("white")
#' @export
#' @name ansi-styles
col_yellow  <- create_ansi_style("yellow")
#' @export
#' @name ansi-styles
col_grey    <- create_ansi_style("silver")
#' @export
#' @name ansi-styles
col_silver  <- create_ansi_style("silver")
#' @export
#' @name ansi-styles
col_none <- create_ansi_style("no_color")

#' @export
#' @name ansi-styles
col_br_black   <- create_ansi_style("br_black")
#' @export
#' @name ansi-styles
col_br_blue    <- create_ansi_style("br_blue")
#' @export
#' @name ansi-styles
col_br_cyan    <- create_ansi_style("br_cyan")
#' @export
#' @name ansi-styles
col_br_green   <- create_ansi_style("br_green")
#' @export
#' @name ansi-styles
col_br_magenta <- create_ansi_style("br_magenta")
#' @export
#' @name ansi-styles
col_br_red     <- create_ansi_style("br_red")
#' @export
#' @name ansi-styles
col_br_white   <- create_ansi_style("br_white")
#' @export
#' @name ansi-styles
col_br_yellow  <- create_ansi_style("br_yellow")

#' @export
#' @name ansi-styles
style_dim           <- create_ansi_style("blurred")
#' @export
#' @name ansi-styles
style_blurred       <- create_ansi_style("blurred")
#' @export
#' @name ansi-styles
style_bold          <- create_ansi_style("bold")
#' @export
#' @name ansi-styles
style_hidden        <- create_ansi_style("hidden")
#' @export
#' @name ansi-styles
style_inverse       <- create_ansi_style("inverse")
#' @export
#' @name ansi-styles
style_italic        <- create_ansi_style("italic")
#' @export
#' @name ansi-styles
style_reset         <- create_ansi_style("reset")
#' @export
#' @name ansi-styles
style_strikethrough <- create_ansi_style("strikethrough")
#' @export
#' @name ansi-styles
style_underline     <- create_ansi_style("underline")

#' @export
#' @name ansi-styles
style_no_bold <- create_ansi_style("no_bold")
#' @export
#' @name ansi-styles
style_no_blurred <- create_ansi_style("no_blurred")
#' @export
#' @name ansi-styles
style_no_dim <- create_ansi_style("no_blurred")
#' @export
#' @name ansi-styles
style_no_italic <- create_ansi_style("no_italic")
#' @export
#' @name ansi-styles
style_no_underline <- create_ansi_style("no_underline")
#' @export
#' @name ansi-styles
style_no_inverse <- create_ansi_style("no_inverse")
#' @export
#' @name ansi-styles
style_no_hidden <- create_ansi_style("no_hidden")
#' @export
#' @name ansi-styles
style_no_strikethrough <- create_ansi_style("no_strikethrough")
#' @export
#' @name ansi-styles
style_no_color <- create_ansi_style("no_color")
#' @export
#' @name ansi-styles
style_no_bg_color <- create_ansi_style("no_bg_color")
