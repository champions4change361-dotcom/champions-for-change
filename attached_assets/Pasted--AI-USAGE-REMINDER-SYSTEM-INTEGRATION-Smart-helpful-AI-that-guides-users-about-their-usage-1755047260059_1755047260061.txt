// ðŸ¤– AI USAGE REMINDER SYSTEM INTEGRATION
// Smart, helpful AI that guides users about their usage and upgrade options

// =============================================================================
// 1. AI CONTEXT ENHANCEMENT FOR USAGE TRACKING
// =============================================================================

// Add to existing AI context schema
export const tournaments = pgTable("tournaments", {
  // ... existing fields
  
  // AI USAGE CONTEXT
  aiSetupProgress: jsonb("ai_setup_progress").$type<{
    donationModuleStep: string;
    stripeAccountStatus: string;
    lastAIInteraction: string;
    completedSteps: string[];
    userResponses: Record<string, any>;
    
    // USAGE AWARENESS
    hasBeenWarnedAboutLimit: boolean;
    lastUsageReminder: string;
    suggestedUpgradeOptions: string[];
    usagePattern: 'light' | 'moderate' | 'heavy';
  }>(),
});

export const users = pgTable("users", {
  // ... existing fields
  
  // AI USAGE PREFERENCES
  aiPreferences: jsonb("ai_preferences").$type<{
    wantsProactiveHelp: boolean;
    communicationStyle: 'friendly' | 'professional' | 'technical';
    helpLevel: 'minimal' | 'guided' | 'comprehensive';
    hasCompletedOnboarding: boolean;
    
    // AVATAR PREFERENCES
    avatarEnabled: boolean;
    avatarStyle: 'professional_coach' | 'friendly_advisor' | 'minimalist_icon' | 'sports_mascot';
    
    // USAGE REMINDER PREFERENCES
    usageRemindersEnabled: boolean;
    reminderFrequency: 'immediate' | 'daily' | 'weekly';
    lastUsageReminderSent: string;
    dismissedUpgradePrompts: string[]; // Track what they've already seen
  }>(),
});

// =============================================================================
// 2. ENHANCED AI CONTEXT SERVICE WITH USAGE AWARENESS
// =============================================================================

export class AIUsageAwarenessService extends AIContextService {
  
  // Generate usage-aware AI responses
  async generateUsageAwareResponse(context: any, userQuestion: string): Promise<{
    response: string;
    usageAlert?: {
      type: 'info' | 'warning' | 'limit_reached';
      message: string;
      actionSuggested?: string;
    };
    proactiveHelp?: string[];
  }> {
    const { user, currentTournament, history } = context;
    const usageStatus = await this.analyzeUsageStatus(user);
    
    // Base response generation
    let response = await this.generateContextualResponse(context, userQuestion);
    
    // Add usage awareness if appropriate
    const usageAlert = this.generateUsageAlert(usageStatus, user);
    const proactiveHelp = await this.generateProactiveHelp(usageStatus, user, history);
    
    // Enhance response with usage context if relevant
    if (this.shouldMentionUsage(userQuestion, usageStatus)) {
      response = this.enhanceResponseWithUsage(response, usageStatus, user);
    }
    
    return {
      response,
      usageAlert,
      proactiveHelp
    };
  }
  
  // Analyze user's current usage status
  private async analyzeUsageStatus(user: any): Promise<{
    planType: string;
    remainingTournaments: number;
    totalAvailable: number;
    usagePercentage: number;
    creditsAvailable: number;
    status: 'plenty' | 'moderate' | 'warning' | 'critical' | 'unlimited';
    recommendedAction?: string;
  }> {
    const remaining = user.monthlyTournamentLimit - user.currentMonthTournaments;
    const percentage = (user.currentMonthTournaments / user.monthlyTournamentLimit) * 100;
    const total = remaining + user.tournamentCredits;
    
    let status: 'plenty' | 'moderate' | 'warning' | 'critical' | 'unlimited';
    let recommendedAction: string | undefined;
    
    if (user.subscriptionPlan !== 'foundation' && user.subscriptionPlan !== 'starter') {
      status = 'unlimited';
    } else if (total <= 0) {
      status = 'critical';
      recommendedAction = 'upgrade_or_purchase';
    } else if (percentage >= 80) {
      status = 'warning';
      recommendedAction = 'consider_upgrade';
    } else if (percentage >= 60) {
      status = 'moderate';
      recommendedAction = 'plan_ahead';
    } else {
      status = 'plenty';
    }
    
    return {
      planType: user.subscriptionPlan,
      remainingTournaments: remaining,
      totalAvailable: total,
      usagePercentage: percentage,
      creditsAvailable: user.tournamentCredits,
      status,
      recommendedAction
    };
  }
  
  // Generate appropriate usage alerts
  private generateUsageAlert(usageStatus: any, user: any): any {
    if (usageStatus.status === 'unlimited') return null;
    
    switch (usageStatus.status) {
      case 'critical':
        return {
          type: 'limit_reached',
          message: `You've reached your monthly limit! You have ${usageStatus.creditsAvailable} credits remaining.`,
          actionSuggested: 'upgrade_or_purchase'
        };
        
      case 'warning':
        return {
          type: 'warning',
          message: `You're using ${Math.round(usageStatus.usagePercentage)}% of your monthly tournaments (${usageStatus.totalAvailable} remaining).`,
          actionSuggested: 'consider_options'
        };
        
      case 'moderate':
        return {
          type: 'info',
          message: `You have ${usageStatus.totalAvailable} tournaments remaining this month.`
        };
        
      default:
        return null;
    }
  }
  
  // Generate proactive help suggestions
  private async generateProactiveHelp(usageStatus: any, user: any, history: any): Promise<string[]> {
    const suggestions: string[] = [];
    
    // Don't overwhelm users who've dismissed suggestions
    const dismissed = user.aiPreferences?.dismissedUpgradePrompts || [];
    
    if (usageStatus.status === 'critical' && !dismissed.includes('critical_upgrade')) {
      suggestions.push("Need more tournaments? I can help you upgrade to unlimited or purchase additional credits.");
    }
    
    if (usageStatus.status === 'warning' && !dismissed.includes('warning_upgrade')) {
      suggestions.push("Getting close to your limit! Want me to show you expansion options?");
    }
    
    if (history.averageDonationGoal > 300 && user.subscriptionPlan === 'foundation') {
      suggestions.push("Your tournaments are raising good money! Professional plan includes advanced features for serious organizers.");
    }
    
    if (history.totalTournaments > 10 && user.subscriptionPlan === 'foundation') {
      suggestions.push("You're an experienced organizer! Unlimited plans eliminate usage worries completely.");
    }
    
    return suggestions;
  }
  
  // Determine if usage should be mentioned in response
  private shouldMentionUsage(question: string, usageStatus: any): boolean {
    const usageKeywords = ['tournament', 'create', 'setup', 'limit', 'more', 'additional'];
    const hasUsageKeyword = usageKeywords.some(keyword => 
      question.toLowerCase().includes(keyword)
    );
    
    return hasUsageKeyword && (usageStatus.status === 'warning' || usageStatus.status === 'critical');
  }
  
  // Enhance response with usage context
  private enhanceResponseWithUsage(response: string, usageStatus: any, user: any): string {
    if (usageStatus.status === 'critical') {
      return `${response}\n\nBy the way, you've reached your monthly tournament limit, but you have ${usageStatus.creditsAvailable} credits available. Would you like me to help you use those or explore upgrade options?`;
    }
    
    if (usageStatus.status === 'warning') {
      return `${response}\n\nQuick note: You have ${usageStatus.totalAvailable} tournaments remaining this month. Planning any more events?`;
    }
    
    return response;
  }
}

// =============================================================================
// 3. PROACTIVE USAGE REMINDER SYSTEM
// =============================================================================

export class UsageReminderSystem {
  
  // Check if user needs usage reminders
  static async shouldSendUsageReminder(userId: string, storage: any): Promise<{
    shouldSend: boolean;
    reminderType: 'milestone' | 'warning' | 'critical' | 'upgrade_suggestion';
    message: string;
    actionItems?: string[];
  }> {
    const user = await storage.getUser(userId);
    const usageService = new AIUsageAwarenessService(storage);
    const usageStatus = await usageService.analyzeUsageStatus(user);
    
    // Check user preferences
    if (!user.aiPreferences?.usageRemindersEnabled) {
      return { shouldSend: false, reminderType: 'milestone', message: '' };
    }
    
    // Check if recently reminded
    const lastReminder = user.aiPreferences?.lastUsageReminderSent;
    if (lastReminder) {
      const hoursSinceReminder = (Date.now() - new Date(lastReminder).getTime()) / (1000 * 60 * 60);
      if (hoursSinceReminder < 24) {
        return { shouldSend: false, reminderType: 'milestone', message: '' };
      }
    }
    
    // Generate appropriate reminder
    return this.generateUsageReminder(usageStatus, user);
  }
  
  // Generate contextual usage reminders
  private static generateUsageReminder(usageStatus: any, user: any): {
    shouldSend: boolean;
    reminderType: 'milestone' | 'warning' | 'critical' | 'upgrade_suggestion';
    message: string;
    actionItems?: string[];
  } {
    const friendlyStyle = user.aiPreferences?.communicationStyle === 'friendly';
    const greeting = friendlyStyle ? "Hey there! ðŸ‘‹" : "Hello!";
    
    switch (usageStatus.status) {
      case 'critical':
        return {
          shouldSend: true,
          reminderType: 'critical',
          message: `${greeting} You've reached your monthly tournament limit, but I noticed you have ${usageStatus.creditsAvailable} credits available. Want me to help you use those or explore unlimited options?`,
          actionItems: [
            'Use available credits',
            'Purchase more credits',
            'Upgrade to unlimited plan',
            'View usage history'
          ]
        };
        
      case 'warning':
        return {
          shouldSend: true,
          reminderType: 'warning',
          message: `${greeting} Quick heads up - you've used ${Math.round(usageStatus.usagePercentage)}% of your monthly tournaments. You have ${usageStatus.totalAvailable} remaining. Planning any more events this month?`,
          actionItems: [
            'Plan remaining tournaments',
            'Consider credit pack',
            'Explore unlimited plans'
          ]
        };
        
      case 'moderate':
        if (user.totalTournamentsCreated > 15) {
          return {
            shouldSend: true,
            reminderType: 'upgrade_suggestion',
            message: `${greeting} I noticed you're a regular tournament organizer (${user.totalTournamentsCreated} tournaments created)! Have you considered our unlimited plans? They eliminate usage worries completely.`,
            actionItems: [
              'View unlimited plans',
              'Calculate potential savings',
              'See plan comparison'
            ]
          };
        }
        break;
    }
    
    return { shouldSend: false, reminderType: 'milestone', message: '' };
  }
  
  // Send usage reminder through appropriate channel
  static async sendUsageReminder(userId: string, reminderData: any, storage: any): Promise<void> {
    // Update last reminder timestamp
    await storage.updateUserAIPreferences(userId, {
      lastUsageReminderSent: new Date().toISOString()
    });
    
    // Log the reminder for analytics
    await storage.createUsageLog({
      userId,
      actionType: 'usage_reminder_sent',
      metadata: {
        reminderType: reminderData.reminderType,
        usageStatus: reminderData.message
      },
      timestamp: new Date()
    });
    
    // In a real implementation, you might:
    // - Send email notification
    // - Create in-app notification
    // - Add to dashboard alert queue
    // - Trigger push notification
  }
}

// =============================================================================
// 5. KEYSTONE AI AVATAR SYSTEM
// =============================================================================

export class KeystoneAvatarService {
  
  // Get domain-appropriate avatar defaults
  static getDomainAvatarDefaults(domain: string): {
    enabled: boolean;
    style: string;
    reason: string;
  } {
    switch (domain) {
      case 'tournaments.trantortournaments.org':
        return {
          enabled: false, // Professional default for education
          style: 'professional_coach',
          reason: 'Educational districts prefer professional interfaces'
        };
        
      case 'pro.trantortournaments.org':
        return {
          enabled: true, // Business users like personality
          style: 'friendly_advisor',
          reason: 'Business users appreciate helpful guidance'
        };
        
      case 'coaches.trantortournaments.org':
        return {
          enabled: true, // Community wants fun
          style: 'sports_mascot', 
          reason: 'Community platform encourages personality'
        };
        
      default:
        return {
          enabled: false,
          style: 'minimalist_icon',
          reason: 'Conservative default'
        };
    }
  }
  
  // Avatar preference setup during onboarding
  static async setupAvatarPreferences(userId: string, domain: string, storage: any): Promise<void> {
    const defaults = this.getDomainAvatarDefaults(domain);
    
    await storage.updateUserAIPreferences(userId, {
      avatarEnabled: defaults.enabled,
      avatarStyle: defaults.style
    });
  }
  
  // Generate avatar introduction message
  static generateAvatarIntroduction(domain: string, userPreferences: any): string {
    const defaults = this.getDomainAvatarDefaults(domain);
    
    if (defaults.enabled && !userPreferences.hasCompletedOnboarding) {
      return `Hi! I'm Keystone AI, your tournament assistant. I'm here to help you create amazing tournaments and manage everything smoothly. Would you like me to have a visual avatar, or prefer text-only interactions? You can change this anytime in settings.`;
    }
    
    return `Hi! I'm Keystone AI. I'm here to help you with tournament setup, donations, and anything else you need. Ready to get started?`;
  }
}

// =============================================================================
// 6. AI CHAT INTEGRATION WITH AVATAR AWARENESS
// =============================================================================

// Enhanced AI chat endpoint with usage awareness and avatar support
app.post("/api/ai/keystone-chat", async (req, res) => {
  try {
    const { userId, tournamentId, question, conversationHistory, domain } = req.body;
    const storage = await getStorage();
    const aiService = new AIUsageAwarenessService(storage);

    // Get comprehensive context including usage
    const context = await aiService.getAIContext(userId, tournamentId);
    
    // Get user's avatar preferences
    const avatarDefaults = KeystoneAvatarService.getDomainAvatarDefaults(domain);
    const userAvatarPrefs = context.user.aiPreferences || {};
    
    // Generate usage-aware response
    const aiResponse = await aiService.generateUsageAwareResponse(context, question);
    
    // Add avatar introduction if first interaction
    if (!userAvatarPrefs.hasCompletedOnboarding) {
      const avatarIntro = KeystoneAvatarService.generateAvatarIntroduction(domain, userAvatarPrefs);
      aiResponse.response = `${avatarIntro}\n\n${aiResponse.response}`;
    }
    
    // Check if usage reminder should be sent
    const reminderCheck = await UsageReminderSystem.shouldSendUsageReminder(userId, storage);
    
    // Update interaction tracking
    await storage.updateUser(userId, {
      aiInteractionCount: (context.user.totalInteractions || 0) + 1,
      updatedAt: new Date()
    });

    res.json({
      success: true,
      response: aiResponse.response,
      usageAlert: aiResponse.usageAlert,
      proactiveHelp: aiResponse.proactiveHelp,
      usageReminder: reminderCheck.shouldSend ? {
        type: reminderCheck.reminderType,
        message: reminderCheck.message,
        actionItems: reminderCheck.actionItems
      } : null,
      
      // AVATAR INFORMATION
      avatar: {
        enabled: userAvatarPrefs.avatarEnabled ?? avatarDefaults.enabled,
        style: userAvatarPrefs.avatarStyle ?? avatarDefaults.style,
        showIntroduction: !userAvatarPrefs.hasCompletedOnboarding
      },
      
      context: {
        userLevel: context.user.techSkillLevel,
        experienceLevel: context.user.successfulSetups > 2 ? 'experienced' : 'learning',
        usageStatus: await aiService.analyzeUsageStatus(context.user)
      }
    });

  } catch (error) {
    console.error("Keystone AI chat error:", error);
    res.status(500).json({
      success: false,
      message: "Keystone AI temporarily unavailable",
      fallbackResponse: "I'm having trouble right now, but I'm still here to help with your tournament questions!"
    });
  }
});

// Avatar preference update endpoint
app.post("/api/ai/avatar-preferences", async (req, res) => {
  try {
    const { userId, avatarEnabled, avatarStyle } = req.body;
    const storage = await getStorage();
    
    await storage.updateUserAIPreferences(userId, {
      avatarEnabled,
      avatarStyle,
      hasCompletedOnboarding: true
    });
    
    res.json({
      success: true,
      message: "Avatar preferences updated",
      preferences: { avatarEnabled, avatarStyle }
    });
    
  } catch (error) {
    console.error("Avatar preference update error:", error);
    res.status(500).json({ success: false, error: "Update failed" });
  }
});

// Proactive usage check endpoint (called periodically)
app.get("/api/ai/check-usage-reminders/:userId", async (req, res) => {
  try {
    const { userId } = req.params;
    const storage = await getStorage();
    
    const reminderCheck = await UsageReminderSystem.shouldSendUsageReminder(userId, storage);
    
    if (reminderCheck.shouldSend) {
      await UsageReminderSystem.sendUsageReminder(userId, reminderCheck, storage);
    }
    
    res.json({
      reminderSent: reminderCheck.shouldSend,
      reminderType: reminderCheck.reminderType
    });
    
  } catch (error) {
    console.error("Usage reminder check error:", error);
    res.status(500).json({ error: "Check failed" });
  }
});

/*
IMPLEMENTATION SUMMARY FOR DRIZZLE AI:

ðŸ¤– KEYSTONE AI SYSTEM:
âœ… Usage-aware contextual responses
âœ… Proactive upgrade suggestions  
âœ… Personalized communication styles
âœ… Smart reminder frequency control

ðŸŽ­ AVATAR SYSTEM:
âœ… Optional avatar toggle per user preference
âœ… Domain-appropriate defaults:
   - Education: OFF (professional)
   - Business: ON (friendly advisor) 
   - Coaches: ON (sports mascot)
âœ… Avatar style choices: professional_coach, friendly_advisor, minimalist_icon, sports_mascot
âœ… Onboarding avatar preference setup

ðŸ’¡ PROACTIVE REMINDERS:
âœ… "You're at 4/5 tournaments this month..."
âœ… "Reached your limit! Here are your options..."
âœ… "You're a power user! Consider unlimited..."
âœ… "Planning more events? Let me help..."

ðŸŽ¯ USER-FRIENDLY APPROACH:
âœ… Educational coaching tone
âœ… Supportive rather than pushy
âœ… Actionable suggestions
âœ… Respects user preferences and domain context

ðŸ”§ INTEGRATION POINTS:
âœ… Enhanced AI context service with avatar awareness
âœ… Usage-aware chat responses
âœ… Proactive reminder system with avatar intro
âœ… Dashboard usage widgets
âœ… Avatar preference management

This makes Keystone AI feel like a helpful coach guiding users toward success, with optional personality that respects professional environments!
*/