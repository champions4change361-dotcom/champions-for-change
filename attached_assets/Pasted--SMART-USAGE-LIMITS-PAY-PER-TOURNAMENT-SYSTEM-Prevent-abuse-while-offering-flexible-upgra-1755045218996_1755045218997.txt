// ðŸ”’ SMART USAGE LIMITS & PAY-PER-TOURNAMENT SYSTEM
// Prevent abuse while offering flexible upgrade options

// =============================================================================
// 1. ENHANCED USAGE TRACKING SYSTEM
// =============================================================================

import { sql } from "drizzle-orm";
import { pgTable, text, varchar, integer, jsonb, timestamp, boolean, decimal } from "drizzle-orm/pg-core";

// Enhanced user table with usage tracking
export const users = pgTable("users", {
  // ... existing fields
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  email: varchar("email").unique(),
  
  // USAGE TRACKING FIELDS
  subscriptionPlan: text("subscription_plan", { 
    enum: ["foundation", "starter", "professional", "champion", "enterprise", "district_enterprise"] 
  }).default("foundation"),
  
  monthlyTournamentLimit: integer("monthly_tournament_limit").default(5),
  currentMonthTournaments: integer("current_month_tournaments").default(0),
  lastMonthReset: timestamp("last_month_reset").defaultNow(),
  
  // ABUSE PREVENTION
  registrationFingerprint: varchar("registration_fingerprint"), // Browser/device fingerprint
  registrationIP: varchar("registration_ip"),
  verifiedPhone: varchar("verified_phone"), // Phone verification for higher limits
  organizationVerified: boolean("organization_verified").default(false),
  
  // USAGE TRACKING
  totalTournamentsCreated: integer("total_tournaments_created").default(0),
  lifetimeUsageValue: decimal("lifetime_usage_value", { precision: 10, scale: 2 }).default("0"),
  
  // PAY-PER-TOURNAMENT CREDITS
  tournamentCredits: integer("tournament_credits").default(0), // Purchased tournament slots
  creditsPurchased: decimal("credits_purchased", { precision: 10, scale: 2 }).default("0"),
  
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

// Tournament credits purchases tracking
export const tournamentCredits = pgTable("tournament_credits", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull(),
  packageType: text("package_type", {
    enum: ["single_tournament", "tournament_5_pack", "tournament_10_pack", "monthly_boost"]
  }).notNull(),
  creditsAmount: integer("credits_amount").notNull(),
  priceAmount: decimal("price_amount", { precision: 10, scale: 2 }).notNull(),
  stripePaymentId: varchar("stripe_payment_id"),
  purchaseDate: timestamp("purchase_date").defaultNow(),
  expiresAt: timestamp("expires_at"), // Credits can expire
  status: text("status", {
    enum: ["pending", "completed", "failed", "refunded"]
  }).default("pending"),
});

// Usage analytics for fraud detection
export const usageAnalytics = pgTable("usage_analytics", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull(),
  actionType: text("action_type", {
    enum: ["tournament_created", "login", "credit_purchased", "limit_reached"]
  }).notNull(),
  ipAddress: varchar("ip_address"),
  userAgent: varchar("user_agent"),
  deviceFingerprint: varchar("device_fingerprint"),
  timestamp: timestamp("timestamp").defaultNow(),
  metadata: jsonb("metadata"), // Additional context
});

// =============================================================================
// 2. SMART USAGE LIMIT ENFORCEMENT
// =============================================================================

export class UsageLimitService {
  
  // Check if user can create a tournament
  static async canCreateTournament(userId: string, storage: any): Promise<{
    allowed: boolean;
    reason?: string;
    suggestedAction?: string;
    creditsAvailable?: number;
  }> {
    const user = await storage.getUser(userId);
    
    // Reset monthly counter if needed
    await this.resetMonthlyCounterIfNeeded(user, storage);
    
    // Check subscription limits
    if (user.subscriptionPlan !== 'foundation' && user.subscriptionPlan !== 'starter') {
      return { allowed: true }; // Unlimited for paid plans
    }
    
    // Check monthly limit
    if (user.currentMonthTournaments < user.monthlyTournamentLimit) {
      return { allowed: true };
    }
    
    // Check if they have credits
    if (user.tournamentCredits > 0) {
      return { 
        allowed: true, 
        creditsAvailable: user.tournamentCredits 
      };
    }
    
    // Limit reached - suggest upgrade options
    return {
      allowed: false,
      reason: `You've reached your monthly limit of ${user.monthlyTournamentLimit} tournaments`,
      suggestedAction: 'upgrade_or_buy_credits'
    };
  }
  
  // Use a tournament slot (monthly limit or credit)
  static async useTournamentSlot(userId: string, storage: any): Promise<void> {
    const user = await storage.getUser(userId);
    
    if (user.tournamentCredits > 0) {
      // Use credit first
      await storage.updateUser(userId, {
        tournamentCredits: user.tournamentCredits - 1,
        totalTournamentsCreated: user.totalTournamentsCreated + 1,
        updatedAt: new Date()
      });
    } else {
      // Use monthly allowance
      await storage.updateUser(userId, {
        currentMonthTournaments: user.currentMonthTournaments + 1,
        totalTournamentsCreated: user.totalTournamentsCreated + 1,
        updatedAt: new Date()
      });
    }
    
    // Log usage for analytics
    await storage.createUsageLog({
      userId,
      actionType: 'tournament_created',
      ipAddress: this.getCurrentIP(),
      timestamp: new Date()
    });
  }
  
  // Reset monthly counter when new month starts
  static async resetMonthlyCounterIfNeeded(user: any, storage: any): Promise<void> {
    const now = new Date();
    const lastReset = new Date(user.lastMonthReset);
    
    // Check if we're in a new month
    if (now.getMonth() !== lastReset.getMonth() || now.getFullYear() !== lastReset.getFullYear()) {
      await storage.updateUser(user.id, {
        currentMonthTournaments: 0,
        lastMonthReset: now,
        updatedAt: now
      });
    }
  }
  
  // Detect potential abuse patterns
  static async detectAbusePatterns(userId: string, storage: any): Promise<{
    suspicious: boolean;
    reasons: string[];
    confidence: number;
  }> {
    const user = await storage.getUser(userId);
    const recentLogs = await storage.getUserUsageLogs(userId, 30); // Last 30 days
    
    const suspiciousIndicators = [];
    let confidence = 0;
    
    // Check for multiple accounts from same IP/device
    const sameDeviceUsers = await storage.getUsersByFingerprint(user.registrationFingerprint);
    if (sameDeviceUsers.length > 3) {
      suspiciousIndicators.push('Multiple accounts from same device');
      confidence += 0.3;
    }
    
    // Check for rapid account creation and tournament usage
    const accountAge = Date.now() - new Date(user.createdAt).getTime();
    const daysSinceCreation = accountAge / (1000 * 60 * 60 * 24);
    
    if (daysSinceCreation < 7 && user.totalTournamentsCreated >= 5) {
      suspiciousIndicators.push('High usage on new account');
      confidence += 0.4;
    }
    
    // Check for suspicious email patterns
    if (user.email.includes('+') || user.email.match(/\d{4,}/)) {
      suspiciousIndicators.push('Suspicious email format');
      confidence += 0.2;
    }
    
    return {
      suspicious: confidence > 0.5,
      reasons: suspiciousIndicators,
      confidence
    };
  }
  
  private static getCurrentIP(): string {
    // Implementation depends on your server setup
    return 'unknown';
  }
}

// =============================================================================
// 3. PAY-PER-TOURNAMENT PACKAGES
// =============================================================================

export const TOURNAMENT_CREDIT_PACKAGES = {
  single: {
    id: 'single_tournament',
    name: 'Single Tournament',
    credits: 1,
    price: 10,
    pricePerTournament: 10,
    description: 'Perfect for one-time events',
    popular: false
  },
  small_pack: {
    id: 'tournament_5_pack',
    name: '5-Tournament Pack',
    credits: 5,
    price: 40,
    pricePerTournament: 8,
    description: 'Save $10 vs individual purchases',
    savings: 10,
    popular: true
  },
  large_pack: {
    id: 'tournament_10_pack',
    name: '10-Tournament Pack',
    credits: 10,
    price: 70,
    pricePerTournament: 7,
    description: 'Best value for active organizers',
    savings: 30,
    popular: false
  },
  monthly_boost: {
    id: 'monthly_boost',
    name: 'Monthly Boost',
    credits: 15,
    price: 90,
    pricePerTournament: 6,
    description: '15 extra tournaments this month',
    expiresInDays: 31,
    popular: false
  }
};

// =============================================================================
// 4. USAGE LIMIT UI COMPONENT
// =============================================================================

import React, { useState, useEffect } from 'react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { Progress } from '@/components/ui/progress';
import { 
  Trophy, 
  AlertTriangle, 
  CreditCard, 
  Zap, 
  TrendingUp,
  Calendar,
  Star
} from 'lucide-react';

interface UsageStatusProps {
  user: {
    subscriptionPlan: string;
    monthlyTournamentLimit: number;
    currentMonthTournaments: number;
    tournamentCredits: number;
  };
}

export function UsageStatusWidget({ user }: UsageStatusProps) {
  const [showUpgradeOptions, setShowUpgradeOptions] = useState(false);
  
  const remainingTournaments = user.monthlyTournamentLimit - user.currentMonthTournaments;
  const usagePercentage = (user.currentMonthTournaments / user.monthlyTournamentLimit) * 100;
  const totalAvailable = remainingTournaments + user.tournamentCredits;
  
  const isNearLimit = usagePercentage >= 80;
  const isAtLimit = remainingTournaments <= 0 && user.tournamentCredits <= 0;

  return (
    <Card className={`${isNearLimit ? 'border-yellow-200 bg-yellow-50' : ''} ${isAtLimit ? 'border-red-200 bg-red-50' : ''}`}>
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <Trophy className="h-5 w-5 text-blue-600" />
          Tournament Usage
          {user.subscriptionPlan === 'foundation' && (
            <Badge variant="outline" className="text-xs">Free Plan</Badge>
          )}
        </CardTitle>
        <CardDescription>
          {user.subscriptionPlan === 'foundation' || user.subscriptionPlan === 'starter'
            ? `${user.monthlyTournamentLimit} tournaments per month included`
            : 'Unlimited tournaments included'
          }
        </CardDescription>
      </CardHeader>
      
      <CardContent className="space-y-4">
        {(user.subscriptionPlan === 'foundation' || user.subscriptionPlan === 'starter') && (
          <>
            {/* Monthly Usage Progress */}
            <div>
              <div className="flex justify-between text-sm mb-2">
                <span>Monthly Usage</span>
                <span>{user.currentMonthTournaments}/{user.monthlyTournamentLimit}</span>
              </div>
              <Progress 
                value={usagePercentage} 
                className={`h-2 ${isNearLimit ? 'bg-yellow-200' : ''}`}
              />
            </div>
            
            {/* Credits Available */}
            {user.tournamentCredits > 0 && (
              <div className="bg-green-50 p-3 rounded-lg border border-green-200">
                <div className="flex items-center gap-2 text-green-800">
                  <Zap className="h-4 w-4" />
                  <span className="font-semibold">Extra Credits: {user.tournamentCredits}</span>
                </div>
                <p className="text-xs text-green-700 mt-1">
                  These credits never expire and can be used anytime
                </p>
              </div>
            )}
            
            {/* Status Alerts */}
            {isAtLimit && (
              <Alert className="border-red-200 bg-red-50">
                <AlertTriangle className="h-4 w-4 text-red-600" />
                <AlertDescription className="text-red-800">
                  <strong>Tournament limit reached!</strong> Upgrade your plan or purchase additional tournaments to continue.
                </AlertDescription>
              </Alert>
            )}
            
            {isNearLimit && !isAtLimit && (
              <Alert className="border-yellow-200 bg-yellow-50">
                <AlertTriangle className="h-4 w-4 text-yellow-600" />
                <AlertDescription className="text-yellow-800">
                  <strong>Almost at your limit!</strong> You have {totalAvailable} tournaments remaining this month.
                </AlertDescription>
              </Alert>
            )}
            
            {/* Upgrade Options */}
            {(isNearLimit || isAtLimit) && (
              <div className="space-y-3">
                <Button 
                  onClick={() => setShowUpgradeOptions(!showUpgradeOptions)}
                  variant="outline" 
                  className="w-full"
                >
                  <TrendingUp className="mr-2 h-4 w-4" />
                  View Upgrade Options
                </Button>
                
                {showUpgradeOptions && <UpgradeOptionsWidget />}
              </div>
            )}
          </>
        )}
        
        {/* Unlimited Plan Status */}
        {user.subscriptionPlan !== 'foundation' && user.subscriptionPlan !== 'starter' && (
          <div className="bg-blue-50 p-3 rounded-lg border border-blue-200 text-center">
            <div className="flex items-center justify-center gap-2 text-blue-800">
              <Star className="h-4 w-4" />
              <span className="font-semibold">Unlimited Tournaments</span>
            </div>
            <p className="text-xs text-blue-700 mt-1">
              Create as many tournaments as you need!
            </p>
          </div>
        )}
      </CardContent>
    </Card>
  );
}

// =============================================================================
// 5. UPGRADE OPTIONS WIDGET
// =============================================================================

export function UpgradeOptionsWidget() {
  return (
    <div className="space-y-4">
      <div className="border-t pt-4">
        <h4 className="font-semibold text-gray-900 mb-3">Upgrade Options</h4>
        
        {/* Pay-per-Tournament */}
        <div className="grid grid-cols-1 md:grid-cols-2 gap-3 mb-4">
          {Object.values(TOURNAMENT_CREDIT_PACKAGES).map((pkg) => (
            <Card key={pkg.id} className={`${pkg.popular ? 'border-blue-500 bg-blue-50' : 'border-gray-200'}`}>
              <CardContent className="p-4">
                <div className="flex justify-between items-start mb-2">
                  <div>
                    <h5 className="font-semibold text-sm">{pkg.name}</h5>
                    <p className="text-xs text-gray-600">{pkg.description}</p>
                  </div>
                  {pkg.popular && (
                    <Badge className="bg-blue-600 text-white text-xs">Popular</Badge>
                  )}
                </div>
                
                <div className="flex justify-between items-center">
                  <div>
                    <span className="text-lg font-bold">${pkg.price}</span>
                    <span className="text-xs text-gray-600 ml-1">
                      (${pkg.pricePerTournament}/tournament)
                    </span>
                  </div>
                  <Button size="sm" className="bg-blue-600 hover:bg-blue-700">
                    <CreditCard className="mr-1 h-3 w-3" />
                    Buy
                  </Button>
                </div>
                
                {pkg.savings && (
                  <p className="text-xs text-green-600 mt-1">Save ${pkg.savings}!</p>
                )}
              </CardContent>
            </Card>
          ))}
        </div>
        
        {/* Monthly Subscription */}
        <Card className="border-green-500 bg-green-50">
          <CardContent className="p-4">
            <div className="flex justify-between items-center">
              <div>
                <h5 className="font-semibold text-green-900">Unlimited Plan</h5>
                <p className="text-sm text-green-800">Never worry about limits again</p>
              </div>
              <div className="text-right">
                <div className="text-xl font-bold text-green-900">$99/month</div>
                <Button className="bg-green-600 hover:bg-green-700 mt-2">
                  <Calendar className="mr-2 h-4 w-4" />
                  Upgrade Now
                </Button>
              </div>
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  );
}

// =============================================================================
// 6. API ENDPOINTS FOR CREDIT PURCHASES
// =============================================================================

// Purchase tournament credits
app.post("/api/tournament-credits/purchase", async (req, res) => {
  try {
    const { packageId } = req.body;
    const userId = req.user?.id;
    
    const packageInfo = TOURNAMENT_CREDIT_PACKAGES[packageId as keyof typeof TOURNAMENT_CREDIT_PACKAGES];
    if (!packageInfo) {
      return res.status(400).json({ error: "Invalid package" });
    }
    
    // Create Stripe checkout session
    const session = await stripe.checkout.sessions.create({
      payment_method_types: ['card'],
      line_items: [
        {
          price_data: {
            currency: 'usd',
            product_data: {
              name: packageInfo.name,
              description: `${packageInfo.credits} tournament credits - ${packageInfo.description}`,
            },
            unit_amount: packageInfo.price * 100,
          },
          quantity: 1,
        },
      ],
      mode: 'payment',
      success_url: `${req.headers.origin}/dashboard?credits_purchased=true`,
      cancel_url: `${req.headers.origin}/dashboard?credits_cancelled=true`,
      metadata: {
        userId,
        packageId,
        creditsAmount: packageInfo.credits.toString(),
      },
    });

    res.json({ checkoutUrl: session.url });
  } catch (error) {
    console.error("Credit purchase error:", error);
    res.status(500).json({ error: "Purchase failed" });
  }
});

// Webhook to handle successful credit purchases
app.post("/api/webhooks/stripe-credits", async (req, res) => {
  try {
    const event = stripe.webhooks.constructEvent(
      req.body,
      req.headers['stripe-signature'],
      process.env.STRIPE_WEBHOOK_SECRET
    );

    if (event.type === 'checkout.session.completed') {
      const session = event.data.object;
      const { userId, packageId, creditsAmount } = session.metadata;
      
      const storage = await getStorage();
      
      // Add credits to user account
      const user = await storage.getUser(userId);
      await storage.updateUser(userId, {
        tournamentCredits: user.tournamentCredits + parseInt(creditsAmount),
        creditsPurchased: user.creditsPurchased + session.amount_total / 100,
        updatedAt: new Date()
      });
      
      // Log the purchase
      await storage.createCreditPurchase({
        userId,
        packageType: packageId,
        creditsAmount: parseInt(creditsAmount),
        priceAmount: session.amount_total / 100,
        stripePaymentId: session.payment_intent,
        status: 'completed'
      });
    }

    res.json({ received: true });
  } catch (error) {
    console.error("Webhook error:", error);
    res.status(400).json({ error: "Webhook failed" });
  }
});

/*
IMPLEMENTATION SUMMARY:

ðŸ”’ ABUSE PREVENTION:
âœ… Device fingerprinting to detect multiple accounts
âœ… IP tracking and suspicious pattern detection
âœ… Phone verification for higher trust levels
âœ… Email pattern analysis for fake accounts

ðŸ’° PAY-PER-TOURNAMENT OPTIONS:
âœ… Single Tournament: $10
âœ… 5-Pack: $40 ($8 each, save $10)
âœ… 10-Pack: $70 ($7 each, save $30)  
âœ… Monthly Boost: $90 (15 tournaments, expires monthly)

ðŸ“Š SMART USAGE TRACKING:
âœ… Monthly limits with automatic reset
âœ… Credit system that never expires
âœ… Usage analytics for pattern detection
âœ… Progressive upgrade suggestions

ðŸŽ¯ USER EXPERIENCE:
âœ… Clear usage status widget
âœ… Upgrade options when approaching limits
âœ… Flexible pricing for different needs
âœ… Smooth credit purchase flow

This system prevents most abuse while offering affordable expansion options!
*/